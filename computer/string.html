<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="msvalidate.01" content="9BDlx6FiNE">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wangkejie.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="基本分类： 1.朴素法：BF(Brute Force)  暴风(Brute Force)算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。      思路     首先S[1]和T[1]比较，若相等，则再比较S[2">
<meta property="og:type" content="article">
<meta property="og:title" content="字符串匹配算法">
<meta property="og:url" content="https://wangkejie.com/computer/string.html">
<meta property="og:site_name" content="王科杰">
<meta property="og:description" content="基本分类： 1.朴素法：BF(Brute Force)  暴风(Brute Force)算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。      思路     首先S[1]和T[1]比较，若相等，则再比较S[2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/24/1577174693577-bf.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/25/1577257833453-bf_code.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/25/1577260060952-kmp_longest_prefix">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/25/1577260060922-kmp_longest_prefix_1">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/25/1577260521069-kmp_longest_prefix_3">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/25/1577274995335-next_2.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/25/1577275465434-next_3.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/25/1577275521268-kmp_next.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/25/1577259144804-kmp_1.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/25/1577259144630-kmp_2.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/25/1577259144781-kmp_3.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/25/1577259144657-kmp_4.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/25/1577259144680-kmp_5.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/25/1577276557271-next_abab_1.jpg">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/25/1577276557271-next_abab_2.jpg">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577347131453-bm_bad_2.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577347131365-bm_bad_11.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577347131411-bm_good_1.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577349874546-bm_good_11.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577347131453-bm_good_2.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577354552013-bm_demo_1.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577354552008-bm_demo_2.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577354551978-bm_demo_3.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577354552009-bm_demo_4.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577354551882-bm_demo_5.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577354551857-bm_demo_6.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577354551825-bm_demo_7.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577354551911-bm_demo_8.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577354551756-bm_demo_9.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577354551619-bm_demo_11.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577354551619-bm_demo_13.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577354551592-bm_demo_14.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577362110097-sunday_1.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577362109287-sunday_2.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577362109333-sunday_3.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577364324709-sunday_code.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/26/1577367195724-rabin_karp_code.png">
<meta property="og:image" content="https://s.momocdn.com/w/u/others/2019/12/27/1577420152336-rabin_karp_code_2.png">
<meta property="article:published_time" content="2021-09-16T07:15:01.000Z">
<meta property="article:modified_time" content="2023-01-14T03:12:23.772Z">
<meta property="article:author" content="Jack Wang">
<meta property="article:tag" content="字符串">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s.momocdn.com/w/u/others/2019/12/24/1577174693577-bf.png">

<link rel="canonical" href="https://wangkejie.com/computer/string.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>字符串匹配算法 | 王科杰</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?93e26277de0cf2c5851167f2c6dcaa7d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">王科杰</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Jack's Notes</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">70</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/me/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">78</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类<span class="badge">70</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL29yZ3Mvd2FuZ2tlamllL3JlcG9zaXRvcmllcw==" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wangkejie.com/computer/string.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jack Wang">
      <meta itemprop="description" content="书山有路勤为径，学海无涯苦作舟！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="王科杰">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          字符串匹配算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-09-16 15:15:01" itemprop="dateCreated datePublished" datetime="2021-09-16T15:15:01+08:00">2021-09-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/" itemprop="url" rel="index"><span itemprop="name">字符串</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/computer/string.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/computer/string.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="基本分类："><a href="#基本分类：" class="headerlink" title="基本分类："></a>基本分类：</h2><ul>
<li><h4 id="1-朴素法：BF-Brute-Force"><a href="#1-朴素法：BF-Brute-Force" class="headerlink" title="1.朴素法：BF(Brute Force)"></a>1.朴素法：BF(Brute Force)</h4><p>  暴风(Brute Force)算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。    </p>
<ul>
<li><p><strong>思路</strong>  </p>
<p>  首先S[1]和T[1]比较，若相等，则再比较S[2]和T[2]，一直到T[M]为止；若S[1]和T[1]不等，则S向右移动一个字符的位置，再依次进行比较。如果存在k，1≤k≤N，且S[k+1…k+M]=T[1…M]，则匹配成功；否则失败。该算法最坏情况下要进行M*(N-M+1)次比较，时间复杂度为O(M*N)</p>
</li>
<li><p><strong>匹配过程</strong><br>  <img src="https://s.momocdn.com/w/u/others/2019/12/24/1577174693577-bf.png" alt="image">  </p>
</li>
<li><p><strong>代码</strong><br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577257833453-bf_code.png" alt="BF Code"></p>
</li>
</ul>
</li>
<li><h4 id="2-基于前后缀"><a href="#2-基于前后缀" class="headerlink" title="2.基于前后缀"></a>2.基于前后缀</h4><ul>
<li><p><strong>KMP</strong></p>
<ul>
<li><p><strong>思路</strong><br>  假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置。如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值），即移动的实际位数为：j - next[j]，且此值大于等于1。</p>
<p>  next 数组各值的含义：代表当前字符==之前：不包括自身==的字符串中，有多大长度的相同前缀后缀。例如如果next [j] =k，代表j之前的字符串中有最大长度为k的相同前缀后缀。此也意味着在某个字符失配时，该字符对应的next值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，==而不是跳到开头，且具体跳过了k 个字符，这就是KMP相对于BF的优化==。     </p>
</li>
<li><p><strong>最长前缀后缀表</strong><br>  对于P = p0 p1 …pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 …pk-1 pk = pj- k pj-k+1…pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。比如求模式串“ABCDABD”的最长前缀后缀表过程：<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577260060952-kmp_longest_prefix" alt="kmp_longest_prefix_1">    </p>
<p>  所以最后求得的模式串“ABCDABD”的最长前缀后缀表为：<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577260060922-kmp_longest_prefix_1" alt="kmp_longest_prefix_2">      </p>
</li>
<li><p><strong>根据前缀后缀表推导next数组</strong><br>  next 数组考虑的是==除当前字符外==的最长相同前缀后缀，所以通过前面最长前缀后缀表求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将前面最长前缀后缀表中求得的值整体右移一位，然后初值赋为-1，如下表格所示：<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577260521069-kmp_longest_prefix_3" alt="kmp_longest_prefix_3">      </p>
</li>
<li><p><strong>如何求next数组</strong>        </p>
<ul>
<li>根据前面匹配的求后一个的next<br>  给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577274995335-next_2.png" alt="next_1">     但如果====pk== != pj== 呢？说明“p0 pk-1 pk”  ≠ “pj-k pj-1 pj”。换言之，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1。所以，这个时候可以去找p[k]的前缀中有没有合适的前缀。见下图递归推导过程<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577275465434-next_3.png" alt="next_2">      </li>
<li>递归的推导过程<br>  k = next[k];<br>  待求的是p[j+1]，发现p[j] !=  p[k]，那就递归寻找p[next[k]]和p[j]是否一样，如果一样，那next[j+1] = next[next[k] + 1<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577275521268-kmp_next.png" alt="递归">      </li>
</ul>
</li>
<li><p><strong>求next数组代码</strong><br>  <a href="">见IDEA代码</a>      </p>
</li>
<li><p><strong>匹配过程</strong><br>  假设S=“ABCDAB ABCDABCDABDE”，P=“ABCDABD”    </p>
<ol>
<li>P[0]跟S[4]匹配成功，P[1]跟S[5]也匹配成功…，直到当匹配到P[6]处的字符D时失配（即S[10] != P[6]），由于P[6]处的D对应的next值为2，所以下一步用P[2]处的字符C继续跟S[10]匹配，相当于向右移动：j-next[j]=6-2=4位。<br><img src="https://s.momocdn.com/w/u/others/2019/12/25/1577259144804-kmp_1.png" alt="kmp_1"></li>
<li>向右移动4位后，P[2]处的C再次失配，由于C对应的next值为0，所以下一步用P[0]处的字符继续跟S[10]匹配，相当于向右移动：j - next[j] = 2 - 0 = 2 位。<br><img src="https://s.momocdn.com/w/u/others/2019/12/25/1577259144630-kmp_2.png" alt="kmp_2">   </li>
<li>移动两位之后，A 跟空格不匹配，模式串后移1 位。<br><img src="https://s.momocdn.com/w/u/others/2019/12/25/1577259144781-kmp_3.png" alt="kmp_3"></li>
<li>P[6]处的D再次失配，因为P[6]对应的next值为2，故下一步用P[2]继续跟文本串匹配，当于模式串向右移动 j - next[j] = 6 - 2 = 4 位。<br><img src="https://s.momocdn.com/w/u/others/2019/12/25/1577259144657-kmp_4.png" alt="kmp_4">   </li>
<li>匹配成功，过程结束。<br><img src="https://s.momocdn.com/w/u/others/2019/12/25/1577259144680-kmp_5.png" alt="kmp_5">   </li>
</ol>
</li>
<li><p><strong>kmp算法查找过程</strong><br>  <a href="">见IDEA代码</a></p>
</li>
<li><p><strong>next数组的优化</strong><br>  比如，求模式串“abab”的next 数组，可得其next 数组为-1 0 0 1，当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移j - next[j] = 3 - 1 =2位。<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577276557271-next_abab_1.jpg" alt="next_abab_1">    </p>
<p>  右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577276557271-next_abab_2.jpg" alt="next_abab_2">        </p>
<p>  问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]<br>  <a href="">见IDEA代码</a></p>
</li>
<li><p><strong>时间复杂度</strong><br>  如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。    </p>
</li>
<li><p><strong>参考资料</strong>      </p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfanVseV92L2FydGljbGUvZGV0YWlscy83MDQxODI3">July大神–从头到尾彻底理解KMP<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpJMk9UUXhNVE00T1E9PSZtaWQ9MjI0NzQ4OTg2MCZpZHg9MiZzbj01ZGI0MjdhMTM0YTQ3YmNhZWQ2MjIwNGVhMDE5M2UwNSZjaGtzbT1lYWUxZWMxNmRkOTY2NTAwODZiZjA4MGU0MjI2NDI0YWU2MTg1NjViZWYzYmIwNmZkZGVmNWZiZGJjNWUwM2UwNDNlZjdlYzM1ZGFkJm1wc2hhcmU9MSZzY2VuZT0yNCZzcmNpZD0mc2hhcmVyX3NoYXJldGltZT0xNTY2NTIzODU5NDE0JnNoYXJlcl9zaGFyZWlkPWM2NTJmM2ZlMzhhYjZhMjkyYjg0ZjQ4YmFiMTk4ZDI0I3Jk">7分钟动画理解KMP<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>BM(Boyer-Moore)</strong><br>  Boyer-Moore算法平均要比KMP快3-5倍，grep，window电脑的查找还有各种文本查找都用的BM算法。它和之前的BF和KMP匹配的过程不大一样，采用的是从后往前对比的过程。BM算法实际上包含两个并行的算法（也就是两个启发策略）：坏字符算法（bad-character shift）和好后缀算法（good-suffix shift）。这两种算法的目的就是让模式串每次向右移动尽可能大的距离     </p>
<ul>
<li><strong>思路</strong><br>  从后往前匹配。如果遇到不一致的字符，则这个字符就是==坏的字符==，所以坏字符是针对匹配串S的；匹配的路上相同的字符以及子集称为==好的后缀==，所以好的字符是针对模式串P的。每次失配时，都要根据这两个启发算法中找到能右移动的最大值。接下来详细讨论坏字符算法和好后缀算法这两个启发式。        </li>
<li><strong>启发式</strong>        <ul>
<li><strong>坏字符算法</strong><br>  当出现一个坏字符时,BM算法向右移动模式串,让模式串中==最靠右的对应字符==与坏字符相对,然后继续匹配。坏字符算法有两种情况。      <ul>
<li>case 1: 模式串中不存在坏字符。这种情况直接右移模式串P的长度       <pre><code>  ![bm_bad_1](https://s.momocdn.com/w/u/others/2019/12/26/1577347131411-bm_bad_1.png)     
</code></pre>
  比如底下的第一次匹配的字符‘d’，在模式串中不存在，直接右移模式串长度     <pre><code>  ![bm_bad_11](https://s.momocdn.com/w/u/others/2019/12/26/1577347131365-bm_bad_11.png)       
</code></pre>
</li>
<li>case 2:模式串中有对应的坏字符时，让模式串中最==靠右的对应字符==与坏字符相对<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577347131453-bm_bad_2.png" alt="bm_bad_2">       比如还是上图，在第一次右移模式串P的长度后，模式串末尾的c和主串末尾的b不匹配，说明‘b’是坏字符，但是它在模式串P中有两个出现的位置，如果用从末尾开始数的第二个‘b’会太激进，漏掉匹配；所以得用==最右边==的‘b’去匹配，这就是坏字符算法的第二种case。<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577347131365-bm_bad_11.png" alt="bm_bad_11"></li>
</ul>
</li>
<li><strong>好后缀算法</strong><br>  如果匹配了一个好后缀, 并且在模式中还有另外一个相同的完整后缀或后缀的部分, 那把下一个完整后缀或部分移动到当前后缀位置。假如说，P的后u个字符和S都已经匹配了，但是接下来的一个字符不匹配(坏字符)，我需要移动才能匹配。如果说后u个字符在P其他位置也出现过或部分出现，我们将P右移到前面的u个字符或部分和最后的u个字符或部分相同，如果说后u个字符在P其他位置完全没有出现，直接右移整个pattern。这样，好后缀算法有三种情况:     <ul>
<li>case 1:<br>  模式串中有子串和好后缀==完全匹配==，则将==失配位置前最靠右==的那个子串移动到好后缀的位置继续进行匹配<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577347131411-bm_good_1.png" alt="bm_good_1">         比如下面的例子，第一步在5的位置text的‘c’和pattern的‘b’失配了，说明‘c’是个坏字符，并且‘c’在pattern中有出现，那按照上面坏字符算法的case 2移动pattern最右边的‘c’与text失配的位置5中去继续匹配。接下来在位置7中，text的‘a’和pattern的‘b’失配了，如果坏字符的规则相当于走回头路了，所以保守一点移动一步，有没有更好的？可以看到按好字后缀的定义，8和9位置的‘ab’是好的后缀，并且它们在pattern模式串中有‘ab’和它完全匹配，那就是这种case，移动到完全匹配的位置，这样一次移动了两步，多走了一步，优秀了一点。<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577349874546-bm_good_11.png" alt="bm_good_11">     </li>
<li>case 2:<br>  模式串种字串和好后缀只能部分匹配，那就从模式串中找到具有如下特征的最长子串,使得P[m-s…m]=P[0…s]。就是从模式串P的第0个元素开始找，找能匹配最长的部分模式串(为啥从0开始而不是找最右边出现的？)<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577347131453-bm_good_2.png" alt="bm_good_2">         比如下面的例子，一利用花字符算法移动4位，然后在位置4处text的‘a’和pattern的‘b’失配了，如果按坏字符规则要走回头路，所以保守一点右移一步？看看完整的好的后缀为‘cbab’，显然pattern中没有完整能匹配这个完整的‘cbab’后缀的，那就按这种case，取最长的在pattern中出现的部分后缀‘ab’去对应，但是这里有个限制，就是如果是部分后缀匹配，那==只能从pattern的头开始==。想下为啥得这样？这样的话拿pattern的头部的‘ab’去匹配text的部分后缀‘ab’，一下就移动了4位，➡又优秀。</li>
<li>case 3:<br>  如果完全不存在和好后缀匹配的子串，则右移整个模式串，这种情况和坏字符在pattern中没有出现一样，因为怎么都不会匹配成功的                     </li>
</ul>
</li>
</ul>
</li>
<li><strong>案例分析</strong><br>  接下来拿Moore教授自己的<span class="exturl" data-url="aHR0cDovL3d3dy5jcy51dGV4YXMuZWR1L35tb29yZS9iZXN0LWlkZWFzL3N0cmluZy1zZWFyY2hpbmcvZnN0cnBvcy1leGFtcGxlLmh0bWw=">案例<i class="fa fa-external-link-alt"></i></span>来分析整个过程，模式串为EXAMPLE，主串为：HERE IS A SIMPLE EXAMPLE        <ul>
<li>上来text的‘S’和pattern的‘E’不匹配，所以‘S’是坏字符，并且‘S’在pattern中不存在，所以按照坏字符算法case 1，直接向右移动pattern的长度7位。<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354552013-bm_demo_1.png" alt="bm_demo_1">       </li>
<li>接下来text的‘P’和pattern的‘E’不匹配，所以‘P’也是坏字符，但是‘P’在pattern中存在，所以按照坏字符算法case 2，让pattern中最靠右的‘P’与之对齐，也就是向右移动2位<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354552008-bm_demo_2.png" alt="bm_demo_2">       </li>
<li>按上面移动后<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551978-bm_demo_3.png" alt="bm_demo_3">       </li>
<li>然后从末尾开始依次往前面匹配<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354552009-bm_demo_4.png" alt="bm_demo_4"><br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551882-bm_demo_5.png" alt="bm_demo_5"><br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551857-bm_demo_6.png" alt="bm_demo_6"><br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551825-bm_demo_7.png" alt="bm_demo_7"><br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551911-bm_demo_8.png" alt="bm_demo_8">   </li>
<li>注意上面的红框，在text的‘I’和pattern的‘A’失配的时候，‘I’是坏字符，而‘E’，‘LE’，‘PLE’，‘MPLE’都是好的后缀。如果按坏字符的话，因为‘I’在pattern中没有出现，那么需要整个都移动到‘I’的后面，也就是下面这样移动，只能移动==3==位：<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551756-bm_demo_9.png" alt="bm_demo_9"><br>  但是因为有这么多的好后缀（MPLE、PLE、LE、E），根据上面好后缀算法，因为MPLE在失配位置前没有完全匹配的，所以case1不满足；接下从（PLE、LE、E）这些匹配的部分后缀中找能在失配位置前==最长的==，并且从pattern的0号位置头部开始的，那只有‘E’满足，所以把pattern头部的‘E’移到和text的‘E’一样的位置重新开始匹配。这样一次就移动了==6==位！显然这样更优秀。<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551619-bm_demo_11.png" alt="bm_demo_11">     </li>
<li>接下来继续从尾到头开始匹配，上来就失配了，满足坏字符的case2，所以找到pattern的最靠右边的字符‘P’去匹配<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551619-bm_demo_13.png" alt="bm_demo_13">     </li>
<li>从尾到头去匹配，匹配成功<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551592-bm_demo_14.png" alt="bm_demo_14">     </li>
</ul>
</li>
<li><strong>参考资料</strong><br>  <span class="exturl" data-url="aHR0cDovL3d3dy5jcy51dGV4YXMuZWR1L35tb29yZS9iZXN0LWlkZWFzL3N0cmluZy1zZWFyY2hpbmcvZnN0cnBvcy1leGFtcGxlLmh0bWw=">Moore教授自己的案例demo<i class="fa fa-external-link-alt"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGFueHVlemFpcGlhby9wLzM0NTI1NzkuaHRtbA==">阿里小姐姐的分析过程<i class="fa fa-external-link-alt"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDEzLzA1L2JveWVyLW1vb3JlX3N0cmluZ19zZWFyY2hfYWxnb3JpdGhtLmh0bWw=">阮一峰的，得结合上面一起看<i class="fa fa-external-link-alt"></i></span>      </li>
</ul>
</li>
<li><p><strong>Sunday</strong>        </p>
<ul>
<li><strong>思路</strong><br>  Sunday算法最主要的特点是匹配失败的时候，关注的是主串中这一轮参与匹配的==最末位字符的下一位字符==，并且和BM不一样的是它是从前往后开始匹配。具体规则是：      <ul>
<li>如果该字符(主串失配位置的下一个字符)没有在模式串中出现则直接跳过它，即模式串右移位数 = 模式串长度 + 1。因为下一个不可能在模式串中存在，所以可以大胆的全部跳过它        </li>
<li>如果在模式串中存在，则模式串右移位数 = 模式串长度 - 该字符最右出现的位置(0开始算) = 模式串中该字符最右出现的位置到尾部的距离 + 1。和BM的坏字符的case 2类型，稳妥起见，拿最右边的相同的字符去对应匹配。     </li>
</ul>
</li>
<li><strong>案例分析</strong><br>  假设现在要在主串”substring searching”中查找模式串”search”。     <ul>
<li>刚开始时，把模式串和主串的左边对齐<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577362110097-sunday_1.png" alt="sunday_1">     </li>
<li>发现在第二个字符‘u’和‘e’的时候不匹配，根据规则，不匹配的时候关注主串这一轮参加匹配的的最末尾字符的下一个字符，即蓝色的‘i’，因为‘i’不在模式串中，所以向右移动位数 = 模式串长度 + 1 = 6 + 1 = 7，移动后如下图：<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577362109287-sunday_2.png" alt="sunday_2">     </li>
<li>继续匹配发现第一个字符就不匹配，按规则还是关注这一轮主串参加匹配的最末尾的字符的下一个字符，即蓝色的‘r’，发现它出现在模式串的倒数第3位，所以向右移动位数 = ‘r’到模式串末尾的距离 + 1 = 2 + 1 = 3，移动后如下图：<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577362109333-sunday_3.png" alt="sunday_3">     </li>
<li>匹配成功          </li>
</ul>
</li>
<li><strong>代码</strong><br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577364324709-sunday_code.png" alt="sunday_code">       </li>
<li><strong>缺点</strong><br>  Sunday算法的核心在向右移动位数move数组，这个依赖与模式串，所以有可能构造处很差的move数组(move数组的值都为1)，比如：<br>  主串：baaaabaaaabaaaabaaaa<br>  模式串：aaaaa<br>  这个模式串中，move[‘a’]的值都为1，因为最右边出现的‘a’就在末尾，所以每次失配时，只能让模式串移动1位，这就退化位BF的朴素算法了，时间复杂度也会飙升到o(m*n)，所以sunday不适合这种重复的模式串。      </li>
<li><strong>参考</strong><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yZTZlYjczODZjZDM=">参考资料<i class="fa fa-external-link-alt"></i></span>      </li>
</ul>
</li>
</ul>
</li>
<li><h4 id="3-基于hash"><a href="#3-基于hash" class="headerlink" title="3.基于hash"></a>3.基于hash</h4><ul>
<li><strong>Rabin-Karp算法</strong>        <ul>
<li><strong>背景</strong><br>  BF这种朴素的字符串匹配算法慢主要有两点：1.每一轮的比较都是一个字符一个字符去比较；2.前一次匹配的信息对于下一次匹配完全用不上。<br>  所以Rabin-Karp算法对这两点进行了改进：一是每一轮的匹配不用一个个字符去比较，而是把模式串和这一轮匹配的主串用对应的hash数值去比较，所以一次就能匹配完；二是当失配时，把第一字符去掉，然后把下一个字符加进去，重新计算hash，但是这次计算hash可以根据上次的hash在常数时间内快速的算出来，这样上一次匹配的信息也能充分利用起来      </li>
<li><strong>思路</strong><br>  比如我们要在源串”9876543210520”中查找”520”，因为这些字符串中只有数字，所以我们  可以使用字符集{‘0’,’1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’}来表示字符串中的所有元   素，并且将各个字符映射到数字0～9，然后用M表示字符集中字符的总个数，这里是10，   那么我们就可以将搜索词 “987” 转化为下面的数值：<br>  (“9”的映射值 * M + “8”的映射值) * M + “7”的映射值 = (9 * 10 + 8) * 10 + 7 = 987   分析一下这个数值：987，它可以代表字符串 “987”，其中:<br>  代表字符 “9” 的部分是“ “9”的映射值 * (M 的 n - 1 次方) = 9 * (10 的 2 次方) = 900”<br>  代表字符 “8” 的部分是“ “8”的映射值 * (M 的 n - 2 次方) = 8 * (10 的 1 次方) = 80”<br>  代表字符 “7” 的部分是“ “7”的映射值 * (M 的 n - 3 次方) = 0 * (10 的 0 次方) = 7    其实这就是987按10进制的表达方式，同理可以去算模式串“520”的hash，显然这两个hash值不相等。接下来应该把‘9’去掉，把‘6’加进来。那如何利用前面‘987’计算的hash的信息呢？首先我们把 987 减去代表字符 “9” 的部分：987 - (“9”的映射值 * (M 的 n - 1 次方)) = 987 - (9 * (10 的 2 次方)) = 987 - 900 = 87，然后再乘以 M（这里是 10），再加上 “6” 的映射值，就成了‘876’ ：87 * M + “6”的映射值 = 87 * 10 + 6 = 876。然后根据这个规则继续匹配。当两个数值相等时，未必是真正的相等，我们需要进行一次细致的检查（再进行一次朴素的字符串比较）。若不匹配，则可以排除掉，防止hash碰撞的情况。        这里我们列举的是10进制的情况，如果是ASCII 字符集的话M可以取值128；这个M值尽量取较大的素数，这样使得更多的位参与运算减少hash碰撞。如果我们要在 Unicode 字符集范围内查找“搜索词”，由于 Unicode 字符集中有 1114112 个字符，那么 M 就等于 1114112，而 Go 语言中使用 ==16777619== <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9ibG9iL21hc3Rlci9zcmMvc3RyaW5ncy9zdHJpbmdzLmdv">Go的strings源码<i class="fa fa-external-link-alt"></i></span>作为 M 的值，16777619 比 1114112 大（更大的 M 值可以容纳更多的字符，这是可以的），而且 16777619 是一个素数。这样就可以使用上面的方法计算 Unicode 字符串的数值了。进而可以对 Unicode 字符串进行比较了。      </li>
<li><strong>代码</strong><br>  计算待匹配模式串sep的hash和最高位权重的值pow<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577367195724-rabin_karp_code.png" alt="rabin_karp_code">      匹配算法<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/27/1577420152336-rabin_karp_code_2.png" alt="rabin_karp_code_2">       </li>
<li><strong>案例</strong><br>  比如在ABCDE里去匹配BCD，我们用q表示常数primeRK<br>  BCD的hash计算出来应该是B q^2 + C q + D<br>  ABC的hash应该是        A q^2 + B q + C<br>  当D来的时候如何操作的呢？根据之前的规则：<br>  [A q^2 + B q + C] q + D - A pow = A q^3 - A pow + B q^2 + C q + D<br>  而这个pow是可以和go源码里一样提前算出来的，所以在失陪时计算下一个hash能在常数时间快速得到，而两个hash值只是数值对比，一样快的飞起。</li>
<li><strong>参考</strong><br>  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9ibG9iL21hc3Rlci9zcmMvc3RyaW5ncy9zdHJpbmdzLmdv">Go的strings源码<i class="fa fa-external-link-alt"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ29sb3ZlL3AvMzIzNDY3My5odG1s">参考资料1<i class="fa fa-external-link-alt"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cubGlua2luc3Rhci53aWtpLzIwMTkvMDYvMjAvZ29sYW5nL3NvdXJjZS1jb2RlL3N0cmluZ3MtZ28tc291cmNlLWNvZGUv">参考资料2<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><strong>AC算法</strong><br>  基于前缀的AC算法，构造goto表<br>  <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hseHhjYy9hcnRpY2xlL2RldGFpbHMvNjQxMzI0MDk=">参考资料<i class="fa fa-external-link-alt"></i></span>       </li>
<li><strong>Bitmap算法</strong><br>  用一个 bit 位来标记某个元素节省存储空间<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2hhbnNodXlpL3AvNTI4NzgyNS5odG1s">参考资料<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div>希望对您有所帮助，您的支持将是我莫大的动力！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Jack Wang 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Jack Wang 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag"># 字符串</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/luafile/index.html" rel="prev" title="lua相关">
      <i class="fa fa-chevron-left"></i> lua相关
    </a></div>
      <div class="post-nav-item">
    <a href="/luafile/luacode.html" rel="next" title="Lua源码学习">
      Lua源码学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="nav-number">1.</span> <span class="nav-text">基本分类：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%9C%B4%E7%B4%A0%E6%B3%95%EF%BC%9ABF-Brute-Force"><span class="nav-number">1.0.1.</span> <span class="nav-text">1.朴素法：BF(Brute Force)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%9F%BA%E4%BA%8E%E5%89%8D%E5%90%8E%E7%BC%80"><span class="nav-number">1.0.2.</span> <span class="nav-text">2.基于前后缀</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%9F%BA%E4%BA%8Ehash"><span class="nav-number">1.0.3.</span> <span class="nav-text">3.基于hash</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">1.1.</span> <span class="nav-text">其他</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jack Wang"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Jack Wang</p>
  <div class="site-description" itemprop="description">书山有路勤为径，学海无涯苦作舟！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">78</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29yZ3Mvd2FuZ2tlamllL3JlcG9zaXRvcmllcw==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;orgs&#x2F;wangkejie&#x2F;repositories"><i class="github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOjcyNzg4MTk0NUBxcS5jb20=" title="E-Mail → mailto:727881945@qq.com"><i class="envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><span class="exturl" data-url="aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbg==">京ICP备16036665号-2 </span>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jack Wang</span>
</div>

        


  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1277804316&web_id=1277804316"></script>
  </div>






      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'S7tR3Qqx6JSg8P5ChLXjLWt8-gzGzoHsz',
      appKey     : 'hHRdJzqrf8zU1xQElb7km39u',
      placeholder: "上面也可以填入联系方式，感谢您宝贵的建议~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
