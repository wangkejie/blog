<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>我的博客首页</title>
    <url>/home.html</url>
    <content><![CDATA[<!-- 标签别名 -->
<!-- <center>【置顶】</center> -->
<!-- hext-next文档 -->
<!-- https://theme-next.js.org/docs/advanced-settings/front-matter.html?highlight=hexo+generator+index -->


<!-- 待翻阅博客 -->
<!-- http://chuquan.me/2021/02/14/understand-ios-library-and-framework/ -->
<!-- https://blog.csdn.net/m_miao001/article/details/81671692 -->
<!-- https://www.jianshu.com/p/231b1cebf477 -->

<h1 id="欢迎来到我的博客"><a href="#欢迎来到我的博客" class="headerlink" title="欢迎来到我的博客"></a>欢迎来到我的博客</h1><blockquote>
<p>学习一些东西，记录一些东西。 左侧边栏有<code>搜索</code>框，可以关键字检索整个博客内容。</p>
</blockquote>
<h2 id="记录-索引"><a href="#记录-索引" class="headerlink" title="记录/索引"></a>记录/索引</h2><ul>
<li><a href="./iOS/performance/modularization.html">组件化记录-未完</a></li>
<li><a href="./sumup/sumupthepast.html">总结过去-未完</a></li>
<li><a href="./acrossplatform/breakpad">Breakpad跨平台Crash Report解决方案</a></li>
<li><a href="./os/dyld">dyly-简阅</a></li>
<li><a href="./luafile/lua-patch">OC热修复方案 - 草稿中</a></li>
<li><a href="./luafile/luacode">lua源码学习</a></li>
<li><a href="./iOS/fishhook">fishhook crash</a></li>
<li><a href="./computer/string">字符串匹配算法</a></li>
<li><a href="./iOS/performance/wildpoint">野指针-未完</a></li>
<li><a href="">oom-卡顿等-未开始</a></li>
<li><a href="./luafile/">Lua相关</a></li>
</ul>
<h2 id="不忘初心"><a href="#不忘初心" class="headerlink" title="不忘初心"></a>不忘初心</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9uYXZpZ2F0aW9uLw==">Apple官方文档<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oaXQtYWxpYmFiYS5naXRodWIuaW8vaW50ZXJ2aWV3L2Jhc2ljL25ldHdvcmsvVENQLmh0bWw=">计算机知识点<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGlhb2xpbmNvZGluZy9wLzEzNjMxMjI0Lmh0bWw=">计算机调度算法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zd2lmdC5nZy8=">Swift 翻译组<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zd2lmdC5vcmcvc291cmNlLWNvZGUv">Swift source code<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscw==">苹果源码库<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="面试快餐"><a href="#面试快餐" class="headerlink" title="面试快餐"></a>面试快餐</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvNmNrUm55QUFMYkNzWGZadTU2a1REdw==">离屏渲染等原理<i class="fa fa-external-link-alt"></i></span></li>
<li>SideTable相关（主要用来引用计数和weak表）<br>  定义在objc-private文件下。  由<code>static objc::ExplicitInit&lt;StripedMap&lt;SideTable&gt;&gt; SideTablesMap;</code> 全局静态变量<br>  类型为StripedMap，iOS有8张SideTable表，mac有64张， 重载了[]方法，可以通过对象指针分配其中一张表Sidetable，<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xM2M0ZmIxY2VkZWE=">https://www.jianshu.com/p/13c4fb1cedea<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xHQmFtYm9vL2lPUy1hcnRpY2xlLjAyL2Jsb2IvbWFpbi8lRTklOTglQkYlRTklODclOEMlRTMlODAlODElRTUlQUQlOTclRTglOEElODJpT1MlRTklOUQlQTIlRTglQUYlOTUlRTklQTIlOTglRTQlQjklOEJSdW50aW1lJUU3JTlCJUI4JUU1JTg1JUIzJUU5JTk3JUFFJUU5JUEyJTk4MiVFRiVCQyU4OCVFOSU5OSU4NCVFNyVBRCU5NCVFNiVBMSU4OCVFRiVCQyU4OS5tZA==">gihub面试大全<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li>关联对象。 解决weak可以包装一层，属性弱引用。</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjUxY3RvLmNvbS91XzE1Mjk1NDg4LzMxMjk0NzM=">HTTP3.0<i class="fa fa-external-link-alt"></i></span><br>  TCP四元组(源IP、源端口、目标IP、目的端口)，网络发生变化的时候，重连。QUIC采用Connection ID不关心四元组</li>
<li>AutoReleasePool 与线程一一对应，page结构体中有thread成员。 TLS(Thread local Stroge)hotPage。 嵌套用哨兵对象</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jMTc5M2JjMmNhMTM=">为什么会有元类的设计<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ub25nY2hhb3poZS5naXRodWIuaW8vMjAxOS8wOS8wOC9pc0VxdWFsJUU1JTkyJThDaGFzaCVFNyU5QSU4NCVFNSU4NSVCMyVFNyVCMyVCQi8=">isEqual 和 hash<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="以后慢慢积累补充"><a href="#以后慢慢积累补充" class="headerlink" title="以后慢慢积累补充"></a>以后慢慢积累补充</h2><ul>
<li><a href="./iOS/crashrepaort/crashanalysis.html">iOS程序崩溃和抓取原理</a></li>
<li><a href="./python/index.html">Python</a> 未完待续，后期慢慢补上<ul>
<li>学习来源github 共勉之！(<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2phY2tmcnVlZC9QeXRob24tMTAwLURheXM=">https://github.com/jackfrued/Python-100-Days<i class="fa fa-external-link-alt"></i></span>)</li>
<li>微软出了一个《Develop With Python on Windows》<br>  (<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vemgtY24vd2luZG93cy9weXRob24vZ2V0LXN0YXJ0ZWQvcHl0aG9uLWZvci1lZHVjYXRpb24=">https://docs.microsoft.com/zh-cn/windows/python/get-started/python-for-education<i class="fa fa-external-link-alt"></i></span>)</li>
</ul>
</li>
<li><a href="./vue/qa.html">Vue</a></li>
<li><a href="./linux/home.html">Linux相关知识点</a></li>
<li>Swift</li>
<li>Flutter</li>
</ul>
<h2 id="关于iOS基础技术部分"><a href="#关于iOS基础技术部分" class="headerlink" title="关于iOS基础技术部分"></a>关于iOS基础技术部分</h2><ul>
<li>你可以点击<a href="./categories/">iOS目录</a>，查看更详细的大纲<ul>
<li><a href="./iOS/objective-c/index.html">OC相关基础</a></li>
<li><a href="./iOS/multithreading/index.html">多线程</a></li>
<li><a href="./iOS/RunTime/index.html">RunTime</a></li>
<li><a href="./iOS/RunLoop/index.html">RunLoop</a></li>
<li><a href="./iOS/Autoreleasepool.html">AutoReleasePool</a></li>
<li><a href="./iOS/block/index.html">block相关</a></li>
<li><a href="./iOS/animation/index.html">animation动画</a></li>
<li><a href="./iOS/algorithm/index.html">算法收集</a></li>
<li><a href="./iOS/memorymanagerment/memory.html">内存管理</a></li>
<li><a href="./iOS/performance/index.html">iOS优化</a></li>
<li><a href="./iOS/kernelarchitecture/overview.html">苹果内核架构</a></li>
<li><a href="./iOS/kernelarchitecture/mach.html">mach内核</a></li>
<li><a href="./iOS/thirdpart/asdk.html">AsyncDisplayKit</a></li>
<li><a href="./iOS/hybrid/hybrid.html">Hybrid浅谈</a></li>
</ul>
</li>
<li><a href="./categories/iOS/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/">iOS源码学习</a><ul>
<li><a href="./iOS/origincode/metaclass.html">什么是元类</a></li>
<li><a href="./iOS/origincode/origincodestudy.html">类的本质</a></li>
<li><a href="./iOS/origincode/category.html">分类</a></li>
</ul>
</li>
<li><a href="./categories/iOS/Third-Party-Lib/">第三方库学习</a><ul>
<li><a href="./iOS/thirdpart/sdwebimage.html">SDWebImage</a></li>
<li><a href="iOS/thirdpart/glide.html">Glide</a></li>
</ul>
</li>
<li><a href="./categories/OS/">操作系统</a><ul>
<li><a href="os/ios-macos.html">MacOS和iOS操作系统</a></li>
</ul>
</li>
</ul>
<h2 id="快餐"><a href="#快餐" class="headerlink" title="快餐"></a>快餐</h2><ul>
<li><a href="./iOS/interview/">部分索引</a></li>
<li><a href="./iOS/interview/memory">内存管理</a></li>
<li><a href="./iOS/interview/xingneng">性能优化</a></li>
</ul>
<h2 id="待处理的事情-计划"><a href="#待处理的事情-计划" class="headerlink" title="待处理的事情/计划"></a>待处理的事情/计划</h2><ol>
<li>项目总结、沉淀</li>
<li>把收集的书籍列出来，标记已读和未读，已读的写读后感，未读的写推荐原因</li>
<li>规划5年/10年/未来（参考下面规划）</li>
</ol>
<h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>思考了一下，职场上，需要高调做事儿，私下还要低调做人。维护不好职场上的人际关系，也是不好有出路的。由于个人偏内向性格，喜欢钻研一些未知的东西，在以后的发展道路上，可能更适合往技术方向发展。 那么问题来了，年龄的增长一定会削弱钻研的buff，伴随着也会出现瓶颈，所以，势必得规划好转型。</p>
<p>技术方向，终归是个打工仔，技术再牛，也可能只是保住有个工作。</p>
<ul>
<li>技术深造。深度挖掘某个领域，如有创新更好。难~</li>
<li>技术转型。人工智能、web3等。只是多个就业路子~</li>
</ul>
<p>其他方向</p>
<ul>
<li>管理。主要看机遇，需要多表现这方面的倾向，多展露这方面的才能。</li>
<li>创业。倾家荡产。</li>
<li>老师/培训。半创业。</li>
</ul>
<h2 id="其它博客"><a href="#其它博客" class="headerlink" title="其它博客"></a>其它博客</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmliaXJlbWUuY29tLw==">YY<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc3Vubnl4eC5jb20v">孙源sunny<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmRldnRhbmcuY29tLw==">唐巧<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9taW5nMTAxNi5naXRodWIuaW8v">戴铭<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9vbmV2Y2F0LmNvbS8=">王巍<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zYXRhbndvby5naXRodWIuaW8vMjAxNy8xMC8xOC9hYm9ydC8=">SatanWoo<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82OTNlYzk2MmIzZDM=">GCD看这一篇就够了<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="我的公众号"><a href="#我的公众号" class="headerlink" title="我的公众号"></a>我的公众号</h2><img src="/images/wechatpublic.jpg" class="" title="我的公众号">





<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lM2Q1MjFiMmNiNDM=">需要反复阅读文章及子文章<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>


<!-- - http://www.progressmore.com -->
<!-- https://objccn.io/issue-3-1/ -->  
<!-- https://www.jianshu.com/p/e0277ac633bc -->


<!-- <div >
<img style="width: 40%;display:inline-block;margin:0" src='/images/iOS/exception_handler.png' />
<img style="width: 40%;display:inline-block;margin:0" src='/images/iOS/exception_handler.png' />
</div>
dskjdhjksgdhjs -->
]]></content>
      <tags>
        <tag>文章索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Breakpad</title>
    <url>/acrossplatform/breakpad.html</url>
    <content><![CDATA[<h1 id="Momo-跨平台的crash-report解决方案"><a href="#Momo-跨平台的crash-report解决方案" class="headerlink" title="Momo 跨平台的crash-report解决方案"></a>Momo 跨平台的crash-report解决方案</h1><ul>
<li>最近负责公司的质量平台建设，参与了陌陌的crash-report方案设计和开发。 </li>
<li>经过优化封装后，已对外使用，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nvc21vczMzL01NU3BlY3MvY29tbWl0cy9tYXN0ZXIvUmlmbGU=">组件地址<i class="fa fa-external-link-alt"></i></span></li>
<li>使用方式请联系<span class="exturl" data-url="aHR0cHM6Ly9jb3Ntb3MuaW1tb21vLmNvbS8=">陌陌企业服务<i class="fa fa-external-link-alt"></i></span></li>
<li><a href="../iOS/crashreport/crashanalysis.html">iOS程序崩溃和抓取原理</a></li>
</ul>
<h1 id="Crash-背景"><a href="#Crash-背景" class="headerlink" title="Crash 背景"></a>Crash 背景</h1><p>对于所有崩溃场景，仅25%的崩溃可通过信号量捕获，实施相应改进；另有75%的崩溃则难以识别，从而对App的用户体验，造成了巨大的潜在影响。</p>
<img src="/images/iOS/crash_capture.png" class="" title="捕获crash">


<p>Facebook的工程师将App退出分为以下6个类别：<br>1.App内部主动调用exit()或abort()退出；<br>2.App升级过程中，用户进程被杀死；<br>3.系统升级过程中，用户进程被杀死；<br>4.App在后台被杀死；<br>5.App在前台被杀死，且可获取堆栈；<br>6.App在前台被杀死，且无法获取堆栈。</p>
<img src="/images/iOS/facebookoom.jpeg" class="" title="捕获crash">

<p>对于第1～4类退出，属于App的正常退出，对用户体验没有太大影响，无需进行相应处理；对于第5类退出，可通过堆栈代码级定位崩溃原因，对此业界已形成比较成熟的解决方案，；对于第6类退出，可能的原因很多，包括但不限于：系统内存不足时继续申请内存、主线程卡死20s以上、CPU使用率过高Stack Overflow等，在此我们统一称之为iOS客户端的“Abort问题”。<br>Abort问题无法被堆栈捕获，且发生频次远高于可被捕获的崩溃（下称“堆栈崩溃”）。从历史数据来看，手淘（电商类超级App代表）的Abort问题数量一般是堆栈崩溃数量的3倍左右；优酷Pad（视频类超级App代表）的Abort问题数量一般是堆栈崩溃数量的5倍左右。可见，Abort问题对用户的使用体验造成巨大影响。<br>本文将针对iOS客户端的Abort问题，进行根因定位分析，并提出系统性解决方案。</p>
<p>对于oom，除了facebook的排除法，还有字条抖音的 Memory Graph主动分析方式，参看<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpJMU16WXpNakUwTVE9PSZtaWQ9MjI0NzQ4Njg1OCZpZHg9MSZzbj1lYzU5NjRiMDI0OGIzNTI2ODM2NzEyYjI2ZWYxYjA3NyZjaGtzbT1lOWQwYzY2OGRlYTc0ZjdlMWUxNmNkNWQ2NWQxNDM2YzI4YzE4ZTgwZTMyYmJmOTcwMzc3MWJkNGUwNTYzZjY0NzIzMjk0YmExMzI0JnRva2VuPTE0ODM2MjEyMzYmbGFuZz16aF9DTiZzY2VuZT0yMSN3ZWNoYXRfcmVkaXJlY3Q=">iOS性能优化实践：头条抖音如何实现OOM崩溃率下降50%+<i class="fa fa-external-link-alt"></i></span><br>微信 <span class="exturl" data-url="aHR0cHM6Ly93ZXRlc3QucXEuY29tL2xhYi92aWV3LzM2Ny5odG1s">https://wetest.qq.com/lab/view/367.html<i class="fa fa-external-link-alt"></i></span></p>
<p>task_vm_info.phys_footprint: 47.4MB<br>task_info.resident_size: 80MB</p>
<h2 id="Abort问题的原因分类"><a href="#Abort问题的原因分类" class="headerlink" title="Abort问题的原因分类"></a>Abort问题的原因分类</h2><p>形成Abort问题的原因主要包括以下4个。<br>1 内存 Jetsam<br>移动端设备的物理内存资源紧张，但App仍不断申请内存。因此系统signal 9杀死进程，造成异常退出。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>   <span class="attr">&quot;memoryPages&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span>     <span class="attr">&quot;active&quot;</span> <span class="punctuation">:</span> <span class="number">24493</span><span class="punctuation">,</span>     <span class="attr">&quot;throttled&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>     <span class="attr">&quot;fileBacked&quot;</span> <span class="punctuation">:</span> <span class="number">24113</span><span class="punctuation">,</span>     <span class="attr">&quot;wired&quot;</span> <span class="punctuation">:</span> <span class="number">13007</span><span class="punctuation">,</span>     <span class="attr">&quot;anonymous&quot;</span> <span class="punctuation">:</span> <span class="number">12915</span><span class="punctuation">,</span>     <span class="attr">&quot;purgeable&quot;</span> <span class="punctuation">:</span> <span class="number">127</span><span class="punctuation">,</span>     <span class="attr">&quot;inactive&quot;</span> <span class="punctuation">:</span> <span class="number">10955</span><span class="punctuation">,</span>     <span class="attr">&quot;free&quot;</span> <span class="punctuation">:</span> <span class="number">2290</span><span class="punctuation">,</span>     <span class="attr">&quot;speculative&quot;</span> <span class="punctuation">:</span> <span class="number">1580</span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  <span class="attr">&quot;uncompressed&quot;</span> <span class="punctuation">:</span> <span class="number">125795</span><span class="punctuation">,</span>  <span class="attr">&quot;decompressions&quot;</span> <span class="punctuation">:</span> <span class="number">143684</span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  <span class="attr">&quot;largestProcess&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Taobao4iPhone&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;processes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span>  <span class="punctuation">&#123;</span>  ...  <span class="punctuation">&#123;</span>     <span class="attr">&quot;rpages&quot;</span> <span class="punctuation">:</span> <span class="number">2050</span><span class="punctuation">,</span>     <span class="attr">&quot;states&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span>       <span class="string">&quot;frontmost&quot;</span><span class="punctuation">,</span>       <span class="string">&quot;resume&quot;</span>     <span class="punctuation">]</span><span class="punctuation">,</span>     <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Taobao4iPhone&quot;</span><span class="punctuation">,</span>     <span class="attr">&quot;pid&quot;</span> <span class="punctuation">:</span> <span class="number">1518</span><span class="punctuation">,</span>     <span class="attr">&quot;reason&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;vm-thrashing&quot;</span><span class="punctuation">,</span>     <span class="attr">&quot;fds&quot;</span> <span class="punctuation">:</span> <span class="number">50</span><span class="punctuation">,</span>     <span class="attr">&quot;uuid&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;5103a88a-917f-319e-8553-c0189dd1abac&quot;</span><span class="punctuation">,</span>     <span class="attr">&quot;purgeable&quot;</span> <span class="punctuation">:</span> <span class="number">127</span><span class="punctuation">,</span>     <span class="attr">&quot;cpuTime&quot;</span> <span class="punctuation">:</span> <span class="number">4.619693</span><span class="punctuation">,</span>     <span class="attr">&quot;lifetimeMax&quot;</span> <span class="punctuation">:</span> <span class="number">3557</span>  <span class="punctuation">&#125;</span><span class="punctuation">,</span>  ...  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>2 主线程死锁<br>A/B两个线程同时等待对方完成某些操作，因而无法继续执行，形成死锁，造成异常退出。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Exception</span> Type:  <span class="number">00000020</span>Exception Codes: <span class="number">0</span>x000000008badf00dHighlighted Thread:  <span class="number">0</span> Application Specific Information:com.myapp.myapp failed to scene-create in time Elapsed total CPU time (seconds): <span class="number">4</span>.<span class="number">230</span> (user <span class="number">4</span>.<span class="number">230</span>, system <span class="number">0</span>.<span class="number">000</span>), <span class="number">10</span>% CPU Elapsed application CPU time (seconds): <span class="number">1</span>.<span class="number">039</span>, <span class="number">3</span>% CPU Thread <span class="number">0</span> name:  Dispatch queue: com.apple.main-threadThread <span class="number">0</span>:<span class="number">0</span>   libsystem_kernel.dylib          <span class="number">0</span>x36360540 semaphore_wait_trap + <span class="number">81</span>   libdispatch.dylib               <span class="number">0</span>x36297eee _dispatch_semaphore_wait_slow + <span class="number">1862</span>   libxpc.dylib                    <span class="number">0</span>x364077b8 xpc_connection_send_message_with_reply_sync + <span class="number">1523</span>   Security                        <span class="number">0</span>x2b8dd310 securityd_message_with_reply_sync + <span class="number">644</span>   Security                        <span class="number">0</span>x2b8dd48c securityd_send_sync_and_do + <span class="number">445</span>   Security                        <span class="number">0</span>x2b8ea452 __SecItemCopyMatching_block_invoke + <span class="number">1666</span>   Security                        <span class="number">0</span>x2b8e96f6 SecOSStatusWith + <span class="number">147</span>   Security                        <span class="number">0</span>x2b8ea36e SecItemCopyMatching + <span class="number">174</span></span><br></pre></td></tr></table></figure>
<p>3 启动/重启超时<br>App由于启动/重启的时间超过系统允许的时间限制，造成异常退出。</p>
<blockquote>
<p>scene-create watchdog transgression: app exhausted real (wall clock) time allowance of 19.93 seconds, Elapsed total CPU time (seconds): 21.050 (user 21.050, system 0.000)</p>
</blockquote>
<p>4 CPU打爆<br>主线程死锁、启动/重启超时，都可能间接导致CPU打爆，造成异常退出。</p>
<p>1.Abort问题发生的场景：例如，哪个页面、什么操作。<br>2.Abort问题发生的原因：例如，内存Jetsam、主线程死锁、启动/重启超时、CPU打爆。<br>3.对于内存Jetsam，需进一步定位到是否发生了内存泄露以及泄露的循环引用（Retain Cycle）。<br>4.对于主线程死锁，需进一步定位到卡死的堆栈。<br>5.对于启动/重启超时，以及CPU打爆，需进一步定位到堆栈。</p>
<h2 id="abort问题的系统性解决方案"><a href="#abort问题的系统性解决方案" class="headerlink" title="abort问题的系统性解决方案"></a>abort问题的系统性解决方案</h2><ol start="0">
<li>现场捕获<br>为实现Abort问题的系统性解决方案，需充分考虑以下问题：<br> 1.通过signal 9杀死进程造成的Abort问题，往往难以通过信号量捕获至堆栈。在这种情况下，应如何尽可能完整地捕获崩溃现场的关键信息？具体包含哪些信息？<br> 2.App崩溃时系统处于极不稳定的状态，应如何保证崩溃现数据稳定落盘？<br> 3.在信息采集、数据捕获的过程中，需对大量数据进行写入操作，应如何保证日志高性能写入？<br> 4.在数据量较大的情况下，数据的存储、上传可能对系统造成较大压力，应如何保证数据的高压缩率？<blockquote>
<p>基于以上考虑，我们提出并设计了一套基于mmap的高性能、高压缩率、高一致性、可自解释的trace文件协议，作为iOS端高可用体系的数据载体。</p>
</blockquote>
</li>
</ol>
<ol>
<li><p>mmap数据存储层保证数据写入的高性能和高一致性</p>
<ul>
<li>通过mmap将一个文件或者其它对象映射到进程的地址空间，对内存的操作会由内核将数据写到对应的磁盘文件上；数据写入的性能与内存操作相当（略比内存操作高）</li>
<li>用户进程崩溃之后，这块映射区仍由内核管理，可以保证数据的一致性</li>
</ul>
</li>
<li><p>二进制编码协议保证数据压缩率最高</p>
<ul>
<li>具体编码协议</li>
<li>实测编码在压缩率能达到80%以上，或者直观一点说，使用50k的内存可以记录下用户二十分钟内详细的使用记录，包括页面访问记录、系统事件、秒级别的内存、CPU数据。</li>
</ul>
</li>
<li><p>尽可能多的记录系统多维度指标及异常事件包括：</p>
<ul>
<li>性能数据，包括CPU、内存数据，用于判断应用当前是不是处理overload状态</li>
<li>大内存申请</li>
<li>Retain Cycle，用于定位Jetsam Event</li>
<li>卡顿，用于定位watch dog kill</li>
<li>当前存活VC实例数量</li>
</ul>
</li>
</ol>
<img src="/images/iOS/crashmmp.png" class="" title="mmp">

<h1 id="BreakPad-跨平台的crash-report解决方案"><a href="#BreakPad-跨平台的crash-report解决方案" class="headerlink" title="BreakPad 跨平台的crash-report解决方案"></a>BreakPad 跨平台的crash-report解决方案</h1><p><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL2JyZWFrcGFkL2JyZWFrcGFk">官方地址<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9icmVha3BhZA==">Github地址<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="介绍breakpad"><a href="#介绍breakpad" class="headerlink" title="介绍breakpad"></a>介绍breakpad</h1><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><img src="/images/general/breakpad-rifle.jpeg" class="" title="breakpad流程">


<h2 id="breakpad原理图"><a href="#breakpad原理图" class="headerlink" title="breakpad原理图"></a>breakpad原理图</h2><img src="/images/general/breakpad-1.png" class="" title="breakpad原理">

<p>主要包括三个部分</p>
<ul>
<li><code>dumpSyms</code>    负责 读取 用户开发应用中的debug信息   并生成特定的符号文件<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9icmVha3BhZC9ibG9iL21hc3Rlci9kb2NzL3N5bWJvbF9maWxlcy5tZA==">参考<i class="fa fa-external-link-alt"></i></span></li>
<li><code>client</code>   在崩溃系统中也就是指的崩溃上报的sdk   负责抓取当前线程和当前载入的库 生成 minidump文件</li>
<li><code>processor</code> 也就是崩溃系统中的mnidump_stackwalk    读取minidump文件 找到合适的符号文件 产生一个人类可读的c/c++调用栈</li>
</ul>
<h3 id="MiniDump文件格式"><a href="#MiniDump文件格式" class="headerlink" title="MiniDump文件格式"></a>MiniDump文件格式</h3><ul>
<li>minidump文件格式是由微软开发的用于崩溃上传，它包括：<ul>
<li>当dump生成时进程中一系列executable和shared libraries, 包括这些文件的文件名和版本号。</li>
<li>进程中的线程列表，对于每个线程，minidump包含它在寄存器中的状态，线程的stack memory内容。这些数据都是未解析的字节流，Breakpad client通常没有调试信息（debugging information）能生成函数名，行号，甚至无法确定stack frame的边界。</li>
<li>其他收集关于系统的信息，如：处理器，操作系统高版本，dump的原因等等。</li>
</ul>
</li>
<li>breakpad在所有平台上（windows/linux等）都统一使用minidump文件格式，而不使用core files，原因是因为：<ul>
<li>core files可能很大，而minidump比较小。</li>
<li>core files文档不全</li>
<li>很难说服windows机器去生成core files，但可以说服其他机器来生成minidump文件。</li>
<li>breakpad只支持一种统一的格式会比较简单，而不是同时支持多种格式。</li>
</ul>
</li>
</ul>
<h3 id="Symbols文件格式"><a href="#Symbols文件格式" class="headerlink" title="Symbols文件格式"></a>Symbols文件格式</h3><p>symbols文件是基于纯文本的，每一行一条记录，每条记录中的字段以一个空格作为分隔符，每条记录的第一个字段表示这一行是什么类型的记录。</p>
<p>记录类型：</p>
<ul>
<li>模块记录：<code>MODULE</code> operatingsystem architecture id name</li>
<li>文件记录：<code>FILE</code> number name</li>
<li>函数记录：<code>FUNC</code> address size parameter_size name</li>
<li>行号记录：<code>address size line filenum</code></li>
<li>PUBLIC记录：<code>PUBLIC</code> address parameter_size name</li>
<li><code>STACK WIN</code></li>
<li><code>STACK CFI</code></li>
</ul>
<h3 id="不同平台的实现原理"><a href="#不同平台的实现原理" class="headerlink" title="不同平台的实现原理"></a>不同平台的实现原理</h3><p>默认情况下，当崩溃时breakpad会生成一个minidump文件，在不同平台上的实现机制不一样：</p>
<p>在windows平台上，使用微软提供的 SetUnhandledExceptionFilter() 方法来实现。<br>在OS X平台上，通过创建一个线程来监听 Mach Exception port 来实现。<br>在Linux平台上，通过设置一个信号处理器来监听 SIGILL SIGSEGV 等异常信号。</p>
<h3 id="发送minidump文件"><a href="#发送minidump文件" class="headerlink" title="发送minidump文件"></a>发送minidump文件</h3><p>在真实环境中，你通常需要以某种方式来处理minidump文件，例如把它发送给服务器来进行分析，Breakpad源码提供了一些HTTP上传的代码，并提供一个minidump上传工具（ 详见minidump_upload.cc）。</p>
<h3 id="生成symbols文件"><a href="#生成symbols文件" class="headerlink" title="生成symbols文件"></a>生成symbols文件</h3><p>为了生成可读的stack trace， breakpad需要你将binaries里的调试符号（debugging symbols）转换成基于文本格式的symbol files。</p>
<p>首先确保你在编译代码的时候加上 -g 参数来生成带调试符号的。</p>
<p>然后使用 configure &amp;&amp; make breakpad源码来生成 <code>dump_syms</code> 工具。</p>
<h3 id="生成Stack-Trace"><a href="#生成Stack-Trace" class="headerlink" title="生成Stack Trace"></a>生成Stack Trace</h3><p>breakpad包含一个叫做 minidump_stackwalk 的工具来将 minidump 文件，外加symbol files来生成一个人可读的stack trace。在编译breakpad后，这个工具一般在 google-breakpad/src/processor 目录下， 通过将 minidump 和 symbol files 传入给它即可：</p>
<h2 id="客户端功能"><a href="#客户端功能" class="headerlink" title="客户端功能"></a>客户端功能</h2><p>每次crash都会生成三部分文件，目录结构如下</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">└── 根目录</span><br><span class="line">    ├── basic<span class="selector-class">.json</span>  <span class="comment">//基础信息,展示在crash详情页</span></span><br><span class="line">    │</span><br><span class="line">    ├── logs	<span class="comment">//业务方自定义日志,在展示在跟踪日志中</span></span><br><span class="line">    │   ├── log_1<span class="selector-class">.txt</span></span><br><span class="line">    │   ├── log_2<span class="selector-class">.txt</span></span><br><span class="line">    │   └── log_3<span class="selector-class">.txt</span></span><br><span class="line">    │</span><br><span class="line">    └── stack.dmp（Android Native Crash / iOS Crash生成次文件）<span class="comment">//堆栈信息,用于定位问题</span></span><br><span class="line">    │</span><br><span class="line">    └── logcat<span class="selector-class">.log</span> (控制台日志文件，<span class="number">2020</span>年<span class="number">11</span>月<span class="number">09</span>日<span class="number">14</span>:<span class="number">52</span>:<span class="number">07</span>添加，暂时只有android)</span><br><span class="line">    │</span><br><span class="line">    └── jvm<span class="selector-class">.dmp</span> (Android Java 堆栈信息)  <span class="comment">//安卓独有</span></span><br></pre></td></tr></table></figure>


<h2 id="接下来写一篇KSCrash读后感"><a href="#接下来写一篇KSCrash读后感" class="headerlink" title="接下来写一篇KSCrash读后感"></a>接下来写一篇KSCrash读后感</h2><p>kscm_handleException</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yOTVlYmY0MmIwNWI=">https://www.jianshu.com/p/295ebf42b05b<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODY4MjMwNTUyNTcxMzQ2OTUx">https://juejin.cn/post/6868230552571346951<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9lbmdpbmVlcmluZy5mYi5jb20vMjAxNS8wOC8yNC9pb3MvcmVkdWNpbmctZm9vbXMtaW4tdGhlLWZhY2Vib29rLWlvcy1hcHAv">https://engineering.fb.com/2015/08/24/ios/reducing-fooms-in-the-facebook-ios-app/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93ZXRlc3QucXEuY29tL2xhYi92aWV3LzM2Ny5odG1s">https://wetest.qq.com/lab/view/367.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Crash Report</category>
        <category>性能</category>
      </categories>
      <tags>
        <tag>Breakpad</tag>
        <tag>crash</tag>
        <tag>oom</tag>
        <tag>性能</tag>
        <tag>崩溃</tag>
      </tags>
  </entry>
  <entry>
    <title>https</title>
    <url>/computer/https.html</url>
    <content><![CDATA[<h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><p>SSL 的握手协议非常有效的让客户和服务器之间完成相互之间的身份认证，其主要过程如下：</p>
<p>1.客户端向服务器请求HTTPS连接:<br>客户端向服务器传送客户端 SSL 协议的版本号，加密算法的种类，<br>产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</p>
<p>2.服务器确认并返回证书。<br>服务器向客户端传送 SSL 协议的版本号，加密算法的种类，<br>随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</p>
<p>3.客户端验证服务器发来的证书。<br>客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：<br>证书是否过期，<br>发行服务器证书的 CA 是否可靠(CA 认证机构颁发证书)，<br>发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，<br>服务器证书上的域名是否和服务器的实际域名相匹配。<br>如果合法性验证没有通过，通讯将断开;<br>如果合法性验证通过，将继续进行第4步。<br>// 关于验证 CA 证书 及可能的中间人攻击:<br>[<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83NjU0MDgzMDUzN2Y=">https://www.jianshu.com/p/76540830537f<i class="fa fa-external-link-alt"></i></span><br>]</p>
<p>4.信息验证通过，客户端生成随机密钥A，用公钥加密后发给服务器。<br>从第3步验证过的证书里面可以拿到服务器的公钥，客户端生成的随机密钥就使用这个公钥来加密.<br>加密之后，只有拥有该服务器(持有私钥)才能解密出来，保证安全。</p>
<p>5.服务器用私钥解密出随机密钥A，以后通信就用这个随机密钥A来对通信进行加密。<br>至此, 客户端和服务端的握手完成, 即可以开始进行加密传输了。</p>
<p>#须知:<br>这个握手过程并没有将验证客户端身份的逻辑加进去。<br>因为在大多数的情况下，HTTPS只是验证服务器的身份而已。<br>如果要验证客户端的身份，需要客户端拥有证书，在握手时发送证书，而这个证书是需要成本的。</p>
]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配算法</title>
    <url>/computer/string.html</url>
    <content><![CDATA[<h2 id="基本分类："><a href="#基本分类：" class="headerlink" title="基本分类："></a>基本分类：</h2><ul>
<li><h4 id="1-朴素法：BF-Brute-Force"><a href="#1-朴素法：BF-Brute-Force" class="headerlink" title="1.朴素法：BF(Brute Force)"></a>1.朴素法：BF(Brute Force)</h4><p>  暴风(Brute Force)算法是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。    </p>
<ul>
<li><p><strong>思路</strong>  </p>
<p>  首先S[1]和T[1]比较，若相等，则再比较S[2]和T[2]，一直到T[M]为止；若S[1]和T[1]不等，则S向右移动一个字符的位置，再依次进行比较。如果存在k，1≤k≤N，且S[k+1…k+M]=T[1…M]，则匹配成功；否则失败。该算法最坏情况下要进行M*(N-M+1)次比较，时间复杂度为O(M*N)</p>
</li>
<li><p><strong>匹配过程</strong><br>  <img src="https://s.momocdn.com/w/u/others/2019/12/24/1577174693577-bf.png" alt="image">  </p>
</li>
<li><p><strong>代码</strong><br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577257833453-bf_code.png" alt="BF Code"></p>
</li>
</ul>
</li>
<li><h4 id="2-基于前后缀"><a href="#2-基于前后缀" class="headerlink" title="2.基于前后缀"></a>2.基于前后缀</h4><ul>
<li><p><strong>KMP</strong></p>
<ul>
<li><p><strong>思路</strong><br>  假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置。如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值），即移动的实际位数为：j - next[j]，且此值大于等于1。</p>
<p>  next 数组各值的含义：代表当前字符==之前：不包括自身==的字符串中，有多大长度的相同前缀后缀。例如如果next [j] =k，代表j之前的字符串中有最大长度为k的相同前缀后缀。此也意味着在某个字符失配时，该字符对应的next值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，==而不是跳到开头，且具体跳过了k 个字符，这就是KMP相对于BF的优化==。     </p>
</li>
<li><p><strong>最长前缀后缀表</strong><br>  对于P = p0 p1 …pj-1 pj，寻找模式串P中长度最大且相等的前缀和后缀。如果存在p0 p1 …pk-1 pk = pj- k pj-k+1…pj-1 pj，那么在包含pj的模式串中有最大长度为k+1的相同前缀后缀。比如求模式串“ABCDABD”的最长前缀后缀表过程：<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577260060952-kmp_longest_prefix" alt="kmp_longest_prefix_1">    </p>
<p>  所以最后求得的模式串“ABCDABD”的最长前缀后缀表为：<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577260060922-kmp_longest_prefix_1" alt="kmp_longest_prefix_2">      </p>
</li>
<li><p><strong>根据前缀后缀表推导next数组</strong><br>  next 数组考虑的是==除当前字符外==的最长相同前缀后缀，所以通过前面最长前缀后缀表求得各个前缀后缀的公共元素的最大长度后，只要稍作变形即可：将前面最长前缀后缀表中求得的值整体右移一位，然后初值赋为-1，如下表格所示：<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577260521069-kmp_longest_prefix_3" alt="kmp_longest_prefix_3">      </p>
</li>
<li><p><strong>如何求next数组</strong>        </p>
<ul>
<li>根据前面匹配的求后一个的next<br>  给定模式串ABCDABCE，且已知next [j] = k（相当于“p0 pk-1” = “pj-k pj-1” = AB，可以看出k为2），现要求next [j + 1]等于多少？因为pk = pj = C，所以next[j + 1] = next[j] + 1 = k + 1（可以看出next[j + 1] = 3）。代表字符E前的模式串中，有长度k+1 的相同前缀后缀。<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577274995335-next_2.png" alt="next_1">     但如果====pk== != pj== 呢？说明“p0 pk-1 pk”  ≠ “pj-k pj-1 pj”。换言之，当pk != pj后，字符E前有多大长度的相同前缀后缀呢？很明显，因为C不同于D，所以ABC 跟 ABD不相同，即字符E前的模式串没有长度为k+1的相同前缀后缀，也就不能再简单的令：next[j + 1] = next[j] + 1。所以，这个时候可以去找p[k]的前缀中有没有合适的前缀。见下图递归推导过程<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577275465434-next_3.png" alt="next_2">      </li>
<li>递归的推导过程<br>  k = next[k];<br>  待求的是p[j+1]，发现p[j] !=  p[k]，那就递归寻找p[next[k]]和p[j]是否一样，如果一样，那next[j+1] = next[next[k] + 1<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577275521268-kmp_next.png" alt="递归">      </li>
</ul>
</li>
<li><p><strong>求next数组代码</strong><br>  <a href="">见IDEA代码</a>      </p>
</li>
<li><p><strong>匹配过程</strong><br>  假设S=“ABCDAB ABCDABCDABDE”，P=“ABCDABD”    </p>
<ol>
<li>P[0]跟S[4]匹配成功，P[1]跟S[5]也匹配成功…，直到当匹配到P[6]处的字符D时失配（即S[10] != P[6]），由于P[6]处的D对应的next值为2，所以下一步用P[2]处的字符C继续跟S[10]匹配，相当于向右移动：j-next[j]=6-2=4位。<br><img src="https://s.momocdn.com/w/u/others/2019/12/25/1577259144804-kmp_1.png" alt="kmp_1"></li>
<li>向右移动4位后，P[2]处的C再次失配，由于C对应的next值为0，所以下一步用P[0]处的字符继续跟S[10]匹配，相当于向右移动：j - next[j] = 2 - 0 = 2 位。<br><img src="https://s.momocdn.com/w/u/others/2019/12/25/1577259144630-kmp_2.png" alt="kmp_2">   </li>
<li>移动两位之后，A 跟空格不匹配，模式串后移1 位。<br><img src="https://s.momocdn.com/w/u/others/2019/12/25/1577259144781-kmp_3.png" alt="kmp_3"></li>
<li>P[6]处的D再次失配，因为P[6]对应的next值为2，故下一步用P[2]继续跟文本串匹配，当于模式串向右移动 j - next[j] = 6 - 2 = 4 位。<br><img src="https://s.momocdn.com/w/u/others/2019/12/25/1577259144657-kmp_4.png" alt="kmp_4">   </li>
<li>匹配成功，过程结束。<br><img src="https://s.momocdn.com/w/u/others/2019/12/25/1577259144680-kmp_5.png" alt="kmp_5">   </li>
</ol>
</li>
<li><p><strong>kmp算法查找过程</strong><br>  <a href="">见IDEA代码</a></p>
</li>
<li><p><strong>next数组的优化</strong><br>  比如，求模式串“abab”的next 数组，可得其next 数组为-1 0 0 1，当它跟下图中的文本串去匹配的时候，发现b跟c失配，于是模式串右移j - next[j] = 3 - 1 =2位。<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577276557271-next_abab_1.jpg" alt="next_abab_1">    </p>
<p>  右移2位后，b又跟c失配。事实上，因为在上一步的匹配中，已经得知p[3] = b，与s[3] = c失配，而右移两位之后，让p[ next[3] ] = p[1] = b 再跟s[3]匹配时，必然失配。问题出在哪呢？<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/25/1577276557271-next_abab_2.jpg" alt="next_abab_2">        </p>
<p>  问题出在不该出现p[j] = p[ next[j] ]。为什么呢？理由是：当p[j] != s[i] 时，下次匹配必然是p[ next [j]] 跟s[i]匹配，如果p[j] = p[ next[j] ]，必然导致后一步匹配失败（因为p[j]已经跟s[i]失配，然后还用跟p[j]等同的值p[next[j]]去跟s[i]匹配，很显然，必然失配），所以不能允许p[j] = p[ next[j ]]。如果出现了p[j] = p[ next[j] ]咋办呢？如果出现了，则需要再次递归，即令next[j] = next[ next[j] ]<br>  <a href="">见IDEA代码</a></p>
</li>
<li><p><strong>时间复杂度</strong><br>  如果文本串的长度为n，模式串的长度为m，那么匹配过程的时间复杂度为O(n)，算上计算next的O(m)时间，KMP的整体时间复杂度为O(m + n)。    </p>
</li>
<li><p><strong>参考资料</strong>      </p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZfanVseV92L2FydGljbGUvZGV0YWlscy83MDQxODI3">July大神–从头到尾彻底理解KMP<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpJMk9UUXhNVE00T1E9PSZtaWQ9MjI0NzQ4OTg2MCZpZHg9MiZzbj01ZGI0MjdhMTM0YTQ3YmNhZWQ2MjIwNGVhMDE5M2UwNSZjaGtzbT1lYWUxZWMxNmRkOTY2NTAwODZiZjA4MGU0MjI2NDI0YWU2MTg1NjViZWYzYmIwNmZkZGVmNWZiZGJjNWUwM2UwNDNlZjdlYzM1ZGFkJm1wc2hhcmU9MSZzY2VuZT0yNCZzcmNpZD0mc2hhcmVyX3NoYXJldGltZT0xNTY2NTIzODU5NDE0JnNoYXJlcl9zaGFyZWlkPWM2NTJmM2ZlMzhhYjZhMjkyYjg0ZjQ4YmFiMTk4ZDI0I3Jk">7分钟动画理解KMP<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>BM(Boyer-Moore)</strong><br>  Boyer-Moore算法平均要比KMP快3-5倍，grep，window电脑的查找还有各种文本查找都用的BM算法。它和之前的BF和KMP匹配的过程不大一样，采用的是从后往前对比的过程。BM算法实际上包含两个并行的算法（也就是两个启发策略）：坏字符算法（bad-character shift）和好后缀算法（good-suffix shift）。这两种算法的目的就是让模式串每次向右移动尽可能大的距离     </p>
<ul>
<li><strong>思路</strong><br>  从后往前匹配。如果遇到不一致的字符，则这个字符就是==坏的字符==，所以坏字符是针对匹配串S的；匹配的路上相同的字符以及子集称为==好的后缀==，所以好的字符是针对模式串P的。每次失配时，都要根据这两个启发算法中找到能右移动的最大值。接下来详细讨论坏字符算法和好后缀算法这两个启发式。        </li>
<li><strong>启发式</strong>        <ul>
<li><strong>坏字符算法</strong><br>  当出现一个坏字符时,BM算法向右移动模式串,让模式串中==最靠右的对应字符==与坏字符相对,然后继续匹配。坏字符算法有两种情况。      <ul>
<li>case 1: 模式串中不存在坏字符。这种情况直接右移模式串P的长度       <pre><code>  ![bm_bad_1](https://s.momocdn.com/w/u/others/2019/12/26/1577347131411-bm_bad_1.png)     
</code></pre>
  比如底下的第一次匹配的字符‘d’，在模式串中不存在，直接右移模式串长度     <pre><code>  ![bm_bad_11](https://s.momocdn.com/w/u/others/2019/12/26/1577347131365-bm_bad_11.png)       
</code></pre>
</li>
<li>case 2:模式串中有对应的坏字符时，让模式串中最==靠右的对应字符==与坏字符相对<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577347131453-bm_bad_2.png" alt="bm_bad_2">       比如还是上图，在第一次右移模式串P的长度后，模式串末尾的c和主串末尾的b不匹配，说明‘b’是坏字符，但是它在模式串P中有两个出现的位置，如果用从末尾开始数的第二个‘b’会太激进，漏掉匹配；所以得用==最右边==的‘b’去匹配，这就是坏字符算法的第二种case。<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577347131365-bm_bad_11.png" alt="bm_bad_11"></li>
</ul>
</li>
<li><strong>好后缀算法</strong><br>  如果匹配了一个好后缀, 并且在模式中还有另外一个相同的完整后缀或后缀的部分, 那把下一个完整后缀或部分移动到当前后缀位置。假如说，P的后u个字符和S都已经匹配了，但是接下来的一个字符不匹配(坏字符)，我需要移动才能匹配。如果说后u个字符在P其他位置也出现过或部分出现，我们将P右移到前面的u个字符或部分和最后的u个字符或部分相同，如果说后u个字符在P其他位置完全没有出现，直接右移整个pattern。这样，好后缀算法有三种情况:     <ul>
<li>case 1:<br>  模式串中有子串和好后缀==完全匹配==，则将==失配位置前最靠右==的那个子串移动到好后缀的位置继续进行匹配<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577347131411-bm_good_1.png" alt="bm_good_1">         比如下面的例子，第一步在5的位置text的‘c’和pattern的‘b’失配了，说明‘c’是个坏字符，并且‘c’在pattern中有出现，那按照上面坏字符算法的case 2移动pattern最右边的‘c’与text失配的位置5中去继续匹配。接下来在位置7中，text的‘a’和pattern的‘b’失配了，如果坏字符的规则相当于走回头路了，所以保守一点移动一步，有没有更好的？可以看到按好字后缀的定义，8和9位置的‘ab’是好的后缀，并且它们在pattern模式串中有‘ab’和它完全匹配，那就是这种case，移动到完全匹配的位置，这样一次移动了两步，多走了一步，优秀了一点。<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577349874546-bm_good_11.png" alt="bm_good_11">     </li>
<li>case 2:<br>  模式串种字串和好后缀只能部分匹配，那就从模式串中找到具有如下特征的最长子串,使得P[m-s…m]=P[0…s]。就是从模式串P的第0个元素开始找，找能匹配最长的部分模式串(为啥从0开始而不是找最右边出现的？)<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577347131453-bm_good_2.png" alt="bm_good_2">         比如下面的例子，一利用花字符算法移动4位，然后在位置4处text的‘a’和pattern的‘b’失配了，如果按坏字符规则要走回头路，所以保守一点右移一步？看看完整的好的后缀为‘cbab’，显然pattern中没有完整能匹配这个完整的‘cbab’后缀的，那就按这种case，取最长的在pattern中出现的部分后缀‘ab’去对应，但是这里有个限制，就是如果是部分后缀匹配，那==只能从pattern的头开始==。想下为啥得这样？这样的话拿pattern的头部的‘ab’去匹配text的部分后缀‘ab’，一下就移动了4位，➡又优秀。</li>
<li>case 3:<br>  如果完全不存在和好后缀匹配的子串，则右移整个模式串，这种情况和坏字符在pattern中没有出现一样，因为怎么都不会匹配成功的                     </li>
</ul>
</li>
</ul>
</li>
<li><strong>案例分析</strong><br>  接下来拿Moore教授自己的<span class="exturl" data-url="aHR0cDovL3d3dy5jcy51dGV4YXMuZWR1L35tb29yZS9iZXN0LWlkZWFzL3N0cmluZy1zZWFyY2hpbmcvZnN0cnBvcy1leGFtcGxlLmh0bWw=">案例<i class="fa fa-external-link-alt"></i></span>来分析整个过程，模式串为EXAMPLE，主串为：HERE IS A SIMPLE EXAMPLE        <ul>
<li>上来text的‘S’和pattern的‘E’不匹配，所以‘S’是坏字符，并且‘S’在pattern中不存在，所以按照坏字符算法case 1，直接向右移动pattern的长度7位。<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354552013-bm_demo_1.png" alt="bm_demo_1">       </li>
<li>接下来text的‘P’和pattern的‘E’不匹配，所以‘P’也是坏字符，但是‘P’在pattern中存在，所以按照坏字符算法case 2，让pattern中最靠右的‘P’与之对齐，也就是向右移动2位<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354552008-bm_demo_2.png" alt="bm_demo_2">       </li>
<li>按上面移动后<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551978-bm_demo_3.png" alt="bm_demo_3">       </li>
<li>然后从末尾开始依次往前面匹配<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354552009-bm_demo_4.png" alt="bm_demo_4"><br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551882-bm_demo_5.png" alt="bm_demo_5"><br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551857-bm_demo_6.png" alt="bm_demo_6"><br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551825-bm_demo_7.png" alt="bm_demo_7"><br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551911-bm_demo_8.png" alt="bm_demo_8">   </li>
<li>注意上面的红框，在text的‘I’和pattern的‘A’失配的时候，‘I’是坏字符，而‘E’，‘LE’，‘PLE’，‘MPLE’都是好的后缀。如果按坏字符的话，因为‘I’在pattern中没有出现，那么需要整个都移动到‘I’的后面，也就是下面这样移动，只能移动==3==位：<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551756-bm_demo_9.png" alt="bm_demo_9"><br>  但是因为有这么多的好后缀（MPLE、PLE、LE、E），根据上面好后缀算法，因为MPLE在失配位置前没有完全匹配的，所以case1不满足；接下从（PLE、LE、E）这些匹配的部分后缀中找能在失配位置前==最长的==，并且从pattern的0号位置头部开始的，那只有‘E’满足，所以把pattern头部的‘E’移到和text的‘E’一样的位置重新开始匹配。这样一次就移动了==6==位！显然这样更优秀。<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551619-bm_demo_11.png" alt="bm_demo_11">     </li>
<li>接下来继续从尾到头开始匹配，上来就失配了，满足坏字符的case2，所以找到pattern的最靠右边的字符‘P’去匹配<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551619-bm_demo_13.png" alt="bm_demo_13">     </li>
<li>从尾到头去匹配，匹配成功<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577354551592-bm_demo_14.png" alt="bm_demo_14">     </li>
</ul>
</li>
<li><strong>参考资料</strong><br>  <span class="exturl" data-url="aHR0cDovL3d3dy5jcy51dGV4YXMuZWR1L35tb29yZS9iZXN0LWlkZWFzL3N0cmluZy1zZWFyY2hpbmcvZnN0cnBvcy1leGFtcGxlLmh0bWw=">Moore教授自己的案例demo<i class="fa fa-external-link-alt"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGFueHVlemFpcGlhby9wLzM0NTI1NzkuaHRtbA==">阿里小姐姐的分析过程<i class="fa fa-external-link-alt"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDEzLzA1L2JveWVyLW1vb3JlX3N0cmluZ19zZWFyY2hfYWxnb3JpdGhtLmh0bWw=">阮一峰的，得结合上面一起看<i class="fa fa-external-link-alt"></i></span>      </li>
</ul>
</li>
<li><p><strong>Sunday</strong>        </p>
<ul>
<li><strong>思路</strong><br>  Sunday算法最主要的特点是匹配失败的时候，关注的是主串中这一轮参与匹配的==最末位字符的下一位字符==，并且和BM不一样的是它是从前往后开始匹配。具体规则是：      <ul>
<li>如果该字符(主串失配位置的下一个字符)没有在模式串中出现则直接跳过它，即模式串右移位数 = 模式串长度 + 1。因为下一个不可能在模式串中存在，所以可以大胆的全部跳过它        </li>
<li>如果在模式串中存在，则模式串右移位数 = 模式串长度 - 该字符最右出现的位置(0开始算) = 模式串中该字符最右出现的位置到尾部的距离 + 1。和BM的坏字符的case 2类型，稳妥起见，拿最右边的相同的字符去对应匹配。     </li>
</ul>
</li>
<li><strong>案例分析</strong><br>  假设现在要在主串”substring searching”中查找模式串”search”。     <ul>
<li>刚开始时，把模式串和主串的左边对齐<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577362110097-sunday_1.png" alt="sunday_1">     </li>
<li>发现在第二个字符‘u’和‘e’的时候不匹配，根据规则，不匹配的时候关注主串这一轮参加匹配的的最末尾字符的下一个字符，即蓝色的‘i’，因为‘i’不在模式串中，所以向右移动位数 = 模式串长度 + 1 = 6 + 1 = 7，移动后如下图：<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577362109287-sunday_2.png" alt="sunday_2">     </li>
<li>继续匹配发现第一个字符就不匹配，按规则还是关注这一轮主串参加匹配的最末尾的字符的下一个字符，即蓝色的‘r’，发现它出现在模式串的倒数第3位，所以向右移动位数 = ‘r’到模式串末尾的距离 + 1 = 2 + 1 = 3，移动后如下图：<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577362109333-sunday_3.png" alt="sunday_3">     </li>
<li>匹配成功          </li>
</ul>
</li>
<li><strong>代码</strong><br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577364324709-sunday_code.png" alt="sunday_code">       </li>
<li><strong>缺点</strong><br>  Sunday算法的核心在向右移动位数move数组，这个依赖与模式串，所以有可能构造处很差的move数组(move数组的值都为1)，比如：<br>  主串：baaaabaaaabaaaabaaaa<br>  模式串：aaaaa<br>  这个模式串中，move[‘a’]的值都为1，因为最右边出现的‘a’就在末尾，所以每次失配时，只能让模式串移动1位，这就退化位BF的朴素算法了，时间复杂度也会飙升到o(m*n)，所以sunday不适合这种重复的模式串。      </li>
<li><strong>参考</strong><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8yZTZlYjczODZjZDM=">参考资料<i class="fa fa-external-link-alt"></i></span>      </li>
</ul>
</li>
</ul>
</li>
<li><h4 id="3-基于hash"><a href="#3-基于hash" class="headerlink" title="3.基于hash"></a>3.基于hash</h4><ul>
<li><strong>Rabin-Karp算法</strong>        <ul>
<li><strong>背景</strong><br>  BF这种朴素的字符串匹配算法慢主要有两点：1.每一轮的比较都是一个字符一个字符去比较；2.前一次匹配的信息对于下一次匹配完全用不上。<br>  所以Rabin-Karp算法对这两点进行了改进：一是每一轮的匹配不用一个个字符去比较，而是把模式串和这一轮匹配的主串用对应的hash数值去比较，所以一次就能匹配完；二是当失配时，把第一字符去掉，然后把下一个字符加进去，重新计算hash，但是这次计算hash可以根据上次的hash在常数时间内快速的算出来，这样上一次匹配的信息也能充分利用起来      </li>
<li><strong>思路</strong><br>  比如我们要在源串”9876543210520”中查找”520”，因为这些字符串中只有数字，所以我们  可以使用字符集{‘0’,’1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’}来表示字符串中的所有元   素，并且将各个字符映射到数字0～9，然后用M表示字符集中字符的总个数，这里是10，   那么我们就可以将搜索词 “987” 转化为下面的数值：<br>  (“9”的映射值 * M + “8”的映射值) * M + “7”的映射值 = (9 * 10 + 8) * 10 + 7 = 987   分析一下这个数值：987，它可以代表字符串 “987”，其中:<br>  代表字符 “9” 的部分是“ “9”的映射值 * (M 的 n - 1 次方) = 9 * (10 的 2 次方) = 900”<br>  代表字符 “8” 的部分是“ “8”的映射值 * (M 的 n - 2 次方) = 8 * (10 的 1 次方) = 80”<br>  代表字符 “7” 的部分是“ “7”的映射值 * (M 的 n - 3 次方) = 0 * (10 的 0 次方) = 7    其实这就是987按10进制的表达方式，同理可以去算模式串“520”的hash，显然这两个hash值不相等。接下来应该把‘9’去掉，把‘6’加进来。那如何利用前面‘987’计算的hash的信息呢？首先我们把 987 减去代表字符 “9” 的部分：987 - (“9”的映射值 * (M 的 n - 1 次方)) = 987 - (9 * (10 的 2 次方)) = 987 - 900 = 87，然后再乘以 M（这里是 10），再加上 “6” 的映射值，就成了‘876’ ：87 * M + “6”的映射值 = 87 * 10 + 6 = 876。然后根据这个规则继续匹配。当两个数值相等时，未必是真正的相等，我们需要进行一次细致的检查（再进行一次朴素的字符串比较）。若不匹配，则可以排除掉，防止hash碰撞的情况。        这里我们列举的是10进制的情况，如果是ASCII 字符集的话M可以取值128；这个M值尽量取较大的素数，这样使得更多的位参与运算减少hash碰撞。如果我们要在 Unicode 字符集范围内查找“搜索词”，由于 Unicode 字符集中有 1114112 个字符，那么 M 就等于 1114112，而 Go 语言中使用 ==16777619== <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9ibG9iL21hc3Rlci9zcmMvc3RyaW5ncy9zdHJpbmdzLmdv">Go的strings源码<i class="fa fa-external-link-alt"></i></span>作为 M 的值，16777619 比 1114112 大（更大的 M 值可以容纳更多的字符，这是可以的），而且 16777619 是一个素数。这样就可以使用上面的方法计算 Unicode 字符串的数值了。进而可以对 Unicode 字符串进行比较了。      </li>
<li><strong>代码</strong><br>  计算待匹配模式串sep的hash和最高位权重的值pow<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/26/1577367195724-rabin_karp_code.png" alt="rabin_karp_code">      匹配算法<br>  <img src="https://s.momocdn.com/w/u/others/2019/12/27/1577420152336-rabin_karp_code_2.png" alt="rabin_karp_code_2">       </li>
<li><strong>案例</strong><br>  比如在ABCDE里去匹配BCD，我们用q表示常数primeRK<br>  BCD的hash计算出来应该是B q^2 + C q + D<br>  ABC的hash应该是        A q^2 + B q + C<br>  当D来的时候如何操作的呢？根据之前的规则：<br>  [A q^2 + B q + C] q + D - A pow = A q^3 - A pow + B q^2 + C q + D<br>  而这个pow是可以和go源码里一样提前算出来的，所以在失陪时计算下一个hash能在常数时间快速得到，而两个hash值只是数值对比，一样快的飞起。</li>
<li><strong>参考</strong><br>  <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9ibG9iL21hc3Rlci9zcmMvc3RyaW5ncy9zdHJpbmdzLmdv">Go的strings源码<i class="fa fa-external-link-alt"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ29sb3ZlL3AvMzIzNDY3My5odG1s">参考资料1<i class="fa fa-external-link-alt"></i></span><br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cubGlua2luc3Rhci53aWtpLzIwMTkvMDYvMjAvZ29sYW5nL3NvdXJjZS1jb2RlL3N0cmluZ3MtZ28tc291cmNlLWNvZGUv">参考资料2<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
</li>
<li><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><strong>AC算法</strong><br>  基于前缀的AC算法，构造goto表<br>  <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hseHhjYy9hcnRpY2xlL2RldGFpbHMvNjQxMzI0MDk=">参考资料<i class="fa fa-external-link-alt"></i></span>       </li>
<li><strong>Bitmap算法</strong><br>  用一个 bit 位来标记某个元素节省存储空间<br>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2hhbnNodXlpL3AvNTI4NzgyNS5odG1s">参考资料<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter</title>
    <url>/flutter/index.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Flutter已经面世这么长时间了，不抽空学习一下，实在是对不起自己。也是由于前天面试被问到Flutter的一些东西，一脸懵逼，真不是一个合格的iOS开发猿！！！</p>
<p>分享一下学习经验和心得，纪录一下学习过程的疑问。</p>
<p>官网学习，手敲练习<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phY2stVmluZy9mbHV0dGVyLXN0dWR5">demo源码<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="学习之前我有几个问题问自己"><a href="#学习之前我有几个问题问自己" class="headerlink" title="学习之前我有几个问题问自己"></a>学习之前我有几个问题问自己</h2><ul>
<li>为什么大家都说Flutter比RN和Weex流畅？ </li>
<li>和RN、Weex实现原理对比, Flutter的实现原理是什么？</li>
<li>怎么和Native通讯？</li>
</ul>
<span id="more"></span>
<h1 id="初见"><a href="#初见" class="headerlink" title="初见"></a>初见</h1><p>clone flutter到本地，配置环境变量，略…</p>
<p>入口函数 lib/main.dart. 中 void main(), 启动一个app，就是 runApp(<Widget>);</p>
<p>对于Flutter来说，万物皆<Widget>, 主App窗口也是一个Widget。</p>
<p>然后就是Widget内部再嵌套子视图Widget，一个套一个，我们可以称之为树节点</p>
<h2 id="有状态和无状态的Widget"><a href="#有状态和无状态的Widget" class="headerlink" title="有状态和无状态的Widget"></a>有状态和无状态的Widget</h2><p>有状态的StatefulWidget,就是在setState()的时候，会重新绘制 Widget树，从而达到了更新状态的目的。 并且 State和Widget是分离的，也就保证了Widget树(界面)重新绘制的时候，数据不会丢失。</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><ul>
<li>竖向排列，也就是Column</li>
<li>横向排列，也就是Row</li>
</ul>
<p>好好运用 <code>Expanded</code>,<code>Container</code>等, </p>
<blockquote>
<p>注意：如果要添加<code>填充</code>，<code>边距</code>，<code>边框</code>或<code>背景色</code>，请使用<code>Container</code>来设置<code>!!!</code></p>
</blockquote>
<p>暂停。。。有些事情耽搁，后续继续写<br><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNWFmYTk3Njk1MTg4MjU0Mjg2MzBhNjFj">看完删除<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/future/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Autoreleasepool</title>
    <url>/iOS/Autoreleasepool.html</url>
    <content><![CDATA[<h1 id="Autoreleasepool"><a href="#Autoreleasepool" class="headerlink" title="Autoreleasepool"></a>Autoreleasepool</h1><ul>
<li>孙源大神的博客  <span class="exturl" data-url="aHR0cDovL2Jsb2cuc3Vubnl4eC5jb20vMjAxNC8xMC8xNS9iZWhpbmQtYXV0b3JlbGVhc2Uv">Autoreleasepool<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdWhvdS5naXRodWIuaW8vMjAxOC8wMS8yMS8lRTUlQjglQTYlRTclOUQlODAlRTklOTclQUUlRTklQTIlOTglRTclOUMlOEIlRTYlQkElOTAlRTclQTAlODEtLS0tJUU1JUFEJTkwJUU3JUJBJUJGJUU3JUE4JThCQXV0b1JlbGVhc2UlRTUlQUYlQjklRTglQjElQTElRTQlQkQlOTUlRTYlOTclQjYlRTklODclOEElRTYlOTQlQkUv">网上搜的<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h1 id="与runloop的关系"><a href="#与runloop的关系" class="headerlink" title="与runloop的关系"></a>与runloop的关系</h1><p>第一个 Observer ：<br>监视的事件是 Entry (即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。</p>
<p>第二个 Observer ：<br>监视了两个事件：BeforeWaiting(准备进入休眠)<br>会调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；</p>
<p>Exit(即将退出Loop)<br>会调用 _objc_autoreleasePoolPop( ) 来释放自动释放池。</p>
<ol>
<li>子线程在使用autorelease对象时，如果没有autoreleasepool会在autoreleaseNoPage中懒加载一个出来。</li>
<li>在runloop的run:beforeDate，以及一些source的callback中，有autoreleasepool的push和pop操作，总结就是系统在很多地方都差不多autorelease的管理操作。</li>
<li>就算插入没有pop也没关系，在线程exit的时候会释放资源，执行AutoreleasePoolPage::tls_dealloc，在这里面会清空autoreleasepool。</li>
</ol>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><ul>
<li>当产生了autorelease对象时，此对象又特别大， 例如图片、大字符串、大数据等等时，此时加上 autoreleasepool ，会更好，避免oom产生</li>
<li>特别是在循环任务中执行代码，优先使用系统迭代器方法，因为系统迭代器帮我们写好了autoreleasepool</li>
</ul>
]]></content>
      <categories>
        <category>Autoreleasepool</category>
      </categories>
      <tags>
        <tag>Autoreleasepool</tag>
      </tags>
  </entry>
  <entry>
    <title>fishhook</title>
    <url>/iOS/fishhook.html</url>
    <content><![CDATA[<h1 id="iOS-14-5-下-fishhook-会-crash"><a href="#iOS-14-5-下-fishhook-会-crash" class="headerlink" title="iOS 14.5 下 fishhook 会 crash"></a>iOS 14.5 下 fishhook 会 crash</h1><p>github相关信息<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zpc2hob29rL2lzc3Vlcy84Mg==">github issue<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zpc2hob29rL3B1bGwvODQ=">resolve<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zpc2hob29rL3B1bGwvNjYvZmlsZXM=">protections ios13<i class="fa fa-external-link-alt"></i></span></p>
<p>Fishhook 考虑到过内存访问权限的问题，在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zpc2hob29rL3B1bGwvNjUvZmlsZXM=">If hooking in __DATA_CONST, make writable before trying to write<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zpc2hob29rL3B1bGwvNjYvZmlsZXM=">Properly restore protections for iOS 13<i class="fa fa-external-link-alt"></i></span> 这两个 PR 中，对于 __DATA_CONST 段中的数据，作者在</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">indirect_symbol_bindings[i] <span class="operator">=</span> cur-&gt;rebindings[j].replacement<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>这一行赋值操作之前，使用了 <code>mprotect</code> 将所属内存区域的访问权限改成了“读写”，在这一行赋值操作以后，再次使用 <code>mprotect</code> 将所属内存区域的访问权限改回了原始值。</p>
<p>然而这两个 PR 其实是有问题的：<br>1、mprotect 修改内存区域的访问权限时，传入的内存地址是需要按页对齐的，所以开源版本的 fishhook 在旧版 iOS 系统上，mprotect 都有很大概率不成功（返回 -1），<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL1N5c3RlbS9Db25jZXB0dWFsL01hblBhZ2VzX2lQaG9uZU9TL21hbjIvbXByb3RlY3QuMi5odG1s">官方文档<i class="fa fa-external-link-alt"></i></span>也印证了这点。</p>
<p>2、oldProtection = get_protection(rebindings); 这一行的目的是保存原先的访问权限，但是传入的参数是错误的，这会导致“在这一行赋值操作以后，再次使用 mprotect 将所属内存区域的访问权限改回了原始值”在实际执行中，“改回了原始值”实际是“改成可读写”（当然由于 mprotect 页对齐的问题很大概率修改不成功），因为 rebindings 是 malloc 出来的。</p>
<p>所以，一直以来，这两个 PR 大概率没有发挥预期的作用， indirect_symbol_bindings[i] 所在的内存区域，如果在程序启动后是只读的，那么 fishhook 的过程中，它也是只读的。只要赋值，就会触发 crash。</p>
<h1 id="查看小技巧"><a href="#查看小技巧" class="headerlink" title="查看小技巧"></a>查看小技巧</h1><p>1、无论是 iOS 14.4 还是 iOS 14.5，mprotect 修改内存区域为读写时，都失败了（返回 -1）。<br>2、但是在 mprotect 修改前，iOS 14.4 上 indirect_symbol_bindings[i] 所在的内存区域是读写的，而 iOS 14.5 上变成了只读。<br>为了便于理解，我们可以在程序启动后、fishhook 开始前，通过 memory graph 来观察各个内存区域的访问权限：</p>
<blockquote>
<p>抓取 memory graph 后，在 Xcode 中选择 File -&gt; Export Memory Graph，导出 memory graph 后使用 vmmap 命令得到各个内存区域的快照</p>
</blockquote>
<p>观察 libxpc.dylib 的 __DATA_CONST 段映射在内存中的访问权限：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iOS 14.5 </span></span><br><span class="line">__DATA_CONST                <span class="number">1</span>edadef10-<span class="number">1</span>edae35c0    [   <span class="number">18</span>K    <span class="number">18</span>K     <span class="number">4</span>K     <span class="number">0</span>K] r--<span class="regexp">/rw- SM=COW          /u</span>sr<span class="regexp">/lib/</span>system/libxpc.dylib</span><br><span class="line"><span class="comment"># iOS 14.4</span></span><br><span class="line">__DATA_CONST                <span class="number">1</span>f30167b0-<span class="number">1</span>f301ae70    [   <span class="number">18</span>K    <span class="number">18</span>K     <span class="number">6</span>K     <span class="number">0</span>K] rw-<span class="regexp">/rw- SM=COW          /u</span>sr<span class="regexp">/lib/</span>system/libxpc.dylib</span><br></pre></td></tr></table></figure>

<p>可以发现，iOS 14.5 中，libxpc.dylib 的 __DATA_CONST 段是只读的，而 iOS 14.4 中是读写的。<br>同时观察其他系统库，能发现 iOS 14.5 中，不少系统库的 __DATA_CONST 段都从 iOS 14.4 的读写变成了只读，同时撞上了一直以来都有的 mprotect 失效的问题，所以产生了 crash。</p>
<p>解决参考上面issue, 核心代码如下</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">mprotect</span><span class="params">((void *)</span><span class="title">trunc_address</span>, <span class="title">section</span>-&gt;</span>size+trunc_size, PROT_READ | PROT_WRITE);</span><br></pre></td></tr></table></figure>

<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">trunc_address = trunc_page((<span class="name">vm_size_t</span>)indirect_symbol_bindings)<span class="comment">;</span></span><br><span class="line">trunc_size =(<span class="name">vm_size_t</span>)indirect_symbol_bindings -trunc_address<span class="comment">;</span></span><br><span class="line">pthread_mutex_lock(<span class="name">&amp;mutex</span>)<span class="comment">;</span></span><br><span class="line">oldProtection = get_protection((<span class="name">void</span> *)trunc_address);</span><br><span class="line">mprotect((void *)trunc_address, section-&gt;size+trunc_size, PROT_READ | PROT_WRITE)<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>fishhook</tag>
        <tag>hook</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS技术收集</title>
    <url>/iOS/index.html</url>
    <content><![CDATA[<h2 id="这个是iOS技术汇总"><a href="#这个是iOS技术汇总" class="headerlink" title="这个是iOS技术汇总"></a>这个是iOS技术汇总</h2><ul>
<li><a href="./iOS/RunTime">RunTime</a></li>
<li><a href="./iOS/RunLoop">RunLoop</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>iOS的基础梳理</title>
    <url>/iOS/study.html</url>
    <content><![CDATA[<blockquote>
<p>iOS的一些基础梳理，方便求职者能有一些参考。 还是那句话，书山有路勤为径，学海无涯苦作舟！</p>
</blockquote>
<h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><ul>
<li>解决研发过程中的<code>关键问题</code>和<code>技术难题</code></li>
<li><code>调优</code>设备流量、性能、电量</li>
<li><code>较强</code>的软件设计能力</li>
<li>对iOS内部原理有<code>深刻理解</code></li>
</ul>
<h1 id="资深"><a href="#资深" class="headerlink" title="资深"></a>资深</h1><ul>
<li><code>精通</code>高性能编程以及性能调优</li>
<li><code>灵活运用</code>数据结构、算法解决<code>复杂程序设计</code>问题</li>
<li>提供性能优化、日志搜索、统计分析等<code>方案</code></li>
<li>架构、模块<code>设计</code></li>
</ul>
<h1 id="专家"><a href="#专家" class="headerlink" title="专家"></a>专家</h1><ul>
<li>你还来看我这干啥，不要检查我的作业~</li>
</ul>
<h1 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h1><ul>
<li>排版清晰</li>
<li>重要和突出的表达</li>
<li>线上bug数变化、量化指标 质量上的指标</li>
<li>开发成本节约了多少 量化指标</li>
<li>基本信息、工作经历、项目经验、擅长技能</li>
<li>项目经验(主导、参与)，背景、方案、效果</li>
</ul>
<span id="more"></span>

<h1 id="UI视图"><a href="#UI视图" class="headerlink" title="UI视图"></a>UI视图</h1><ul>
<li>UITableView</li>
<li>事件传递&amp;视图响应</li>
<li>图像显示原理</li>
<li>卡顿&amp;掉帧</li>
<li>绘制原理&amp;异步绘制</li>
<li>离屏渲染</li>
</ul>
<h1 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h1><ul>
<li>重用机制</li>
<li>数据源同步<ul>
<li>并发方案数据copy 串行方案</li>
</ul>
</li>
<li>UI事件传递&amp;响应<ul>
<li>UIView提供内容，事件响应，响应链</li>
<li>CALayar的contents负责绘制</li>
<li>单一指责原则</li>
</ul>
</li>
</ul>
<h1 id="视图显示原理"><a href="#视图显示原理" class="headerlink" title="视图显示原理"></a>视图显示原理</h1><h2 id="卡顿、掉帧的原因"><a href="#卡顿、掉帧的原因" class="headerlink" title="卡顿、掉帧的原因"></a>卡顿、掉帧的原因</h2><ul>
<li>CPU<ul>
<li>对象创建、调整、销毁</li>
<li>预排版（布局计算、文本计算）</li>
<li>预渲染（文本等异步绘制，图片解码等）</li>
</ul>
</li>
<li>GPU<ul>
<li>纹理渲染</li>
<li>视图混合</li>
</ul>
</li>
</ul>
<h2 id="UIView的绘制原理"><a href="#UIView的绘制原理" class="headerlink" title="UIView的绘制原理"></a>UIView的绘制原理</h2><ul>
<li><p>[UIView setNeedsDisplay] -&gt; [view.layer setNeedsDisplay] -&gt; [CALayer display]</p>
</li>
<li><p>[CALayer display]是否响应 [layer.delegate displayLayer]方法</p>
</li>
<li><p>是，进入异步绘制。否，进入系统绘制流程</p>
<ul>
<li>CALayer creats backing store(CGContextRef)</li>
<li>是否有layer has a delegate</li>
<li>是，[layer.delegate drawLayer:inContext:]</li>
<li>否，[CALayer drawInContext:]</li>
<li>最后 CALayer uploads backing store to GPU</li>
</ul>
</li>
</ul>
<h2 id="异步绘制-layer-delegate-displayLayer"><a href="#异步绘制-layer-delegate-displayLayer" class="headerlink" title="异步绘制 [layer.delegate displayLayer]"></a>异步绘制 [layer.delegate displayLayer]</h2><pre><code>- 代理负责生成对应的bitmap
- 设置该bitmap作为layer.contents属性的值

- 流程如下
</code></pre>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- <span class="selector-attr">[AsyncDrawingView setNeedsDisplay]</span></span><br><span class="line">- <span class="selector-attr">[CALayer display]</span></span><br><span class="line">- <span class="selector-attr">[AsyncDrawingView displayLayer:]</span></span><br><span class="line">    - <span class="built_in">CGBitmapContextCreat</span>()</span><br><span class="line">    - CoreGraphic API</span><br><span class="line">    - <span class="built_in">CGBitmapContextCreatImage</span>()</span><br><span class="line">- <span class="selector-attr">[CALayer setContents]</span></span><br></pre></td></tr></table></figure>

<h2 id="离屏渲染-OFF-SCREEN-RENDERING"><a href="#离屏渲染-OFF-SCREEN-RENDERING" class="headerlink" title="离屏渲染(OFF-SCREEN RENDERING)"></a>离屏渲染(OFF-SCREEN RENDERING)</h2><pre><code>在当前缓冲区创建新的缓冲区渲染
缓冲区渲染，圆角(和maskToBounds一起使用)，孟层遮罩，阴影，光栅化
</code></pre>
<ul>
<li>为何要避免离屏渲染?</li>
</ul>
<ul>
<li>离屏渲染会增加GPU的工作量, CPU+GPU提交一帧的时间超过了16.7ms，造成了不满60帧的卡顿</li>
<li>创建新的渲染缓冲区</li>
<li>上下文切换</li>
</ul>
<h1 id="OC语言面试问题"><a href="#OC语言面试问题" class="headerlink" title="OC语言面试问题"></a>OC语言面试问题</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="分类都做了什么事情？"><a href="#分类都做了什么事情？" class="headerlink" title="分类都做了什么事情？"></a>分类都做了什么事情？</h3><ul>
<li>声明私有方法</li>
<li>分解体积庞大的类文件</li>
<li>framework的私有方法公开</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>运行时决议（runtime时添加）    - 可以为系统类添加分类</li>
</ul>
<h3 id="分类中可以添加哪些内容"><a href="#分类中可以添加哪些内容" class="headerlink" title="分类中可以添加哪些内容"></a>分类中可以添加哪些内容</h3><ul>
<li>实例方法    - 类方法    - 协议    - 属性（只是声明了set和get方法，而不是私有属性）</li>
</ul>
<h3 id="结构体-objc-runtime-680版本源代码"><a href="#结构体-objc-runtime-680版本源代码" class="headerlink" title="结构体(objc-runtime-680版本源代码)"></a>结构体(objc-runtime-680版本源代码)</h3><ul>
<li>const char * name    - cls    - instanceMethods    - classMethods    - protocols    - instanceProperties</li>
</ul>
<h3 id="加载调用栈"><a href="#加载调用栈" class="headerlink" title="加载调用栈"></a>加载调用栈</h3><ul>
<li>_objc_init -&gt; map_2_imags -&gt; map_images_nolock -&gt; _read_images -&gt; remethodizeClass</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ul>
<li>效果上，分类添加的方法可以「覆盖」原类方法</li>
<li>同名分类方法谁能生效取决于编译顺序</li>
<li>名字相同的分类会引起编译报错</li>
</ul>
<h2 id="4-5-扩展相关面试问题"><a href="#4-5-扩展相关面试问题" class="headerlink" title="4-5 扩展相关面试问题"></a>4-5 扩展相关面试问题</h2><ul>
<li>声明私有属性</li>
<li>声明私有方法</li>
<li>声明私有成员变量<h3 id="扩展特性"><a href="#扩展特性" class="headerlink" title="扩展特性"></a>扩展特性</h3></li>
<li>编译时决议</li>
<li>不能为系统类添加扩展</li>
<li>只有声明</li>
</ul>
<h2 id="代理相关"><a href="#代理相关" class="headerlink" title="代理相关"></a>代理相关</h2><ul>
<li>软件设计模式</li>
<li>@protocol形式提现</li>
<li>代理传递<code>一对一</code></li>
<li>weak规避循环引用</li>
</ul>
<h2 id="通知相关-NSNotification"><a href="#通知相关-NSNotification" class="headerlink" title="通知相关(NSNotification)"></a>通知相关(NSNotification)</h2><ul>
<li>是使用<code>观察者模式</code>来实现的用于跨层传递消息的机制（网络层，ui层传递等等）</li>
<li>一对多</li>
</ul>
<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><ul>
<li>KVO是Objective-C对<code>观察者设计模式</code>的有一种实现</li>
<li>Apple使用了isa混写（isa-swizzling）来实现kvo</li>
<li>NSKVONotifying_A （子类）重写setter方法<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)setValue:(id)obj &#123;</span><br><span class="line">    <span class="selector-attr">[self willChangeValueForKey:@<span class="string">&quot;keyPath&quot;</span>]</span>;</span><br><span class="line">    <span class="comment">//调用父类实现，也即原类的实现</span></span><br><span class="line">    <span class="selector-attr">[supe setValue:obj]</span>;</span><br><span class="line">    <span class="selector-attr">[self didChangeValueForKey:@<span class="string">&quot;keyPath&quot;</span>]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>1、通过kvc设置value能否生效？</li>
<li>2、通过成员变量直接赋值value能否生效？</li>
</ul>
<h2 id="KVC-Key-value-coding-键值编码"><a href="#KVC-Key-value-coding-键值编码" class="headerlink" title="KVC (Key-value coding)键值编码"></a>KVC (Key-value coding)键值编码</h2><ul>
<li>valueForKey流程图</li>
</ul>
<img src="/images/iOS/KVC.png" class="" title="KVC流程图">

<ul>
<li><p>Accessor Method</p>
<ul>
<li><code>&lt;getKey&gt;</code></li>
<li><code>&lt;Key&gt;</code></li>
<li><code>&lt;isKey&gt;</code></li>
</ul>
</li>
<li><p>setValueForKey流程图</p>
<img src="/images/iOS/kvc-set.png" class="" title="KVC-set流程图"></li>
</ul>
<h1 id="RunTime"><a href="#RunTime" class="headerlink" title="RunTime"></a>RunTime</h1><ul>
<li>数据结构</li>
<li>类对象与元类对象</li>
<li>消息传递</li>
<li>方法缓存</li>
<li>消息转发</li>
<li>Methond-Swizzling</li>
<li>动态添加方法</li>
<li>动态方法解析</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>objc_object</p>
<ul>
<li>isa_t </li>
<li>关于isa操作相关</li>
<li>弱引用相关</li>
<li>关联对象相关</li>
<li>内存管理<br>objc_class</li>
<li>Class = objc_class继承自objc_object<ul>
<li>Class puserClass</li>
<li>cache_t cache</li>
<li>class_data_bits_t bits;<br>isa指针</li>
</ul>
</li>
<li>指针型isa，的内存地址代表Class的地址</li>
<li>非指针型的呢值，代表Class的地址<br>isa指向</li>
<li>关于对象，指向类对象，-class</li>
<li>类对象，元类对象， Class——isa-MetaClass<br>cache_t</li>
<li>用于<code>快速</code>查找方法执行函数,消息传递的速度</li>
<li>是<code>可增量扩展</code>的<code>哈希表</code>结构</li>
<li>是<code>局部性原理</code>的最佳应用(调用频率越高，越容易命中)</li>
<li>数据结构<ul>
<li>bucket_t 这样的数组<ul>
<li>key   </li>
<li>IMP<br>class_data_bits_t</li>
</ul>
</li>
</ul>
</li>
<li>主要是对class_rw_t的封装<ul>
<li>class_ro_t</li>
<li>protocols(二维数组)</li>
<li>properties(二维数组)</li>
<li>methods(二维数组)</li>
</ul>
</li>
<li>clcass_rw_t 代表了类相关的读写信息、对class_ro_t的封装</li>
<li>class_ro_t<ul>
<li>name(类名等…)</li>
<li>ivars(二维数组)</li>
<li>properties(二维数组)</li>
<li>protocols(二维数组)</li>
<li>methodlist(二维数组)</li>
</ul>
</li>
<li>method_t<ul>
<li>struct method_t<br>= name。。。SEL name; 名称</li>
<li>chonst char* types; 函数体<ul>
<li><ul>
<li>返回值 参数1.。。参数n</li>
</ul>
</li>
<li>v@: void， id  SEL</li>
</ul>
</li>
<li>IMP imp;  实现</li>
</ul>
</li>
</ul>
<img src="/images/iOS/runtime-data-structure.png" class="" title="runtime结构体">

<h1 id="类对象，对象-实例，isa指向类对象-，"><a href="#类对象，对象-实例，isa指向类对象-，" class="headerlink" title="类对象，对象(实例，isa指向类对象)，"></a>类对象，对象(实例，isa指向类对象)，</h1><p>实例对象可以通过isa指针找到类对象，类对象的isa指针可以找到元类对象,元类对象isa指向根原类对象，根元类对象isa指向根类对象</p>
<h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><ul>
<li>void objc_mesSend(void /* id self, SEL op, …*/)</li>
<li>void objc_mesSendSuper(void /* struct objc_super * super, SEL op, …*/)</li>
</ul>
<h3 id="缓存查找-哈希查找"><a href="#缓存查找-哈希查找" class="headerlink" title="缓存查找 哈希查找"></a>缓存查找 哈希查找</h3><p>通过SEL-&gt;hash-&gt;key找多对应的bucket_t的IMP</p>
<ul>
<li>对于<code>已排序好</code>的列表,采用<code>二分法</code>查找对应执行函数</li>
<li>对于没有<code>排序好</code>的列表，采用<code>一般遍历</code></li>
<li>缓存查找是否命中，  方法列表是否命中， 逐级父类方法是否命中, 消息转发</li>
</ul>
<h3 id="x消息转发"><a href="#x消息转发" class="headerlink" title="x消息转发"></a>x消息转发</h3><h4 id="实例方法的转发"><a href="#实例方法的转发" class="headerlink" title="实例方法的转发"></a>实例方法的转发</h4><ul>
<li>类方法 resolveInstanceMethode: 返回值bool。yes已处理，消息转发结束</li>
<li>forwarding TargetForSelector:  返回值是id，因该有那个对象来处理，返回nil进入第三次转发</li>
<li>methodSignatureForSelector: 返回方法签名,返回nil，消息无法处理</li>
<li>forwardInvocation：</li>
</ul>
<h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method-Swizzling"></a>Method-Swizzling</h3><h3 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h3><ul>
<li>通过消息转发机制,动态添加方法。在resolveInstanceMethod</li>
</ul>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><ul>
<li>@dynamic  动态运行时语言将函数决议推迟到运行时</li>
<li>编译时语言在编译器进行函数决议</li>
</ul>
<h3 id="obj-foo-和objc-msgSend-函数有什么关系？"><a href="#obj-foo-和objc-msgSend-函数有什么关系？" class="headerlink" title="[obj foo]和objc_msgSend()函数有什么关系？"></a>[obj foo]和objc_msgSend()函数有什么关系？</h3><ul>
<li>[obj foo]在编译之后，就变成了和objc_msgSend()</li>
</ul>
<h3 id="runtime如何通过Selector找到对应的IMP地址？"><a href="#runtime如何通过Selector找到对应的IMP地址？" class="headerlink" title="runtime如何通过Selector找到对应的IMP地址？"></a>runtime如何通过Selector找到对应的IMP地址？</h3><ul>
<li>先从缓存方法列表—-待补充</li>
</ul>
<h3 id="能否向编译后的类中增加实例变量？"><a href="#能否向编译后的类中增加实例变量？" class="headerlink" title="能否向编译后的类中增加实例变量？"></a>能否向编译后的类中增加实例变量？</h3><ul>
<li>不能！编译后结构体class_ro_t是只读属性</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ul>
<li>TaggedPointer</li>
<li>NONPOINTER_ISA</li>
<li>散列表(引用技术表和弱引用表)</li>
</ul>
<h2 id="NONPOINTER-ISA"><a href="#NONPOINTER-ISA" class="headerlink" title="NONPOINTER_ISA"></a>NONPOINTER_ISA</h2><h2 id="散列表-Side-Tables-结构"><a href="#散列表-Side-Tables-结构" class="headerlink" title="散列表 Side Tables()结构"></a>散列表 Side Tables()结构</h2><ul>
<li>自旋锁</li>
<li>引用计数表</li>
<li>弱引用表<blockquote>
<p>分离锁，提升并发问题</p>
</blockquote>
</li>
<li>Spinlock_t 自旋锁<ul>
<li>Spinlock_t是『忙等』的锁</li>
<li>轻量访问</li>
</ul>
</li>
<li>RefcountMap Hash表</li>
<li>weak_table_t 弱引用表 Hash表</li>
</ul>
<h2 id="MRC-amp-ARC"><a href="#MRC-amp-ARC" class="headerlink" title="MRC &amp; ARC"></a>MRC &amp; ARC</h2><ul>
<li>ARC是LLVM和Runtime协作的结果</li>
<li>ARC禁止调用 retain/等</li>
<li>ARC中新增weak，strong等属性关键字</li>
</ul>
<h2 id="引用计数管理"><a href="#引用计数管理" class="headerlink" title="引用计数管理"></a>引用计数管理</h2><h3 id="retain实现"><a href="#retain实现" class="headerlink" title="retain实现"></a>retain实现</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">SideTable&amp; table = SideTables()[This];（哈西查找）</span><br><span class="line">size_t&amp; <span class="built_in">ref</span>cntStorage = table.<span class="built_in">ref</span>cnts[This];   size_t就是无符号long型</span><br><span class="line"><span class="built_in">ref</span>cnStorage += SIDE_TABLE_RC_ONE;</span><br></pre></td></tr></table></figure>

<h3 id="dealloc实现"><a href="#dealloc实现" class="headerlink" title="dealloc实现"></a>dealloc实现</h3><ol>
<li>_objc_rootDeallco()</li>
<li>rootDealloc()</li>
<li>是否可以释放<ul>
<li>nonpointer_isa</li>
<li>weakly_referenced</li>
<li>has_assoc</li>
<li>has_cxx_dtor</li>
<li>has_sidetable_rc</li>
</ul>
</li>
<li>3全部为no，调用object_dospose().否则可直接c函数free()释放</li>
</ol>
<h3 id="弱引用管理"><a href="#弱引用管理" class="headerlink" title="弱引用管理"></a>弱引用管理</h3><h2 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h2><ul>
<li>是以<code>栈</code>为节点通过<code>双向链表</code>的形式结合而成</li>
<li>是和<code>线程</code>一一对应的</li>
</ul>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>{<br>    id * next;<br>    AutoReleasePoolPage * const parent;<br>    AutoReleasePoolPage * child;<br>    pthread_t const thread<br>}<br>多层嵌套就是多次插入哨兵对象</p>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><ul>
<li>自循环引用</li>
<li>相互循环引用</li>
<li>多循环引用</li>
</ul>
<h3 id="如何破除循环引用"><a href="#如何破除循环引用" class="headerlink" title="如何破除循环引用"></a>如何破除循环引用</h3><ul>
<li>避免产生循环引用</li>
<li>在合适的时机手动断环</li>
</ul>
<ul>
<li>__block<ul>
<li>MRC下，__block修饰不会增加引用计数，避免了循环引用</li>
<li>ARC下，__block修饰会被强引用，无法避免循环引用，需手动解环</li>
</ul>
</li>
</ul>
<ul>
<li>NSTimer的循环引用问题<ul>
<li>nstimer 会对target强引用，Runloop会强制引用NSTimer；</li>
<li>添加中间对象，NSTimer和对象之间</li>
<li>invalidInvocation</li>
</ul>
</li>
</ul>
<h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><blockquote>
<p>Block是将<code>函数</code>以及<code>执行上下文</code>封装起来的<code>对象</code>.<br>使用【clang -rewite-objc file.m】查看编译之后的文件内容</p>
</blockquote>
<h2 id="截获变量"><a href="#截获变量" class="headerlink" title="截获变量"></a>截获变量</h2><ul>
<li>对于<code>基本数据</code>类型的<code>局部变量</code>截获其值</li>
<li>对于<code>对象</code>类型的局部变量<code>连同所有权修饰符</code>一起截获</li>
<li>以<code>指针形式</code>截获局部静态变量</li>
<li>不截获全局变量、静态全局变量<br>使用【clang -rewite-objc -fobjc-arc file.m】查看编译之后的文件内容</li>
</ul>
<h2 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h2><ul>
<li><code>一般情况下</code>，对被截获的变量进行<code>赋值</code>操纵时，需要添加<code>__block修饰符</code></li>
</ul>
<h2 id="Block的内存管理"><a href="#Block的内存管理" class="headerlink" title="Block的内存管理"></a>Block的内存管理</h2><p>无论任何位置，都可以顺利的用__block修饰变量访问到</p>
<h2 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h2><ul>
<li>__block在MRC下不会引用计数+1，在arc下会引用计数+1</li>
</ul>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><ul>
<li>GCD</li>
<li>NSOperation</li>
<li>NSTread （常驻线程）</li>
<li>多线程与锁</li>
</ul>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><ul>
<li>同步、异步和串行/并发</li>
<li>dispath_barrier_async 针对多读单写问题,栅栏函数</li>
<li>dispath_group</li>
</ul>
<h3 id="同步串行"><a href="#同步串行" class="headerlink" title="同步串行"></a>同步串行</h3><ul>
<li>死锁原因，是队列引起的 循环等待</li>
</ul>
<h3 id="同步并发"><a href="#同步并发" class="headerlink" title="同步并发"></a>同步并发</h3><h3 id="异步串行"><a href="#异步串行" class="headerlink" title="异步串行"></a>异步串行</h3><h3 id="异步并发-performSelector-delay"><a href="#异步并发-performSelector-delay" class="headerlink" title="异步并发 performSelector: delay"></a>异步并发 performSelector: delay</h3><h2 id="dispath-barrier-async"><a href="#dispath-barrier-async" class="headerlink" title="dispath_barrier_async()"></a>dispath_barrier_async()</h2><h2 id="dispath-group-async"><a href="#dispath-group-async" class="headerlink" title="dispath_group_async()"></a>dispath_group_async()</h2><p>使用GCD实现：ABC执行完，再执行D</p>
<blockquote>
<p>dispatch_group_notify(group,….){}</p>
</blockquote>
<h2 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h2><ul>
<li>需要和NSOperationQueue</li>
</ul>
<ul>
<li>添加任务依赖</li>
<li>任务执行状态控制</li>
<li>最大并发量</li>
</ul>
<h3 id="任务执行状态控制"><a href="#任务执行状态控制" class="headerlink" title="任务执行状态控制"></a>任务执行状态控制</h3><ul>
<li>isReady</li>
<li>isExecuting</li>
<li>isFinished</li>
<li>isCancelled<br>只重写了<code>main</code>方法，底层控制变更任务执行完成状态，以及任务退出<br>如果重写了<code>star</code>方法，自行控制任务状态</li>
</ul>
<ul>
<li>gnustep=base-1.24.9<blockquote>
<p>系统通过KVO的形势移出一个isFinished为YES的NSOperation</p>
</blockquote>
</li>
</ul>
<h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><p>启动流程 star() -&gt; 创建pthread -&gt; main() -&gt; [target performSelector:SEL] -&gt; exit()</p>
<h2 id="多线程和锁"><a href="#多线程和锁" class="headerlink" title="多线程和锁"></a>多线程和锁</h2><ul>
<li>@synchronized<ul>
<li>创建单利对象的使用</li>
</ul>
</li>
<li>atomic<ul>
<li>属性关键字，赋值操作线程安全，其它不安全</li>
</ul>
</li>
<li>OSSpinLock<ul>
<li>自旋锁，<code>循环等待</code>询问，不释放当前资源</li>
<li>轻量级的数据访问，简单的+1、-1</li>
</ul>
</li>
<li>NSRecursivelock 递归锁<ul>
<li>可以重录</li>
</ul>
</li>
<li>NSLock<ul>
<li>互斥</li>
<li>A方法中[lock lock],再次调用[lock lock]会造成死锁，使用NSRecursivelock</li>
</ul>
</li>
<li><h2 id="dispath-semaphore-t"><a href="#dispath-semaphore-t" class="headerlink" title="dispath_semaphore_t"></a>dispath_semaphore_t</h2></li>
</ul>
<h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><blockquote>
<p>RunLoop是通过内部维护的<code>事件循环</code>来对<code>事件/消息进行管理</code>的一个对象</p>
</blockquote>
<ul>
<li>没有消息需要处理时，休眠以避免资源占用<ul>
<li>用户态 -&gt; 内核态</li>
</ul>
</li>
<li>有消息需要处理时，立刻被唤醒<ul>
<li>内核态 -&gt; 用户态</li>
</ul>
</li>
</ul>
<h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p>NSRunLoop 是CFRunLoop的封装，提供了面向对象的API, <span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscy9DRi9DRi04NTUuMTcudGFyLmd6">开源地址<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>CFRunLoop</li>
<li>CFRunLoopMode</li>
<li>Source/Timer/Observer</li>
</ul>
<h3 id="CFRunLoop-数据结构"><a href="#CFRunLoop-数据结构" class="headerlink" title="CFRunLoop 数据结构"></a>CFRunLoop 数据结构</h3><ol>
<li>pthread          一一对应 （Runloop和线程的关系）</li>
<li>currentMode      CFRunLoopMode</li>
<li>modes            NSMutableSet&lt;CFRunLoopMode*&gt;</li>
<li>commonModes      NSMutableSet&lt;NSString*&gt;<ul>
<li><code>不是一种实际存在</code>的Mode，</li>
<li>同步 Source/Timer/Observer 到多个Mode中的<code>一种技术方案</code></li>
</ul>
</li>
<li>commonModeItems  observer Timer source,</li>
</ol>
<h3 id="CFRunLoopMode"><a href="#CFRunLoopMode" class="headerlink" title="CFRunLoopMode"></a>CFRunLoopMode</h3><ol>
<li>name                 NSDefaultRunloopMode</li>
<li>source0              </li>
<li>source1</li>
<li>observers</li>
<li>timers</li>
</ol>
<h3 id="CFRunLoopSource"><a href="#CFRunLoopSource" class="headerlink" title="CFRunLoopSource"></a>CFRunLoopSource</h3><ul>
<li>source0 需要手动唤醒线程</li>
<li>source1 具备唤醒线程的能力</li>
</ul>
<h3 id="CFRunLoopObserver"><a href="#CFRunLoopObserver" class="headerlink" title="CFRunLoopObserver"></a>CFRunLoopObserver</h3><ul>
<li>kCFRunLoopEntry</li>
<li>kCFRunloopBeforeTimers</li>
<li>kCFRunLoopBeforeSources</li>
<li>kCFRunLoopBeforeWaiting</li>
<li>…</li>
</ul>
<blockquote>
<p>1个RunLoop有多个Model，一个model有多个 source、Timer、Observer</p>
</blockquote>
<h2 id="RunLoop的Mode"><a href="#RunLoop的Mode" class="headerlink" title="RunLoop的Mode"></a>RunLoop的Mode</h2><h2 id="事件循环的实现机制"><a href="#事件循环的实现机制" class="headerlink" title="事件循环的实现机制"></a>事件循环的实现机制</h2><p>void CFRunLoopRun(),用户态到核心态相互切换</p>
<img src="/images/iOS/RunLoop-machining.png" class="" title="RunLoop循环机制">

<h2 id="常驻线程"><a href="#常驻线程" class="headerlink" title="常驻线程"></a>常驻线程</h2><p>由于自己创建的线程并没有开启runloop(一一对应关系)，需要创建并开启一个Runloop</p>
<ol>
<li>为当前线程开启一个RunLoop. </li>
<li>向该RunLoop中添加一个Port/Source等维持RunLoop的事件循环. 没有就会退出</li>
<li>启动该RunLoop</li>
</ol>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul>
<li>责任链</li>
<li>桥接</li>
<li>适配器</li>
<li>单例</li>
<li>命令</li>
</ul>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ul>
<li>单一指责原则<ul>
<li>一个类负责一件事儿，CALayer和UIView</li>
</ul>
</li>
<li>依赖倒置原则<ul>
<li>抽象不应该依赖于具体实现，具体实现可以依赖于抽象. 声明的接口等</li>
</ul>
</li>
<li>开闭原则<ul>
<li>对修改关闭、对扩展开放</li>
</ul>
</li>
<li>里氏替换原则<ul>
<li>KVO,使用紫雷无缝替换，且原功能不受任何影响</li>
</ul>
</li>
<li>接口隔离原则<ul>
<li>使用多个专门的协议、delegate，datasouce</li>
</ul>
</li>
<li>迪米特法则<ul>
<li>一个对象应当对其他对象有尽可能少的了解</li>
<li>高内聚，低耦合</li>
</ul>
</li>
</ul>
<h2 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h2><ul>
<li>某一对象的成员变量也是该类类型</li>
</ul>
<h2 id="桥接"><a href="#桥接" class="headerlink" title="桥接"></a>桥接</h2><ul>
<li>一个类拥有一个抽象类，抽象类有多种实现</li>
</ul>
<h2 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h2><ul>
<li>一个现有类需要适应变化的问题<ul>
<li>对象适配器</li>
<li>类适配器</li>
</ul>
</li>
</ul>
<h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>成员变量的方式持有原类</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">void</span>)request &#123;</span><br><span class="line">    <span class="comment">//额外处理</span></span><br><span class="line"><span class="string">    [self.target operation]</span>;</span><br><span class="line">    <span class="comment">//额外处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><blockquote>
<p>instance = [[super allocWithZone:NULL] init];避免循环调用</p>
</blockquote>
<ul>
<li>重写 <figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">+ (id)<span class="symbol">allocWithZone:</span>(<span class="class"><span class="keyword">struct</span> <span class="title">_NSZone</span> *)<span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> shareInstance];</span><br><span class="line">&#125;</span><br><span class="line">- (id)<span class="symbol">copyWithZone:</span>(<span class="class"><span class="keyword">struct</span> <span class="title">_NSZone</span> *)<span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2></li>
</ul>
<ul>
<li>行为参数化</li>
<li>降低代码重合度</li>
</ul>
<h1 id="架构-amp-框架"><a href="#架构-amp-框架" class="headerlink" title="架构&amp;框架"></a>架构&amp;框架</h1><ul>
<li>图片缓存</li>
<li>阅读时长统计</li>
<li>复杂页面架构</li>
<li>客户端整体架构</li>
</ul>
<h2 id="图片缓存框架"><a href="#图片缓存框架" class="headerlink" title="图片缓存框架"></a>图片缓存框架</h2><ol>
<li>内存的设计上需要考虑哪些问题？<ul>
<li>储存的Size</li>
<li>淘汰策略</li>
</ul>
</li>
</ol>
<h3 id="存储的Size"><a href="#存储的Size" class="headerlink" title="存储的Size"></a>存储的Size</h3><ul>
<li>10k以下的图片</li>
<li>100k以下20张图片</li>
<li>100k以上5张左右</li>
</ul>
<h4 id="淘汰策略（内存）"><a href="#淘汰策略（内存）" class="headerlink" title="淘汰策略（内存）"></a>淘汰策略（内存）</h4><ul>
<li>队列先进先出的方式淘汰</li>
<li>模拟LRU算法 （最近最久，如30分钟之内是否使用过）<ul>
<li>定时检查</li>
<li>提高检查出发的频率<ul>
<li>每次进行读写时</li>
<li>前后台切换时</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="磁盘设计"><a href="#磁盘设计" class="headerlink" title="磁盘设计"></a>磁盘设计</h4><ul>
<li>存储方式</li>
<li>大小限制（如100M）</li>
<li>淘汰策略(如某一图片储存时间超过7天)</li>
</ul>
<h4 id="网络请求图片设计"><a href="#网络请求图片设计" class="headerlink" title="网络请求图片设计"></a>网络请求图片设计</h4><ul>
<li>图片请求最大量</li>
<li>请求超时策略</li>
<li>请求优先级</li>
</ul>
<h4 id="图片解码"><a href="#图片解码" class="headerlink" title="图片解码"></a>图片解码</h4><ul>
<li>对于不同格式的图片，用什么方式？</li>
</ul>
<ul>
<li>应用策略模式对不同图片进行解码</li>
</ul>
<ul>
<li>在哪个阶段图片解码处理</li>
</ul>
<ul>
<li>磁盘读取后</li>
<li>网络请求返回后</li>
</ul>
<h4 id="线程处理"><a href="#线程处理" class="headerlink" title="线程处理"></a>线程处理</h4><h2 id="阅读时长统计"><a href="#阅读时长统计" class="headerlink" title="阅读时长统计"></a>阅读时长统计</h2><ul>
<li>记录器<ul>
<li>页面记录</li>
<li>流式</li>
<li>自定义</li>
</ul>
</li>
<li>记录管理者<ul>
<li>记录缓存</li>
<li>磁盘储存</li>
<li>上传器（延时上传）<ul>
<li>前后台切换</li>
<li>从无网到有网的变化</li>
</ul>
</li>
</ul>
</li>
<li>处理数据丢失<ul>
<li>定时储存</li>
<li>100条储存</li>
</ul>
</li>
</ul>
<h2 id="负责页面架构"><a href="#负责页面架构" class="headerlink" title="负责页面架构"></a>负责页面架构</h2><ul>
<li>整体框架</li>
<li>数据流</li>
<li>反向更新</li>
</ul>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><ul>
<li>view（ViewController）</li>
<li>ViewModel</li>
<li>Model(Engeer)</li>
</ul>
<h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><ul>
<li>独立于App的通用层</li>
<li>通用业务层</li>
<li>中间层</li>
<li>业务ABCD</li>
</ul>
<h3 id="业务解耦"><a href="#业务解耦" class="headerlink" title="业务解耦"></a>业务解耦</h3><ul>
<li>OpenUrl</li>
<li>依赖注入（中间层）</li>
</ul>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul>
<li>字符串反转 ；<ul>
<li>俩头交换</li>
</ul>
</li>
<li>链表反转<ul>
<li>插入头部</li>
</ul>
</li>
<li>有序数组合并<ul>
<li>比较大小，添加到新的数组</li>
</ul>
</li>
<li>Hash算法<ul>
<li>字符对应的aciic码表</li>
</ul>
</li>
<li>查找两个子视图的共同父视图<ul>
<li>所有父视图 倒序比较</li>
</ul>
</li>
<li>求无序数组当中的中位数</li>
</ul>
<h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><h2 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h2><p>架构图</p>
<img src="/images/iOS/AFNetworking-draft.png" class="" title="AFNetworking框架">
<ul>
<li>AFURLSessionManager 核心类<ul>
<li>NSUrLSession</li>
<li>AFSecurityPolicy</li>
<li>AFNetworkReachablilityManager</li>
<li>创建和管理NSUrLSession、NSURLSessionTask</li>
<li>实现NSURLSessionDelegate等协议的代理方法</li>
<li>引入AFSecurityPolicy保证请求安全</li>
<li>引入AFNetworkReachablilityManager监控网络状态</li>
</ul>
</li>
<li>AFHTTPSessionManeger<ul>
<li>AFURLRequestSerialzation</li>
<li>AFURLResponseSerial</li>
</ul>
</li>
</ul>
<h2 id="SDWebImage"><a href="#SDWebImage" class="headerlink" title="SDWebImage"></a>SDWebImage</h2><p>架构图</p>
<img src="/images/iOS/SDWebImage.png" class="" title="SDWebImage框架">

<h2 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h2><p>函数响应式编程框架，<code>信号</code>，<code>订阅</code>信号<br>ReactiveCocoa中核心类RACSignal -&gt; RACStream</p>
<ul>
<li>RACDynamicSignal</li>
<li>RACReturnSignal</li>
<li>RACEmptySignal</li>
<li>RACErrorSignal</li>
</ul>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>代表一连串的状态</p>
<ul>
<li>empty，return，bind，concat，zipWith</li>
</ul>
<h3 id="订阅-RACSubscriber"><a href="#订阅-RACSubscriber" class="headerlink" title="订阅 RACSubscriber"></a>订阅 RACSubscriber</h3><p>start -&gt; RACSignal -&gt; -subscribeNext: -&gt; RACSubscriber -&gt; -sendNext: -&gt; -sendCompleted</p>
<h2 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h2><p>更多请看<a href="./iOS/thirdpart/asdk.html">AsyncDisplayKit</a><br>提升iOS界面渲染性能的一个框架<br>主要处理问题</p>
<ul>
<li>Layout 文本宽高计算、视图布局计算</li>
<li>Rendering  文本渲染、图片解码、图形绘制</li>
<li>UIKit Objects 对象创建、对象调整、对象销毁</li>
</ul>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul>
<li>ASNode === UIView === CALayer</li>
<li>针对ASNode的修改和提交，会对其进行封装提交到一个全局容器当中</li>
<li>ASDK也在RunLoop中注册了一个Observer</li>
<li>当RunLoop进入休眠前，ASDK执行该Loop内提交的所有任务</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Finished! 此时需要一个，互动，评论的功能！开搞。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/linux/home.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Linux内核官网<a href="www.kernel.org">www.kernel.org</a></p>
<ul>
<li>内核版本2.6.18  3.16等等</li>
<li>发行版本 redhat==conterOS ubuntu debian等等</li>
</ul>
<ul>
<li>使用的自由<ul>
<li>绝大多数开源软件免费</li>
</ul>
</li>
<li>研究的自由<ul>
<li>可以获得软件源代码</li>
</ul>
</li>
<li>散步及改良的自由<ul>
<li>可以自由传播、改良甚至销售</li>
</ul>
</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>基于Linux服务器</li>
<li>嵌入式应用 手机，接顶盒等等</li>
</ul>
<h2 id="Linux和Windows的不同"><a href="#Linux和Windows的不同" class="headerlink" title="Linux和Windows的不同"></a>Linux和Windows的不同</h2><ul>
<li>Linux严格区分大小写</li>
<li>Linux中所有内容以文件形式保存，包括硬件</li>
<li>以前内容皆文件</li>
<li>Linux不靠扩展名区分文件类型  (-&gt;权限)<ul>
<li>压缩包 .gz .bz2 .tar.bz2  .tgz登</li>
<li>二进制软件包：.rpm</li>
<li>网页文件： *.html  .php</li>
<li>脚本文件： *.sh</li>
<li>配置文件： *.conf</li>
</ul>
</li>
</ul>
<h2 id="字符界面"><a href="#字符界面" class="headerlink" title="字符界面"></a>字符界面</h2><ul>
<li>占用系统资源更少</li>
<li>减少出错、被攻击的可能性越少</li>
</ul>
<h2 id="挂载-给每个分区分配挂载点"><a href="#挂载-给每个分区分配挂载点" class="headerlink" title="挂载 给每个分区分配挂载点"></a>挂载 给每个分区分配挂载点</h2><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li>服务器最小化安装</li>
</ul>
<h2 id="安装日志"><a href="#安装日志" class="headerlink" title="安装日志"></a>安装日志</h2><ul>
<li>/root/install.log: 储存了安装在系统中的软件包及其版本信息</li>
<li>/root/install.log.syslog: 储存了安装过程中留下的事件记录</li>
<li>/root/anaconda-ks.cfg: 以Kickstart配置文件的格式记录安装过程中设置的选项信息</li>
</ul>
<h1 id="常用的目录的作用"><a href="#常用的目录的作用" class="headerlink" title="常用的目录的作用"></a>常用的目录的作用</h1><ul>
<li>/根目录</li>
<li>/bin 命令保存目录（普通用户就可以读取的命令）</li>
<li>/sbin 超级权限才能读取的命令</li>
<li>/boot 启动目录，启动相关文件</li>
<li>/dev 设备文件保存目录</li>
<li>/etc 配置文件</li>
<li>/home 普通用户家目录</li>
<li>/lib 系统库保存目录</li>
<li>/mnt 系统挂载目录</li>
<li>/media 挂载目录</li>
<li>/proc和/sys 目录不能直接操作，保存的是内存的过载点</li>
<li>/usr 系统软件资源目录<ul>
<li>/usr/bin/ 系统命令（普通用户）</li>
<li>/usr/sbin/ 系统命令（超级用户）</li>
</ul>
</li>
<li>/var 系统相关文档内容</li>
</ul>
<h1 id="常用命令-文件处理命令"><a href="#常用命令-文件处理命令" class="headerlink" title="常用命令(文件处理命令)"></a>常用命令(文件处理命令)</h1><h2 id="命令的基本格式"><a href="#命令的基本格式" class="headerlink" title="命令的基本格式"></a>命令的基本格式</h2><ul>
<li>~代表当前所在位置 家目录,初始目录</li>
<li>#代表超级用户</li>
<li>$代表普通用户</li>
</ul>
<ul>
<li><code>命令 [选项] [参数]</code>  -a  -all简化</li>
</ul>
<h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><ul>
<li>rw- r– r– 分为三组，三组的权限</li>
<li>-文件类型(- 文件， d 目录， | 软连接文件)</li>
<li>rw-   r–   r–</li>
<li>所有者 g所属着 o其他人</li>
<li>r读 w写 x执行</li>
<li>.文件为隐藏文件</li>
</ul>
<h2 id="pwd-显示当前所在路径-print-working-dictionary"><a href="#pwd-显示当前所在路径-print-working-dictionary" class="headerlink" title="pwd 显示当前所在路径 print working dictionary"></a>pwd 显示当前所在路径 print working dictionary</h2><h2 id="mkdir-p-目录名"><a href="#mkdir-p-目录名" class="headerlink" title="mkdir -p [目录名]"></a>mkdir -p [目录名]</h2><ul>
<li>-p 递归创建  /s/p 这样的</li>
</ul>
<h2 id="cd-进入目录"><a href="#cd-进入目录" class="headerlink" title="cd 进入目录"></a>cd 进入目录</h2><ul>
<li>~进入当前用户目录，家目录</li>
<li>..上一级目录</li>
<li>.当前目录</li>
</ul>
<h2 id="rmdir-目录-remove-empty-dir"><a href="#rmdir-目录-remove-empty-dir" class="headerlink" title="rmdir [目录] remove empty dir"></a>rmdir [目录] remove empty dir</h2><ul>
<li>只能删除空白目录</li>
</ul>
<h2 id="rm-rf-不询问是否删除"><a href="#rm-rf-不询问是否删除" class="headerlink" title="rm -rf 不询问是否删除"></a>rm -rf 不询问是否删除</h2><ul>
<li>-r 删除目录</li>
<li>-f 强制</li>
</ul>
<h2 id="cp-选项-源文件-目标目录"><a href="#cp-选项-源文件-目标目录" class="headerlink" title="cp [选项] [源文件] [目标目录]"></a>cp [选项] [源文件] [目标目录]</h2><ul>
<li>-r 复制目录</li>
<li>-p 连带文件属性复制</li>
<li>-d 若源文件是链接文件，则复制链接属性</li>
<li>-a 相当于 -pdr</li>
</ul>
<h2 id="mv-剪切或者改名命令"><a href="#mv-剪切或者改名命令" class="headerlink" title="mv 剪切或者改名命令"></a>mv 剪切或者改名命令</h2><ul>
<li>源文件或者目录和目标文件目录  在一起，就是改名</li>
</ul>
<h2 id="链接命令"><a href="#链接命令" class="headerlink" title="链接命令"></a>链接命令</h2><ul>
<li>ln -s [源文件] [目标文件]</li>
<li>命令英文愿意： link</li>
<li>功能描述：生成链接文件<ul>
<li>选项： -s 创建软链接</li>
</ul>
</li>
</ul>
<ul>
<li>硬链接特征 (i 文件索引点)<ol>
<li>拥有相同的i节点和储存block块，可以看作是同一个文件</li>
<li>可通过i节点识别</li>
<li>不能跨分区</li>
<li>不能准对目录使用</li>
<li>引用计数加1，同一个文件</li>
</ol>
</li>
<li>软链接特征<ul>
<li>类似于windows快捷方式</li>
<li>拥有自己的i节点和block块，但是数据块中只保存源文件的文件名和i节点号，并没有实际的文件数据</li>
<li>Irwxrwxrwx I 软连接<ul>
<li>软连接文件的权限都为rwxrwxrwx</li>
</ul>
</li>
<li>修改任意文件，另一个都改变</li>
<li>删除源文件，软连接不能使用</li>
</ul>
</li>
</ul>
<h1 id="文件搜索命令"><a href="#文件搜索命令" class="headerlink" title="文件搜索命令"></a>文件搜索命令</h1><ul>
<li>文件搜索命令locate</li>
<li>命令搜索命令whereis与which</li>
<li>文件搜索命令find</li>
<li>字符串搜索命令grep</li>
<li>find命令与grep命令的区别</li>
</ul>
<h2 id="locate-速度相对较快"><a href="#locate-速度相对较快" class="headerlink" title="locate (速度相对较快)"></a>locate (速度相对较快)</h2><ul>
<li>locate 文件名。 在后台数据库中按照文件名搜索，搜索速度更快</li>
<li>/var/lib/mlocate  #locate命令所搜索的后台数据库</li>
<li>updatedb 更新数据库, 可能是一天更新一次,开机更新一次</li>
</ul>
<h2 id="whereis与which-搜索命令的命令"><a href="#whereis与which-搜索命令的命令" class="headerlink" title="whereis与which 搜索命令的命令"></a>whereis与which 搜索命令的命令</h2><ul>
<li>where 只能搜索<code>系统的命令</code><ul>
<li>-b 只查看命令所在位置</li>
<li>-m 只差看帮助文档</li>
</ul>
</li>
<li>which 只能搜索<code>系统的命令</code><ul>
<li>看命令所在位置,还能查到看别名</li>
</ul>
</li>
</ul>
<h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><ul>
<li><p>find [搜索范围] [搜索条件]</p>
</li>
<li><p>find / -name install.log</p>
<ul>
<li>避免大范围搜索，会非常耗费系统资源</li>
<li>find是在系统当中搜索符合条件的文件名。如果需要匹配，通常使用通配符匹配，<code>通配符</code>是完全匹配</li>
</ul>
</li>
<li><p><code>*</code> 匹配任意字符</p>
</li>
<li><p><code>?</code> 匹配任意一个字符</p>
</li>
<li><p><code>[]</code> 匹配任意一个中括号内的字符 find -name ab[cd]</p>
</li>
<li><p>find /root -inname install.log  就不区分大小写了</p>
</li>
<li><p>find /root -user root 按照所有者搜索</p>
</li>
<li><p>find /root -nouser 查找没有所有者的文件</p>
</li>
<li><p>find /var/log/ -mtime +10 <code>查找10天前修改的文件</code></p>
<ul>
<li>-10 10天内修改的文件</li>
<li>10 10天当天修改的文件</li>
<li>+10 10天前修改的文件</li>
<li>atime 文件访问时间</li>
<li>ctime 改变文件属性</li>
<li>mtime 修改文件内容</li>
</ul>
</li>
<li><p>find . -size 25k <code>查找文件大小是25k的文件</code></p>
<ul>
<li>-25k 小于25KB的文件  注意是小写的<code>k</code>，兆字节用大写的<code>M</code></li>
<li>25k 等于25KB的文件</li>
<li>+25k 大于25KB的文件 </li>
<li>find . -size 25 不加单位就是扇区搜索</li>
</ul>
</li>
<li><p>find /root -inum 262422 <code>查找i节点是262422</code>的文件</p>
</li>
<li><p>find /etc -size +20k -a -size -50k</p>
<ul>
<li><code>查找/etc/目录下，大于20kb小于50kb的文件</code></li>
<li>-a and 逻辑与，两个条件都满足</li>
<li>-0 or  逻辑或，两个条件满足一个即可</li>
</ul>
</li>
<li><p>find /etc -size +20k -a -size -50k -exec ls -lh {} ;</p>
<ul>
<li><code>查找/etc/目录下，大于20KB并且小于50KB的文件，并显示详细信息</code></li>
<li><code>-exec/-ok 命令&#123;&#125; \; 对搜索结果执行操作,&quot;&#123;&#125; \;&quot;为标准格式，只要有-exec就要写它</code></li>
</ul>
</li>
</ul>
<h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><ul>
<li>grep [选项] 字符串 文件名<ul>
<li>在文件档中匹配符合条件的字符串</li>
<li>-i 忽略大小写</li>
<li>-v 排除指定字符串</li>
</ul>
</li>
</ul>
<h2 id="find-与-grep区别"><a href="#find-与-grep区别" class="headerlink" title="find 与 grep区别"></a>find 与 grep区别</h2><ul>
<li>find命令，在当前系统中搜索符合条件的文件名，如果需要匹配。使用通配符匹配，通配符是完全匹配</li>
<li>grep命令：在文件当中搜索符合条件的字符串，如果需要匹配，使用正则表达式进行匹配，正则表达式是包含匹配</li>
</ul>
<h1 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h1><ul>
<li><p>man帮助等级</p>
<ol>
<li>查看命令的帮助</li>
<li>查看可被内核调用的函数的帮助</li>
<li>查看函数和函数库的帮助</li>
<li>查看特殊文件的帮助（主要是/dev目录下的文件）</li>
<li>查看配置文件的帮助</li>
<li>查看游戏的帮助</li>
<li>查看其他杂项的帮助</li>
<li>查看系统管理员可用命令的帮助</li>
<li>查看和内核相关文件的帮助</li>
</ol>
</li>
<li><p>man 命令 -&gt; 获取指定命令的帮助  man ls</p>
</li>
<li><p>man -f 相当于 whatis 命令</p>
</li>
<li><p>man -k 相当于 apropos命令 eg: apropos passwd</p>
</li>
<li><p>shell内部命令帮助</p>
<ul>
<li>help 只能获取shell内部命令的帮助 eg： whereis cd. help cd</li>
<li>是安装的软件，就有路径，比如 /bin/ls ,如果 没有比如cd 就是shell内部命令。『whereis cd』</li>
</ul>
</li>
<li><p>info 命令</p>
<ul>
<li>回车  进入子帮助页面 (带有*号标记)</li>
<li>u 上层</li>
<li>n 下一帮助小节</li>
<li>p 上一帮助小节</li>
<li>q 退出</li>
</ul>
</li>
</ul>
<h1 id="压缩与解压缩命令"><a href="#压缩与解压缩命令" class="headerlink" title="压缩与解压缩命令"></a>压缩与解压缩命令</h1><blockquote>
<p><code>.zip</code> .7z .rar <code>.gz</code> <code>.bz2</code> .tar.gz .tar.bz2等等</p>
</blockquote>
<h2 id="zip格式"><a href="#zip格式" class="headerlink" title=".zip格式"></a>.zip格式</h2><ul>
<li>zip 压缩文件名  源文件名  eg: <code>zip xxx.zip xxx</code></li>
<li>zip -r 压缩目录 源文件</li>
<li>unzip 解压缩文件</li>
</ul>
<h2 id="gz格式"><a href="#gz格式" class="headerlink" title=".gz格式"></a>.gz格式</h2><ul>
<li>gzip 源文件 <code>压缩为.gz格式的压缩文件，源文件会消失</code></li>
<li>gzip -c 源文件 &gt; 压缩文件  <ul>
<li>压缩为.gz 格式，源文件保留</li>
<li>eg： gzip -c cangls &gt; cangls.gz</li>
</ul>
</li>
<li>gzip -r 目录<ul>
<li><code>压缩目录下所有的子文件，但是不能压缩目录</code></li>
</ul>
</li>
<li>gzip -d 解压缩</li>
<li>gunzip 解压缩</li>
</ul>
<h2 id="bz2格式"><a href="#bz2格式" class="headerlink" title=".bz2格式"></a>.bz2格式</h2><ul>
<li>bzip2 源文件 不保留源文件</li>
<li>bzip2 -k 源文件<ul>
<li>压缩之后保留源文件<blockquote>
<p><code>注意：bzip2命令不能压缩目录</code></p>
</blockquote>
</li>
</ul>
</li>
<li>bzip2 -d 解压缩  <code>-k保留源文件</code></li>
<li>bunzip2  <code>-k保留源文件</code></li>
</ul>
<h2 id="tar-gz-tar-bz2"><a href="#tar-gz-tar-bz2" class="headerlink" title=".tar.gz  .tar.bz2"></a>.tar.gz  .tar.bz2</h2><p>先压缩成.tar 再压缩成.gz / .bz2</p>
<h3 id="tar-cvf-打包文件名-源文件"><a href="#tar-cvf-打包文件名-源文件" class="headerlink" title="tar -cvf 打包文件名 源文件"></a>tar -cvf 打包文件名 源文件</h3><ul>
<li><p>-c 打包</p>
</li>
<li><p>-v 显示过程</p>
</li>
<li><p>-f 指定打包后的文件名</p>
</li>
<li><p>-x 解压缩 eg -xvf</p>
</li>
<li><p>-t 只查看</p>
</li>
<li><p>.tar.gz （z)</p>
<ul>
<li><code>-z 压缩为.tar.gz格式</code>  tar -zcvf xx.tar.gz 源文件</li>
<li><code>-x 解压缩为.tar.gz格式</code> tar -zxvf xx.tar.gz </li>
</ul>
</li>
<li><p>.tar.bz2 (j)</p>
<ul>
<li><code>-j 压缩为.tar.bz2格式</code>   tar -jcvf xx.tar.bz2 源文件</li>
<li><code>-x 解压缩为.tar.bz2格式</code>  tar -jxvf xx.tar.bz2 </li>
</ul>
</li>
<li><p>-C 位置</p>
</li>
</ul>
<h1 id="关机和重启命令"><a href="#关机和重启命令" class="headerlink" title="关机和重启命令"></a>关机和重启命令</h1><h2 id="shutdown-选项-时间"><a href="#shutdown-选项-时间" class="headerlink" title="shutdown [选项] 时间"></a>shutdown [选项] 时间</h2><ul>
<li>-c 取消前一个关机命令</li>
<li>-h 关机</li>
<li>-r 重启</li>
</ul>
<h2 id="其他关机命令-非安全，建议shutdown"><a href="#其他关机命令-非安全，建议shutdown" class="headerlink" title="其他关机命令 (非安全，建议shutdown)"></a>其他关机命令 (非安全，建议shutdown)</h2><ul>
<li>halt  (非安全，建议shutdown)</li>
<li>poweroff (非安全，建议shutdown)</li>
<li>init 0 (非安全，建议shutdown)</li>
</ul>
<h2 id="其他重启命令"><a href="#其他重启命令" class="headerlink" title="其他重启命令"></a>其他重启命令</h2><ul>
<li>reboot 相对安全</li>
<li>init 6 非安全</li>
</ul>
<h2 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h2><blockquote>
<p>查看系统运行级别<br>cat /etc/inittab 默认级别<br>runlevel</p>
</blockquote>
<ul>
<li>0 关机</li>
<li>1 单用户</li>
<li>2 不完全多用户，不包含NFS服务</li>
<li>3 完全多用户</li>
<li>4 未分配</li>
<li>5 图形界面</li>
<li>6 重启</li>
</ul>
<h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><h2 id="挂载命令"><a href="#挂载命令" class="headerlink" title="挂载命令"></a>挂载命令</h2><blockquote>
<p>用户登录查看和用户交互命令</p>
</blockquote>
<ul>
<li>mount 查询系统中已经挂载的设备</li>
<li>mount -a 依据配置文件/etc/fstab的内容，自动挂载</li>
</ul>
<h2 id="挂载命令格式"><a href="#挂载命令格式" class="headerlink" title="挂载命令格式"></a>挂载命令格式</h2><p><code>mount [-t 文件系统] [-o 特殊选项] 设备文件名 挂载点</code></p>
<ul>
<li>-t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统</li>
<li>-0 特殊选项：可以指定挂载的额外选项</li>
<li>#!/bin/bash  最好必须写</li>
<li>默认是可执行 exec.  </li>
<li>mount -0 remount, noexec /home  重新挂载/boot分区， 并使用noexec权限</li>
<li>remount 重新挂载已经挂载的文件系统，一般用于指定修改特殊权限</li>
</ul>
<h3 id="挂载光盘"><a href="#挂载光盘" class="headerlink" title="挂载光盘"></a>挂载光盘</h3><ul>
<li>mkdir /mnt/cdrom/  建立挂载点</li>
<li>mount -t iso9660 /dev/cdrom /mnt/cdrom 挂载光盘</li>
<li>mount /dev/sr0 /mnt/cdrom</li>
<li>umount /mnt/cdrom 必须卸载</li>
</ul>
<h3 id="挂载U盘"><a href="#挂载U盘" class="headerlink" title="挂载U盘"></a>挂载U盘</h3><ul>
<li>fdisk -i 查看U盘设备文件</li>
<li>mount -t vfat /dev/sdb1 /mnt/usb/  </li>
<li><code>注意：Linux默认不支持NTFS文件系统</code></li>
</ul>
<h2 id="用户登录查看命令"><a href="#用户登录查看命令" class="headerlink" title="用户登录查看命令"></a>用户登录查看命令</h2><ul>
<li>w 用户名 命令输出如下<ul>
<li>USER: 登录的用户名</li>
<li>TTY:  登录终端</li>
<li>FROM： 从哪个IP地址登录</li>
<li>LOGIN@: 登录时间</li>
<li>IDLE： 用户闲置时间</li>
<li>JCPU: 指的是和该终端廉洁的所有进程占用的时间。这个时间里并不包括过去的后台作业时间，但却包括当前正在运行的后台作业所占用的时间</li>
<li>PCUP：是指当前进程所占用的时间</li>
<li>WHAT: 当前正在运行的命令</li>
</ul>
</li>
<li>who 用户名</li>
<li>last 默认是读取 /var/log/wtmp文件数据，输出如下<ul>
<li>用户名</li>
<li>登录终端</li>
<li>登录IP</li>
<li>登录时间</li>
<li>退出时间（在线时间）</li>
</ul>
</li>
<li>lastlog 默认是读取/var/log/lastlog文件内容<ul>
<li>用户名</li>
<li>登录终端</li>
<li>登录ip</li>
<li>最后一次登录时间</li>
</ul>
</li>
</ul>
<h1 id="Shell部分"><a href="#Shell部分" class="headerlink" title="Shell部分"></a>Shell部分</h1><h2 id="Shell概况"><a href="#Shell概况" class="headerlink" title="Shell概况"></a>Shell概况</h2><ul>
<li>命令行解释器，计算机可不认识命令，只认识0101. 为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启东、挂起、挺直甚至是编写一个程序</li>
<li>SHell还是一个功能相当强大的编译语言，易变写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Sjell中可以直接调用Linux系统命令</li>
</ul>
<h2 id="Shell的分类"><a href="#Shell的分类" class="headerlink" title="Shell的分类"></a>Shell的分类</h2><ul>
<li>Bourne Shell: 从1979起Unix就开始使用Bourne Shell， 主文件名为sh。</li>
<li>C Shell: 主要在BSD版的Unix系统中使用，其语言和C语言像相似而得名</li>
<li>Shell的两种主要语法类型有Bourne和C，这两种语法彼此不兼容。Bourne家族主要有sh、ksh、Bash、psh、zsh； C家族主要包括csh、tcsh</li>
</ul>
<h2 id="脚本执行方式"><a href="#脚本执行方式" class="headerlink" title="脚本执行方式"></a>脚本执行方式</h2><ul>
<li>echo </li>
<li>vi hello.sh  (#!/bin/bash) 可以调用系统命令</li>
<li>赋予执行权限，直接运行<ul>
<li>chmod 755 hello.sh</li>
<li>./hello.sh</li>
</ul>
</li>
<li>通过Bash调用执行脚本<ul>
<li>bash hello.sh</li>
</ul>
</li>
</ul>
<h2 id="别名与快捷键"><a href="#别名与快捷键" class="headerlink" title="别名与快捷键"></a>别名与快捷键</h2><ul>
<li>alias cp = ‘cp -i’,  mv = ‘mv -i’,  rm = ‘rm -i’等等，提示，是否xxx？</li>
<li>unalias 删除别名</li>
<li>vi ~/.bashrc 写入环境变量配置文件</li>
<li>source ~/.bashrc  可以让配置重新生效</li>
</ul>
<h3 id="命令生效顺序"><a href="#命令生效顺序" class="headerlink" title="命令生效顺序"></a>命令生效顺序</h3><ol>
<li>用绝对路径或相对路径执行的命令</li>
<li>执行别名</li>
<li>执行Bash的内部命令</li>
<li>执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令</li>
</ol>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li>ctrl+c 强制终止当前命令</li>
<li>ctrl+l 清屏</li>
<li>ctrl+a 光标移动到命令行首</li>
<li>ctrl+e 光标移动到命令行尾</li>
<li>ctrl+u 从光标所在位置删除到行首</li>
<li>ctrl+z 把命令放入后台</li>
<li>ctrl+r 在历史命令中搜索</li>
</ul>
<h2 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h2><ul>
<li>history [选项] [历史命令保存文件]</li>
<li>-c 清空历史命令</li>
<li>-w 把缓存中的历史命令写入历史命令保存文件 ~/.bash_history</li>
<li>vim /etc/profile</li>
<li>上下剪头调用以前的历史命令</li>
<li>!n 重复执行第n条历史命令</li>
<li>!! 重复执行上一条命令</li>
<li>！字符串   重复执行最后一条以该字符串开头的命令</li>
</ul>
<h2 id="Bash命令补全"><a href="#Bash命令补全" class="headerlink" title="Bash命令补全"></a>Bash命令补全</h2><ul>
<li>tab键</li>
</ul>
<h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>把命令输出保存到文件， &gt; 代表覆盖的形式写入， &gt;&gt;代表追加的方式写入</p>
<ul>
<li>‘&gt;’覆盖，&gt;&gt; 追加</li>
<li>命令 &gt; 文件 2&gt;&amp;1    </li>
<li>命令 &gt;&gt; 文件 2&gt;&amp;1  </li>
<li>命令 &amp;&gt; 文件</li>
<li>命令 &amp;&gt;&gt; 文件</li>
<li>命令&gt;&gt;文件1  2&gt;&gt;文件2  <code>把正确的输出追加到文件1，把错误的输出追加到文件2中</code></li>
</ul>
<ul>
<li><code>ls &amp;&gt;/dev/null</code> 相当于既不显示到屏幕上，也不保存</li>
</ul>
<h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><blockquote>
<p>wc [选项] [文件名]</p>
</blockquote>
<ul>
<li>-c 统计字节数</li>
<li>-w 统计单词数</li>
<li>-l 统计行数</li>
</ul>
<h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h2><h3 id="多命令顺序执行"><a href="#多命令顺序执行" class="headerlink" title="多命令顺序执行"></a>多命令顺序执行</h3><ul>
<li>; 命令1：命令2  多个命令顺序执行，命令之间没有任何联系</li>
<li>&amp;&amp; cmd1 &amp;&amp; cmd2 只有当cmd1正确执行 命令cmd2才会执行</li>
<li>|| cmd1 || cmd2 当命令cmd1不正确的时候，命令2才会执行，正确则不执行</li>
</ul>
<h3 id="管道符-1"><a href="#管道符-1" class="headerlink" title="管道符"></a>管道符</h3><p><code>命令1 | 命令2</code>，命令1的正确输出作为命令2的操作对象</p>
<ul>
<li>ll -a /etc/ | more </li>
<li>netstat -an | grep xxx</li>
</ul>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><ul>
<li>? 匹配<code>一个</code>任意字符</li>
<li>* 匹配0个或<code>任意多个</code>任意字符，也就是可以匹配任何内容</li>
<li>[] 匹配中括号中<code>任意一个</code>字符，例如：[abc]代表一定匹配一个字符串，或者是a,或者b,或者c。</li>
<li>[-] 匹配中括号中<code>任意一个</code>字符， -代表一个<code>范围</code>。例如[a-z]代表匹配一个小写字母</li>
<li>[^] 逻辑非，代表匹配<code>不是</code>中括号内的<code>一个字符</code>。例如：[^0-9]代表匹配不是一个数字的字符</li>
</ul>
<h2 id="Bash中其他特殊字符"><a href="#Bash中其他特殊字符" class="headerlink" title="Bash中其他特殊字符"></a>Bash中其他特殊字符</h2><table>
<thead>
<tr>
<th align="center"><code>符号</code></th>
<th align="center"><code>作用</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">‘’</td>
<td align="center">单引号。在单引号中<code>所有的特殊符号</code>，如”$”和”`“(反引号)都 <code>没有特殊含义</code>。</td>
</tr>
<tr>
<td align="center">“”</td>
<td align="center">双引号。在双引号中特殊字符都没有特殊含义，但是”$”、”`”、和”&quot;是例外，拥有”调用变量的值”、”引用命令”、”转义符”的特殊含义。</td>
</tr>
<tr>
<td align="center">``</td>
<td align="center">反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样，补货推荐使用$()，因为反引号非常容易看错</td>
</tr>
<tr>
<td align="center">$()</td>
<td align="center">和反引号作用一样，用来引用系统命令</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">在Shell脚本中，#开头的行代表注释。</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">用于调用变量的值，如需要调用变量name的值得时候，需要用$name的方式得到变量的值</td>
</tr>
<tr>
<td align="center">\</td>
<td align="center">转义符，跟在\之后的特殊字符将失去特殊含义，变为普通字符。如$ 将输出”$”符号</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LLDB</title>
    <url>/llvm/lldb.html</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9sbGRiLmxsdm0ub3JnLw==">LLDB官方文档地址<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="LLDB调试器"><a href="#LLDB调试器" class="headerlink" title="LLDB调试器"></a>LLDB调试器</h1><p>LLVM源代码树，并在lldb 子目录中找到源代码：</p>
<blockquote>
<p>git clone <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xsdm0vbGx2bS1wcm9qZWN0LmdpdA==">https://github.com/llvm/llvm-project.git<i class="fa fa-external-link-alt"></i></span><br>请注意，LLDB通常使用CMake和Ninja从top-of-trunk构建。另外它构建：</p>
</blockquote>
<ul>
<li>在macOS上生成Xcode项目</li>
<li>在Linux和FreeBSD上使用clang和libstdc ++ / libc ++</li>
<li>在NetBSD上使用GCC / clang和libstdc ++ / libc ++</li>
<li>在Windows上生成VS 2017或更高版本的项目</li>
</ul>
<p>先说大话：</p>
<ul>
<li>构建库以包含在IDE，命令行工具和其他分析工具中</li>
<li>高性能和高效的内存使用</li>
<li>可扩展：Python可编写脚本并使用插件架构</li>
<li>在有意义的地方重用现有的编译器技术</li>
<li>出色的多线程调试支持</li>
<li>对C，Objective-C和C ++的大力支持</li>
<li>可重定向以支持多个平台</li>
<li>为调试器研究和其他创新提供基础</li>
</ul>
<p>LDB支持各种基本调试功能，如读取DWARF，支持步骤，下一步，完成，回溯等。一些更感兴趣的位是：</p>
<ul>
<li>用于可移植性和可扩展性的插件架构：<ul>
<li>可执行文件格式的目标文件解析器。目前支持包括Mach-O（32位和64位）和ELF（32位）。</li>
<li>对象容器解析器，用于提取文件中包含的对象文件。支持目前包括通用Mach-O文件和BSD档案。</li>
<li>调试符号文件解析器以从对象文件中逐步提取调试信息。支持目前包括DWARF和Mach-O符号表。</li>
<li>符号供应商插件从可执行对象的各种不同源收集数据。</li>
<li>每个体系结构的反汇编插件。支持目前包括用于i386，x86-64，ARM / Thumb和PPC64le的LLVM反汇编程序</li>
<li>调试器插件实现调试所需的主机和目标特定功能。</li>
</ul>
</li>
<li>SWIG生成的脚本桥接允许Python访问和控制调试器库的公共API。</li>
<li>远程协议服务器debugserver在i386和x86-64上实现macOS调试。</li>
<li>命令行调试器 - lldb可执行文件本身。</li>
<li>库的框架API。</li>
</ul>
<h2 id="编译器集成的好处"><a href="#编译器集成的好处" class="headerlink" title="编译器集成的好处"></a>编译器集成的好处</h2><p>LLDB目前将调试信息转换为clang类型，以便它可以利用clang编译器基础结构。这允许LLDB在表达式中支持最新的C，C ++，Objective-C和Objective-C ++语言特性和运行时，而无需重新实现任何此功能。它还利用编译器在对表达式进行函数调用时，在反汇编指令和提取指令细节等时处理所有ABI细节。</p>
<p>主要好处包括：</p>
<ul>
<li>最新的C，C ++，Objective-C语言支持</li>
<li>可以声明局部变量和类型的多行表达式</li>
<li>支持时使用JIT表达式</li>
<li>当不能使用JIT时，评估表达式中间表示（IR）</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="命令结构"><a href="#命令结构" class="headerlink" title="命令结构"></a>命令结构</h2><blockquote>
<p><code>&lt;noun&gt; &lt;verb&gt; [-options [option-value]] [argument [argument...]]</code></p>
</blockquote>
<p>选项可以放在命令行的任何位置，但是如果参数以“ - ”开头，那么你必须告诉lldb你已经完成了当前命令的选项，方法是添加一个选项终止：“ - ”所以例如如果你想启动一个进程并给“进程启动”命令“-stop-at-entry”选项，但是你想要启动你要启动的进程并使用参数“-program_arg value”，你会输入：</p>
<ul>
<li><p>(lldb) process launch –stop-at-entry – -program_arg value</p>
</li>
<li><p>要在LLDB中设置相同的文件和换行符，您可以输入以下任一项：<br>(lldb) breakpoint set –file foo.c –line 12<br>(lldb) breakpoint set -f foo.c -l 12</p>
</li>
<li><p>您可以多次使用-name选项在一组函数上创建断点。<br>(lldb) breakpoint set –name foo<br>(lldb) breakpoint set -n foo<br>(lldb) breakpoint set –name foo –name bar</p>
</li>
<li><p>要在名为foo的所有C ++方法上设置断点，您可以输入以下任一项：<br>(lldb) breakpoint set –method foo<br>(lldb) breakpoint set -M foo</p>
</li>
<li><p>设置一个名为alignLeftEdges的断点Objective-C选择器：<br>(lldb) breakpoint set –selector alignLeftEdges:<br>(lldb) breakpoint set -S alignLeftEdges:</p>
</li>
<li><p>您可以使用“-shlib &lt;path&gt;”（简称“-s &lt;path&gt;”）将任何断点限制为特定的可执行映像：<br>(lldb) breakpoint set –shlib foo.dylib –name foo<br>(lldb) breakpoint set -s foo.dylib -n foo</p>
</li>
<li><p>lldb命令解释器对命令名进行最短的唯一字符串匹配，因此以下两个命令都将执行相同的命令：<br>(lldb) breakpoint set -n “-[SKTGraphicView alignLeftEdges:]”<br>(lldb) br s -n “-[SKTGraphicView alignLeftEdges:]”</p>
</li>
</ul>
<h2 id="设置观察点"><a href="#设置观察点" class="headerlink" title="设置观察点"></a>设置观察点</h2><p>除断点外，您还可以使用help watchpoint查看监视点操作的所有命令。例如，我们可能会执行以下操作来查看名为“global”的变量进行写入操作，但只有在条件“（global == 5）”为真时才会停止：</p>
<p>(lldb) watch set var global<br>(lldb) watch modify -c ‘(global==5)’<br>(lldb) watch list<br>(lldb) about to write to ‘global’…</p>
<h2 id="启动或附加到您的程序"><a href="#启动或附加到您的程序" class="headerlink" title="启动或附加到您的程序"></a>启动或附加到您的程序</h2><ul>
<li><p>要在lldb中启动程序，我们使用“process launch”命令或其内置别名之一：<br>(lldb) process launch<br>(lldb) run<br>(lldb) r</p>
</li>
<li><p>您还可以按进程ID或进程名称附加到进程。当按名称附加到进程时，lldb还支持“-waitfor”选项，该选项等待显示该名称的下一个进程，并附加到该进程<br>(lldb) process attach –pid 123<br>(lldb) process attach –name Sketch<br>(lldb) process attach –name Sketch –waitfor</p>
</li>
<li><p>启动或附加到进程后，您的进程可能会在某处停止：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">(lldb) process attach -p <span class="number">12345</span></span><br><span class="line"><span class="built_in">Process</span> <span class="number">46915</span> Attaching</span><br><span class="line"><span class="built_in">Process</span> <span class="number">46915</span> Stopped</span><br><span class="line"><span class="number">1</span> of <span class="number">3</span> threads stopped with reasons:</span><br><span class="line">* thread #<span class="number">1</span>: tid = <span class="number">0x2c03</span>, <span class="number">0x00007fff85cac76a</span>, where = libSystem.B.dylib`__getdirentries64 + <span class="number">10</span>, stop reason = signal = SIGSTOP, queue = com.apple.main-thread</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="控制你的程序"><a href="#控制你的程序" class="headerlink" title="控制你的程序"></a>控制你的程序</h2><ul>
<li><p>启动后，我们可以继续，直到我们达到断点。进程控制的原始命令都存在于“thread”命令下：<br>(lldb) thread continue<br>Resuming thread 0x2c03 in process 46915<br>Resuming process 46915<br>(lldb)</p>
</li>
<li><p>步进命令<br>(lldb) thread step-in    // The same as gdb’s “step” or “s”<br>(lldb) thread step-over  // The same as gdb’s “next” or “n”<br>(lldb) thread step-out   // The same as gdb’s “finish” or “f”</p>
</li>
<li><p>逐步指令版本：<br>(lldb) thread step-inst       // The same as gdb’s “stepi” / “si”<br>(lldb) thread step-over-inst  // The same as gdb’s “nexti” / “ni”</p>
</li>
<li><p>最后，lldb运行直到行或帧退出步进模式：<br>(lldb) thread until 100</p>
</li>
</ul>
<h2 id="检查堆栈帧状态"><a href="#检查堆栈帧状态" class="headerlink" title="检查堆栈帧状态"></a>检查堆栈帧状态</h2><ul>
<li>检查框架参数和局部变量的最方便方法是使用“frame variable”命令：<br>(lldb) frame variable</li>
</ul>
<h1 id="不想写了，用到的时候，写一些用到的东西吧，学习的话，大家去看官方文档吧！！！"><a href="#不想写了，用到的时候，写一些用到的东西吧，学习的话，大家去看官方文档吧！！！" class="headerlink" title="不想写了，用到的时候，写一些用到的东西吧，学习的话，大家去看官方文档吧！！！"></a>不想写了，用到的时候，写一些用到的东西吧，学习的话，大家去看官方文档吧！！！</h1>]]></content>
      <categories>
        <category>LLVM</category>
        <category>LLDB</category>
      </categories>
      <tags>
        <tag>LLDB</tag>
      </tags>
  </entry>
  <entry>
    <title>lua相关</title>
    <url>/luafile/index.html</url>
    <content><![CDATA[<ul>
<li><a href="./luacode">Lua源码学习</a></li>
<li><a href="./lua-patch">在iOS上面的应用，Lua热修复</a></li>
<li><a href="./lua">lua随缘记录</a></li>
</ul>
<p>参考：<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNvZGluZ25vdy5jb20vMjAwNS8xMi9jb21wYXJlX3dpdGhfbHVhXzUuaHRtbA==">虚拟机之比较，lua 5 的实现<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>lua_patch</title>
    <url>/luafile/lua-patch.html</url>
    <content><![CDATA[<h1 id="源码我已公开至-github-持续更新维护"><a href="#源码我已公开至-github-持续更新维护" class="headerlink" title="源码我已公开至 github , 持续更新维护"></a>源码我已公开至 github , 持续更新维护</h1><p>访问链接如下<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmdrZWppZS9sdWFfb2M=">https://github.com/wangkejie/lua_oc<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="首先熟悉下lua和原生的交互"><a href="#首先熟悉下lua和原生的交互" class="headerlink" title="首先熟悉下lua和原生的交互"></a>首先熟悉下lua和原生的交互</h1><ol>
<li>__call 元方法</li>
<li>__index 元方法</li>
<li>__newindex 元方法</li>
<li>__gc </li>
</ol>
<p>还有很多 __add __mode等等。自行学习。</p>
<h1 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h1>]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>lua</tag>
        <tag>热修复</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua</title>
    <url>/luafile/lua.html</url>
    <content><![CDATA[<h1 id="库文件地址"><a href="#库文件地址" class="headerlink" title="库文件地址"></a>库文件地址</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVhLm9yZy8=">lua官方地址<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sdWFqaXQub3JnL3BlcmZvcm1hbmNlX2FybS5odG1s">luajit<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h1><p>这里先卖个关子，有一次面试，面试官问我， objc_msgsend 可以使用C语言写吗？ 当时没回答好，理论上是可以的。</p>
<p>我们都知道lua是解释执行语言，C是编译执行语言，最大的区别，就是C可以充分利用编译器，制作成汇编指令，效率最高。</p>
<p>lua解释性语言只能解释成字节码，模拟汇编，进行操作。</p>
<p>lua是C写的，所以 objc_msgsend 理论上也可以C实现，动态的执行方法(不同参数，不同返回值)，但是效率就降低为解释执行语言的效率了。</p>
<p>待补充。。。。。。。。。</p>
<h2 id="lua指令集"><a href="#lua指令集" class="headerlink" title="lua指令集"></a>lua指令集</h2><p>参看<code>lopcodes.h</code>文件，里面定义了很多指令,<br>还有一个重要函数，我就不贴代码了，一个方法400多行，在<code>lvm.C</code>文件中的<code>luaV_execute</code>，可以看下</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/* main loop of interpreter */</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      ...这里会对不不同指令进行操作</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>




<h2 id="一些零散的源码阅读"><a href="#一些零散的源码阅读" class="headerlink" title="一些零散的源码阅读"></a>一些零散的源码阅读</h2><p>Lua虚拟机并不能执行我们的ifStateMent这种东西。Lua源码里的实现也是类似这种TokenType 和 结构化的 if Statement whileStatement等等，并且Lua没有生成完整的语法树。Lua源码的实现里面，它是解析一些语句，生成临时的语法树，然后翻译成指令集的。并不会等所有的语句都解析完了再翻译的。语义解析和翻译成指令集是并行的一个过程。贴一个源码里面关于语义解析的部分实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">body</span> <span class="params">(LexState *ls, expdesc *e, <span class="type">int</span> needself, <span class="type">int</span> line)</span> &#123;</span><br><span class="line">  <span class="comment">/* body -&gt;  `(&#x27; parlist `)&#x27; chunk END */</span></span><br><span class="line">  FuncState new_fs;</span><br><span class="line">  open_func(ls, &amp;new_fs);</span><br><span class="line">  new_fs.f-&gt;linedefined = line;</span><br><span class="line">  checknext(ls, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (needself) &#123;</span><br><span class="line">    new_localvarliteral(ls, <span class="string">&quot;self&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    adjustlocalvars(ls, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  parlist(ls);</span><br><span class="line">  checknext(ls, <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">  chunk(ls);</span><br><span class="line">  new_fs.f-&gt;lastlinedefined = ls-&gt;linenumber;</span><br><span class="line">  check_match(ls, TK_END, TK_FUNCTION, line);</span><br><span class="line">  close_func(ls);</span><br><span class="line">  pushclosure(ls, &amp;new_fs, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h1 id="LuaJit"><a href="#LuaJit" class="headerlink" title="LuaJit"></a>LuaJit</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnV3YTRkLmNvbS9hcmNoaXZlcy91c3BhcmtsZV9sdWFqaXQuaHRtbA==">iOS的luajit<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>LuaJIT分为JIT模式和Interpreter模式</li>
</ol>
<ul>
<li>JIT模式: 高效的机器码<code>级别</code>执行, 然而不幸的是这个模式在<code>iOS下是无法开启的</code>，因为iOS为了安全，从系统设计上禁止了用户进程自行申请<code>有执行权限的内存空间</code>，因此你没有办法在运行时编译出一段代码到内存然后执行，所以JIT模式在iOS以及其他有权限管制的平台（例如PS4，XBox）都不能使用。</li>
<li>Interpreter模式：编译成中间态的字节码（bytecode）, 相比之下当然比JIT慢。但好处是这个模式不需要<code>运行时生成可执行机器码</code>（<code>字节码是不需要申请可执行内存空间的</code>）</li>
</ul>
<ol start="2">
<li>JIT模式一定更快？不一定！<br>参考下图,这里可以看到，第一，Interpreter模式是必须的，无论平台是否允许JIT，都必须先使用Interpreter执行；第二，并非所有代码都会JIT执行，仅仅是部分代码会这样，并且是运行过程中决定的。</li>
</ol>
<img src="/images/lua/luajit.png" class="" title="luajit">


<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol>
<li>Reduce number of unbiased/unpredictable branches.减少不可预测的分支代码</li>
<li>Use FFI data structures. 如果可以，将你的数据结构用ffi实现，而不是用lua table实现</li>
<li>Call C functions only via the FFI.尽可能用ffi来调用c函数。</li>
<li>Use plain ‘for i=start,stop,step do … end’ loops.实现循环时，最好使用简单的for i = start, stop, step do这样的写法，或者使用ipairs，而尽量避免使用for k,v in pairs(x) do</li>
<li>Find the right balance for unrolling.循环展开，有利有弊，需要自己去平衡</li>
<li>Define and call only ‘local’ (!) functions within a module.</li>
<li>Cache often-used functions from other modules in upvalues.</li>
<li>Avoid inventing your own dispatch mechanisms.避免使用你自己实现的分发调用机制，而尽量使用內建的例如metatable这样的机制<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 编程的时候为了结构优雅，常常会引入像消息分发这样的机制，然后在消息来的时候根据我们给消息定义的枚举来调用对应的实现，过去我们也习惯写成：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> opcode == OP_1 <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">elesif opcode == OP_2 <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 但在luajit下，更建议将上面实现成table或者metatable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> callbacks = &#123;&#125;</span><br><span class="line"></span><br><span class="line">callbacks[OP_1] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> ... <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">callbacks[OP_2] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> ... <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这是因为表查找和metatable查找都是可以参与jit优化的，而自行实现的消息分发机制，往往会用到分支代码或者其他更复杂的代码结构，性能上反而不如纯粹的表查找+jit优化来得快</span></span><br></pre></td></tr></table></figure></li>
<li>Do not try to second-guess the JIT compiler.无需过多去帮jit编译器做手工优化。</li>
<li>Be careful with aliasing, esp. when using multiple arrays.变量的别名可能会阻止jit优化掉子表达式，尤其是在使用多个数组的时候。</li>
<li>Reduce the number of live temporary variables.减少存活着的临时变量的数量</li>
<li>Do not intersperse expensive or uncompiled operations.减少使用高消耗或者不支持jit的操作</li>
</ol>
<h1 id="Lua的API"><a href="#Lua的API" class="headerlink" title="Lua的API"></a>Lua的API</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cud2VuamlhbmdzLmNvbS9kb2MvbHVhX2dldGZpZWxk">参考api文档<i class="fa fa-external-link-alt"></i></span></p>
<p>#define lua_open()    luaL_newstate()  开启一个lua状态机</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lua_settable</span> <span class="params">(lua_State *L, <span class="type">int</span> index)</span>;</span><br><span class="line"><span class="comment">// Does the equivalent to t[k] = v,</span></span><br><span class="line"><span class="comment">// where t is the value at the given valid index index,</span></span><br><span class="line"><span class="comment">// v is the value at the top of the stack,</span></span><br><span class="line"><span class="comment">// and k is the value just below the top.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This function pops both the key and the value from the stack.</span></span><br><span class="line"><span class="comment">// As in Lua, this function may trigger a metamethod</span></span><br><span class="line"><span class="comment">// for the “newindex” event (see §2.8).</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>lua_pop(L,num)函数从栈顶开始移除。<br> 当num&gt;0时从栈顶移除指定个数 。<br> 当num=0时栈不受影响<br> 当num=-1时栈中元素全部移除</p>
</li>
<li><p>lua_settop函数说明<br> 该函数用于指定栈的高度，栈只能从栈顶压栈，不能从栈底添加数据。所以栈底的数据会保持不变。<br> 当新的高度大于原来的高度时，会从栈顶压入数据，压入的数据不可用(因为是随机的)。<br> 当新的高度小于原来的高度时，会从栈顶移除多余的元素。<br> 当输入参数为负数时，表示从栈顶开始的索引（最栈顶元素为-1）。该函数会移除栈顶到该元素之间的所以元素。-1则无，-2 则移除-1 。-3则移除-1，-2。以此类推。但是负数编号不能超出栈底的负数索引，超出会抛出异常。lua_pop函数及是使用了该特性。</p>
</li>
<li><p>int luaL_getmetatable (lua_State <em>L,constchar</em>tname);<br> 将注册表中 tname 对应的元表（参见 luaL_newmetatable）压栈。如果没有 tname 对应的元表，则将 nil 压栈并返回假。</p>
</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnV3YTRkLmNvbS9hcmNoaXZlcy91c3BhcmtsZV9sdWFqaXQuaHRtbA==">https://blog.uwa4d.com/archives/usparkle_luajit.html<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3dpa2kubHVhaml0Lm9yZy9OdW1lcmljYWwtQ29tcHV0aW5nLVBlcmZvcm1hbmNlLUd1aWRl">http://wiki.luajit.org/Numerical-Computing-Performance-Guide<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTU5MDI5Mg==">深入浅出<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>lua随缘记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua源码学习</title>
    <url>/luafile/luacode.html</url>
    <content><![CDATA[<h1 id="lua虚拟机"><a href="#lua虚拟机" class="headerlink" title="lua虚拟机"></a>lua虚拟机</h1><h2 id="阅读源代码的次序"><a href="#阅读源代码的次序" class="headerlink" title="阅读源代码的次序"></a>阅读源代码的次序</h2><p>首先、阅读外围的库是如何实现功能扩展的，<br>然后、阅读 Lua 的具体实现。<br>之后、可以开始了解 Lua VM 的实现。<br>接下来就是分别理解函数调用、返回，string，metatable，table实现<br>debug模块是一个额外的设施、<br>最后是parse 等等编译相关的部分。<br>垃圾收集将是最难的部分，可能会花掉最多的时间去理解细节。<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNvZGluZ25vdy5jb20vMjAxMS8wNC9sdWFfZ2NfbXVsdGl0aHJlYWRpbmcuaHRtbA==">Lua GC 的源码剖析<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="虚拟机核心功能"><a href="#虚拟机核心功能" class="headerlink" title="虚拟机核心功能"></a>虚拟机核心功能</h2><table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>lua.c</td>
<td>可执行main函数入口</td>
</tr>
<tr>
<td>lapi.c</td>
<td>C语言接口</td>
</tr>
<tr>
<td>ldebug.c</td>
<td>Debug接口</td>
</tr>
<tr>
<td>ldo.c</td>
<td>函数调用、栈管理</td>
</tr>
<tr>
<td>lfunc.c</td>
<td>函数原型及闭包管理</td>
</tr>
<tr>
<td>lgc.c</td>
<td>垃圾回收机制</td>
</tr>
<tr>
<td>lmem.c</td>
<td>内存管理</td>
</tr>
<tr>
<td>lobject.c</td>
<td>对象操作函数</td>
</tr>
<tr>
<td>lopcodes.c</td>
<td>虚拟机字节码定义</td>
</tr>
<tr>
<td>lstate.c</td>
<td>全局状态机  管理全局信息</td>
</tr>
<tr>
<td>lstring.c</td>
<td>字符串池</td>
</tr>
<tr>
<td>ltable.c</td>
<td>表类型的相关操作</td>
</tr>
<tr>
<td>ltm.c</td>
<td>元方法</td>
</tr>
<tr>
<td>lvm.c</td>
<td>虚拟机</td>
</tr>
<tr>
<td>lzio.c</td>
<td>输入流接口</td>
</tr>
</tbody></table>
<h2 id="源代码解析和预编译"><a href="#源代码解析和预编译" class="headerlink" title="源代码解析和预编译"></a>源代码解析和预编译</h2><table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>lcode.c</td>
<td>代码生成器</td>
</tr>
<tr>
<td>ldump.c</td>
<td>序列化预编译的Lua字节码</td>
</tr>
<tr>
<td>llex.c</td>
<td>词法分析器</td>
</tr>
<tr>
<td>lparse.c</td>
<td>解析器</td>
</tr>
<tr>
<td>lundump.c</td>
<td>还原预编译的字节码</td>
</tr>
</tbody></table>
<h2 id="内嵌库"><a href="#内嵌库" class="headerlink" title="内嵌库"></a>内嵌库</h2><table>
<thead>
<tr>
<th>文件</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>lauxlib.c</td>
<td>库编写用到的辅助函数库</td>
</tr>
<tr>
<td>lbaselib.c</td>
<td>基础库</td>
</tr>
<tr>
<td>ldblib.c</td>
<td>Debug库</td>
</tr>
<tr>
<td>linit.c</td>
<td>内嵌库的初始化</td>
</tr>
<tr>
<td>liolib.c</td>
<td>IO库</td>
</tr>
<tr>
<td>lmathlib.c</td>
<td>数学库</td>
</tr>
<tr>
<td>loadlib.c</td>
<td>动态扩展库管理</td>
</tr>
<tr>
<td>loslib.c</td>
<td>OS库</td>
</tr>
<tr>
<td>lstrlib.c</td>
<td>字符串库</td>
</tr>
<tr>
<td>ltablib.c</td>
<td>表处理库</td>
</tr>
</tbody></table>
<h2 id="外部符号的前缀指示其来自的模块："><a href="#外部符号的前缀指示其来自的模块：" class="headerlink" title="外部符号的前缀指示其来自的模块："></a>外部符号的前缀指示其来自的模块：</h2><p>luaA_-lapi.c<br>luaB_-lbaselib.c<br>luaC_-lgc.c 垃圾回收部分<br>luaD_-ldo.c 函数的运行流程：函数调用及返回<br>luaE_-lstate.c 虚拟机的当前状态<br>luaF_-lfunc.c function实现<br>luaG_-ldebug.c<br>luaH_-ltable.c table实现<br>luaI_-lauxlib.c<br>luaK_-lcode.c<br>luaL_-lauxlib.c / h，linit.c（公共函数）<br>luaM_-lmem.c 内存管理<br>luaO_-lobject.c 不同的数据类型<br>luaP_-lopcodes.c 虚拟机的行为是由一组 opcode 控制的<br>luaS_-lstring.c string实现<br>luaT_-ltm.c 元表<br>luaU_-lundump.c<br>luaV_-lvm.c 虚拟机对 opcode 的解析和运作<br>luaX_-llex.c<br>luaY_-lparser.c<br>luaZ_-lzio.c 带缓冲的流处理<br>lua_-lapi.c / h + luaconf.h，debug.c<br>luai_-luaconf.h<br>luaopen_-luaconf.h +库（lbaselib.c，ldblib.c，liolib.c，lmathlib.c，<br>                                  loadlib.c，loslib.c，lstrlib.c，ltablib.c）</p>
<h2 id="结构体-类型"><a href="#结构体-类型" class="headerlink" title="结构体/类型"></a>结构体/类型</h2><p>Value结构体  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Union of all Lua values</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">Value</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">GCObject</span> *<span class="title">gc</span>;</span>    <span class="comment">/* collectable objects */</span></span><br><span class="line">  <span class="type">void</span> *p;         <span class="comment">/* light userdata */</span></span><br><span class="line">  lua_CFunction f; <span class="comment">/* light C functions */</span></span><br><span class="line">  lua_Integer i;   <span class="comment">/* integer numbers */</span></span><br><span class="line">  lua_Number n;    <span class="comment">/* float numbers */</span></span><br><span class="line">&#125; Value;</span><br></pre></td></tr></table></figure>

<p>TValue结构体 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Tagged Values. This is the basic representation of values in Lua:</span></span><br><span class="line"><span class="comment">** an actual value plus a tag with its type.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TValuefields	Value value_; lu_byte tt_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TValue</span> &#123;</span></span><br><span class="line">  TValuefields;</span><br><span class="line">&#125; TValue;</span><br></pre></td></tr></table></figure>

<p>GCObject</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Common Header for all collectable objects (in macro form, to be</span></span><br><span class="line"><span class="comment">** included in other objects)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CommonHeader	GCObject *next; lu_byte tt; lu_byte marked</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Common type has only the common header</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GCObject</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可回收的类型,都继承自GCObject</p>
<ul>
<li>TString</li>
<li>Udata</li>
<li>Proto</li>
<li>Closure</li>
<li>Table</li>
</ul>
<p>TString的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Header for string value; string bytes follow the end of this structure</span></span><br><span class="line"><span class="comment">** (aligned according to &#x27;UTString&#x27;; see next).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte extra;  <span class="comment">/* reserved words for short strings; &quot;has hash&quot; for longs */</span></span><br><span class="line">  lu_byte shrlen;  <span class="comment">/* length for short strings */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hash;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> lnglen;  <span class="comment">/* length for long strings */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> *<span class="title">hnext</span>;</span>  <span class="comment">/* linked list for hash table */</span></span><br><span class="line">  &#125; u;</span><br><span class="line">&#125; TString;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Udata定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Header for userdata; memory area follows the end of this structure</span></span><br><span class="line"><span class="comment">** (aligned according to &#x27;UUdata&#x27;; see next).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Udata</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte ttuv_;  <span class="comment">/* user value&#x27;s tag */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">metatable</span>;</span></span><br><span class="line">  <span class="type">size_t</span> len;  <span class="comment">/* number of bytes */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> <span class="title">Value</span> <span class="title">user_</span>;</span>  <span class="comment">/* user value */</span></span><br><span class="line">&#125; Udata;</span><br></pre></td></tr></table></figure>

<p>Proto定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Function Prototypes</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte numparams;  <span class="comment">/* number of fixed parameters */</span></span><br><span class="line">  lu_byte is_vararg;</span><br><span class="line">  lu_byte maxstacksize;  <span class="comment">/* number of registers needed by this function */</span></span><br><span class="line">  <span class="type">int</span> sizeupvalues;  <span class="comment">/* size of &#x27;upvalues&#x27; */</span></span><br><span class="line">  <span class="type">int</span> sizek;  <span class="comment">/* size of &#x27;k&#x27; */</span></span><br><span class="line">  <span class="type">int</span> sizecode;</span><br><span class="line">  <span class="type">int</span> sizelineinfo;</span><br><span class="line">  <span class="type">int</span> sizep;  <span class="comment">/* size of &#x27;p&#x27; */</span></span><br><span class="line">  <span class="type">int</span> sizelocvars;</span><br><span class="line">  <span class="type">int</span> linedefined;</span><br><span class="line">  <span class="type">int</span> lastlinedefined;</span><br><span class="line">  TValue *k;  <span class="comment">/* constants used by the function */</span></span><br><span class="line">  Instruction *code;  <span class="comment">/* opcodes */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> **<span class="title">p</span>;</span>  <span class="comment">/* functions defined inside the function */</span></span><br><span class="line">  <span class="type">int</span> *lineinfo;  <span class="comment">/* map from opcodes to source lines (debug information) */</span></span><br><span class="line">  LocVar *locvars;  <span class="comment">/* information about local variables (debug information) */</span></span><br><span class="line">  Upvaldesc *upvalues;  <span class="comment">/* upvalue information */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LClosure</span> *<span class="title">cache</span>;</span>  <span class="comment">/* last-created closure with this prototype */</span></span><br><span class="line">  TString  *source;  <span class="comment">/* used for debug information */</span></span><br><span class="line">  GCObject *gclist;</span><br><span class="line">&#125; Proto;</span><br></pre></td></tr></table></figure>

<p>Closure分为两种，Lua闭包和C闭包，定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Closures</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ClosureHeader \</span></span><br><span class="line"><span class="meta">	CommonHeader; lu_byte nupvalues; GCObject *gclist</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CClosure</span> &#123;</span></span><br><span class="line">  ClosureHeader;</span><br><span class="line">  lua_CFunction f;</span><br><span class="line">  TValue upvalue[<span class="number">1</span>];  <span class="comment">/* list of upvalues */</span></span><br><span class="line">&#125; CClosure;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LClosure</span> &#123;</span></span><br><span class="line">  ClosureHeader;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Proto</span> *<span class="title">p</span>;</span> <span class="comment">//lua函数的原型指针</span></span><br><span class="line">  UpVal *upvals[<span class="number">1</span>];  <span class="comment">/* list of upvalues */</span></span><br><span class="line">&#125; LClosure;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Table定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte flags;  <span class="comment">/* 1&lt;&lt;p means tagmethod(p) is not present */</span></span><br><span class="line">  lu_byte lsizenode;  <span class="comment">/* log2 of size of &#x27;node&#x27; array */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> sizearray;  <span class="comment">/* size of &#x27;array&#x27; array */</span></span><br><span class="line">  TValue *<span class="built_in">array</span>;  <span class="comment">/* array part */</span></span><br><span class="line">  Node *node;</span><br><span class="line">  Node *lastfree;  <span class="comment">/* any free position is before this position */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">metatable</span>;</span></span><br><span class="line">  GCObject *gclist;</span><br><span class="line">&#125; Table;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从面向对象的角度分析的话，可以认为这5种内部基础类型，都继承自GCObject。<br>创建一个内部对象，使用同一个的接口函数<code>luaC_newobj (lua_State *L, int tt, size_t sz)</code> 参数说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** create a new collectable object (with given type and size) and link</span></span><br><span class="line"><span class="comment">** it to &#x27;allgc&#x27; list.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">GCObject *<span class="title function_">luaC_newobj</span> <span class="params">(lua_State *L, <span class="type">int</span> tt, <span class="type">size_t</span> sz)</span> &#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  GCObject *o = cast(GCObject *, luaM_newobject(L, novariant(tt), sz));</span><br><span class="line">  o-&gt;marked = luaC_white(g); <span class="comment">//标记这个对象是white</span></span><br><span class="line">  o-&gt;tt = tt;  <span class="comment">//类型</span></span><br><span class="line">  o-&gt;next = g-&gt;allgc; <span class="comment">//新创建的对象放到gclist的最前面</span></span><br><span class="line">  g-&gt;allgc = o;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> luaM_newobject(L,tag,s)	luaM_realloc_(L, NULL, tag, (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** generic allocation routine.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">luaM_realloc_</span> <span class="params">(lua_State *L, <span class="type">void</span> *block, <span class="type">size_t</span> osize, <span class="type">size_t</span> nsize)</span> &#123;</span><br><span class="line">  <span class="type">void</span> *newblock;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="type">size_t</span> realosize = (block) ? osize : <span class="number">0</span>; <span class="comment">//新建的话，block都是NULL</span></span><br><span class="line">  lua_assert((realosize == <span class="number">0</span>) == (block == <span class="literal">NULL</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(HARDMEMTESTS)</span></span><br><span class="line">  <span class="keyword">if</span> (nsize &gt; realosize &amp;&amp; g-&gt;gcrunning)</span><br><span class="line">    luaC_fullgc(L, <span class="number">1</span>);  <span class="comment">/* force a GC whenever possible */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  newblock = (*g-&gt;frealloc)(g-&gt;ud, block, osize, nsize);  <span class="comment">//调用的就是l_alloc</span></span><br><span class="line">  <span class="keyword">if</span> (newblock == <span class="literal">NULL</span> &amp;&amp; nsize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    lua_assert(nsize &gt; realosize);  <span class="comment">/* cannot fail when shrinking a block */</span></span><br><span class="line">    <span class="keyword">if</span> (g-&gt;version) &#123;  <span class="comment">/* is state fully built? */</span></span><br><span class="line">      luaC_fullgc(L, <span class="number">1</span>);  <span class="comment">/* try to free some memory... */</span></span><br><span class="line">      newblock = (*g-&gt;frealloc)(g-&gt;ud, block, osize, nsize);  <span class="comment">/* try again */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newblock == <span class="literal">NULL</span>)</span><br><span class="line">      luaD_throw(L, LUA_ERRMEM);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_assert((nsize == <span class="number">0</span>) == (newblock == <span class="literal">NULL</span>));</span><br><span class="line">  g-&gt;GCdebt = (g-&gt;GCdebt + nsize) - realosize;</span><br><span class="line">  <span class="keyword">return</span> newblock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="GCObjcet类型"><a href="#GCObjcet类型" class="headerlink" title="GCObjcet类型"></a>GCObjcet类型</h2><p>通过统一的接口luaC_newobj函数，创建的内部对象都是GCObjcet类型。如果要正常使用，还需要做一次转换，LUA对于这种抽象结构转换为具体对象结构的行为，封装了一套宏函数:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* macros to convert a GCObject into a specific value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gco2ts(o)  \</span></span><br><span class="line"><span class="meta">	check_exp(novariant((o)-&gt;tt) == LUA_TSTRING, &amp;((cast_u(o))-&gt;ts))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gco2u(o)  check_exp((o)-&gt;tt == LUA_TUSERDATA, &amp;((cast_u(o))-&gt;u))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gco2lcl(o)  check_exp((o)-&gt;tt == LUA_TLCL, &amp;((cast_u(o))-&gt;cl.l))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gco2ccl(o)  check_exp((o)-&gt;tt == LUA_TCCL, &amp;((cast_u(o))-&gt;cl.c))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gco2cl(o)  \</span></span><br><span class="line"><span class="meta">	check_exp(novariant((o)-&gt;tt) == LUA_TFUNCTION, &amp;((cast_u(o))-&gt;cl))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gco2t(o)  check_exp((o)-&gt;tt == LUA_TTABLE, &amp;((cast_u(o))-&gt;h))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gco2p(o)  check_exp((o)-&gt;tt == LUA_TPROTO, &amp;((cast_u(o))-&gt;p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> gco2th(o)  check_exp((o)-&gt;tt == LUA_TTHREAD, &amp;((cast_u(o))-&gt;th))</span></span><br></pre></td></tr></table></figure>

<img src="/images/gcobject.jpg" class="" title="gcobject">


<h1 id="推荐一本书-lt-自己动手实现lua虚拟机-gt"><a href="#推荐一本书-lt-自己动手实现lua虚拟机-gt" class="headerlink" title="推荐一本书&lt;自己动手实现lua虚拟机&gt;"></a>推荐一本书&lt;自己动手实现lua虚拟机&gt;</h1><p>lundump文件</p>
<h2 id="字节流结构-二进制-chunk"><a href="#字节流结构-二进制-chunk" class="headerlink" title="字节流结构 二进制 chunk"></a>字节流结构 二进制 chunk</h2><h3 id="头部header"><a href="#头部header" class="headerlink" title="头部header"></a>头部header</h3><p>{<br>    签名，          “\x1bLua”   (0x1b4c7561)<br>    版本，          0x53<br>    格式(0x00)      0x00<br>    LUAC_DATA       0x1993 0d 0a<br>    cint            4<br>    sizet           8<br>    lua虚拟机指令     4<br>    lua_integer     8<br>    lua_number      8<br>    lua_int  0x5678（判断大小端）<br>    lua_num  370.5  (浮点数格式)</p>
<p>}</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><ol>
<li>源文件名<br> 以@开头的是源码编译而来，以=开头的，是标准库而来</li>
<li>起止行号<br> 两个cint,主函数为0</li>
<li>固定参数个数</li>
<li>是否是Vararg函数</li>
<li>寄存器数量<br> MaxStackSize, 因为lua是一种栈结构,可以按索引访问，模拟寄存器</li>
<li>指令表</li>
<li>常量表</li>
<li>Upvalue表  {Instack,Idx}两个字节</li>
<li>子函数原型表</li>
<li>行号表. 和指令表中的指令一一对应</li>
<li>局部变量表<br>LocVar<br>{<pre><code>VarName  String
StartPC   Uint32
EndPC       Uint32
</code></pre>
}</li>
<li>Upvalue名列表</li>
</ol>
<blockquote>
<p>行号表、局部变量表、Upvalue名列表 都是调试信息</p>
</blockquote>
<h3 id="解析二进制-chunk"><a href="#解析二进制-chunk" class="headerlink" title="解析二进制 chunk"></a>解析二进制 chunk</h3><p>//头部header校验<br>lundump.h 里面看 checkHeader函数</p>
<p>//函数原型<br>LoadCode(S, f);<br>LoadConstants(S, f);<br>LoadUpvalues(S, f);<br>LoadProtos(S, f);<br>LoadDebug(S, f);</p>
<h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><p>lopcodes文件</p>
<ol>
<li>基于栈的虚拟机(Stack Based)<br> Java、.NET、CLR、Python、ruby、Yarv;<br> PUSH/POP操作栈，指令集大，平均长度短</li>
<li>基于寄存器(Resigter Based), lua_5.0以后<br> 需要把寄存器地址编码进指令，平均长度长</li>
</ol>
<p>lua采用定长指令集（大约47条指令）， 每条指令4字节32位，6位Opcode操作码，26位操作数Operand</p>
<h2 id="指令编码格式"><a href="#指令编码格式" class="headerlink" title="指令编码格式"></a>指令编码格式</h2><h3 id="编码模式"><a href="#编码模式" class="headerlink" title="编码模式"></a>编码模式</h3><p>按照高26位区分，四种mode， iABC、iABx、iAsBx、iAx<br>iABC可以携带ABC三个操作数8+9+9比特<br>iABx携带 A、Bx，8+18<br>iAx Ax，26<br>iAsBx As、Bx  8+18</p>
<h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>6位，最多64条指令，参看opcodes</p>
<h3 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h3><p>A主要用来表示目标寄存器索引，OpArgN、U、R、K</p>
<h3 id="指令表"><a href="#指令表" class="headerlink" title="指令表"></a>指令表</h3><p>LUAI_DDEF const lu_byte luaP_opmodes[NUM_OPCODES]</p>
<h3 id="指令解码"><a href="#指令解码" class="headerlink" title="指令解码"></a>指令解码</h3><p>CREATE_ABC、CREATE_ABx、CREATE_Ax<br>sBx是有符号整数，18位。 Excess-K编码模式，Offset Binary. x-K. K取最大无符号一半</p>
<h2 id="Lua-API"><a href="#Lua-API" class="headerlink" title="Lua API"></a>Lua API</h2><p>主要以Lua_开头的。60多个luaL_开头的辅助函数，付主函数建立在基础函数之上</p>
<h2 id="Lua栈"><a href="#Lua栈" class="headerlink" title="Lua栈"></a>Lua栈</h2><p>Lua栈是宿主语言和Lua语言沟通的桥梁，api基本上也都是操作这个所谓的栈结构lua_state</p>
<h3 id="Lua数据类型"><a href="#Lua数据类型" class="headerlink" title="Lua数据类型"></a>Lua数据类型</h3><p>8种， nil、boolean、number、string、table、function、thread、userdata</p>
<h2 id="虚拟机雏形-Lua运算符"><a href="#虚拟机雏形-Lua运算符" class="headerlink" title="虚拟机雏形 Lua运算符"></a>虚拟机雏形 Lua运算符</h2><p>程序计数器(Program Counter, 简称PC)记录正在执行的指令。</p>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>lua表是一个关联数组, 包含哈希表和数组两个部分</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>参数</p>
<ul>
<li>固定参数个数，未传递则nil，多传递则忽略</li>
<li>返回值，外部接受几个，多退少补nil的策略，作为函数参数，如数覆盖</li>
</ul>
<p>load,加载二进制chunk或者源码。把被调函数推入栈顶<br>call, </p>
<h2 id="交互-lua-lt-gt-其它语言"><a href="#交互-lua-lt-gt-其它语言" class="headerlink" title="交互 lua &lt;-&gt; 其它语言"></a>交互 lua &lt;-&gt; 其它语言</h2><p>lua注册表，lua_status里<br>lua全局环境 G， GlobalTable</p>
<h2 id="闭包和Upvalue"><a href="#闭包和Upvalue" class="headerlink" title="闭包和Upvalue"></a>闭包和Upvalue</h2><ol>
<li>一等函数，java不支持，可作为参数传递，返回等</li>
<li>变量作用域。 动态作用域、静态作用域</li>
<li>闭包。 词法作用域捕获了非局部变量的嵌套函数</li>
</ol>
<p>Upvalue是lua里面的术语，就是闭包内部捕获的非局部变量。<br>嵌套函数，捕获外围的外围的函数的变量，外围函数会捕获更外围的局部变量。扁平闭包。</p>
<p>_ENV — 全局环境 隐式的Upvalue</p>
<h2 id="元变成-Metaprogram"><a href="#元变成-Metaprogram" class="headerlink" title="元变成 Metaprogram"></a>元变成 Metaprogram</h2><p>值类型默认没有元表，元表nil。 字符串提供了默认元表。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器模式.<br>数值for循环是借助FORPREP和FORLOOP两条指令完成<br>通用for循环，TFORCALL和TFORLOOP两条指令</p>
<h2 id="异常和错误处理"><a href="#异常和错误处理" class="headerlink" title="异常和错误处理"></a>异常和错误处理</h2><h2 id="Lua语法和编译器"><a href="#Lua语法和编译器" class="headerlink" title="Lua语法和编译器"></a>Lua语法和编译器</h2><ul>
<li>词法分析</li>
<li>抽象语法树</li>
<li>语法分析</li>
<li>代码生成</li>
</ul>
<h2 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h2><p>字符流(源码)，以’token’的形式分解<br>类型注释、关键字、标识符、字面量、运算符、分隔符等<br>lua会忽略 \n \r \t \v \f 空格等空白字符<br>忽略注释</p>
<p>token -&gt; { … ; : . }  .etc</p>
<h2 id="抽象语法树-AST"><a href="#抽象语法树-AST" class="headerlink" title="抽象语法树 AST"></a>抽象语法树 AST</h2><p>计算机编程语言一般使用上下文无关文法(Context-free Grammar, CFG)描述，而CFG一般使用巴科斯范式(Backus-Naur Form, BNF)或者其扩展EBNF(Extended BNF)书写</p>
<h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>YACC、Bison、ANTLR、JavaCC</p>
<h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><h2 id="辅助API和基础库"><a href="#辅助API和基础库" class="headerlink" title="辅助API和基础库"></a>辅助API和基础库</h2>]]></content>
      <categories>
        <category>lua</category>
      </categories>
      <tags>
        <tag>lua源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/python/index.html</url>
    <content><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>Linux和Mac环境自带了Python 2.x版本，但是如果要更新到3.x的版本，可以在<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZy8=">Python的官方网站<i class="fa fa-external-link-alt"></i></span>下载安装</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol>
<li>单行注释 - 以#和空格开头的部分 </li>
<li>多行注释 - 三个引号开头，三个引号结尾</li>
</ol>
<h2 id="语言元素"><a href="#语言元素" class="headerlink" title="语言元素"></a>语言元素</h2><h3 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h3><ul>
<li>整型：Python中可以处理任意大小的整数<ul>
<li>（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如<code>0b100</code>，换算成十进制是4）、八进制（如<code>0o100</code>，换算成十进制是64）、十进制（<code>100</code>）和十六进制（<code>0x100</code>，换算成十进制是256）的表示法。</li>
</ul>
</li>
<li>浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如<code>123.456</code>）之外还支持科学计数法（如<code>1.23456e2</code>）。</li>
<li>字符串型：字符串是以单引号或双引号括起来的任意文本，比如<code>&#39;hello&#39;</code>和<code>&quot;hello&quot;</code>,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。</li>
<li>布尔型：布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如<code>3 &lt; 5</code>会产生布尔值<code>True</code>，而<code>2 == 1</code>会产生布尔值<code>False</code>）。</li>
<li>复数型：形如<code>3+5j</code>，跟数学上的复数表示一样，唯一不同的是虚部的<code>i</code>换成了<code>j</code>。</li>
</ul>
<p>在对变量类型进行转换时可以使用Python的内置函数（准确的说下面列出的并不是真正意义上的函数，而是后面我们要讲到的创建对象的构造方法）。</p>
<ul>
<li><code>int()</code>：将一个数值或字符串转换成整数，可以指定进制。</li>
<li><code>float()</code>：将一个字符串转换成浮点数。</li>
<li><code>str()</code>：将指定的对象转换成字符串形式，可以指定编码。</li>
<li><code>chr()</code>：将整数转换成该编码对应的字符串（一个字符）。</li>
<li><code>ord()</code>：将字符串（一个字符）转换成对应的编码（整数）。</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><blockquote>
<p><strong>说明：</strong> 在实际开发中，如果搞不清楚运算符的优先级，可以使用括号来确保运算的执行顺序。</p>
</blockquote>
<h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;x = &#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">1</span>:</span><br><span class="line">    y = <span class="number">3</span> * x - <span class="number">5</span></span><br><span class="line"><span class="keyword">elif</span> x &gt;= -<span class="number">1</span>:</span><br><span class="line">    y = x + <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y = <span class="number">5</span> * x + <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;f(%.2f) = %.2f&#x27;</span> % (x, y))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&#x27;x = &#x27;</span>))</span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">1</span>:</span><br><span class="line">    y = <span class="number">3</span> * x - <span class="number">5</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> x &gt;= -<span class="number">1</span>:</span><br><span class="line">        y = x + <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y = <span class="number">5</span> * x + <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;f(%.2f) = %.2f&#x27;</span> % (x, y))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明：</strong> 大家可以自己感受一下这两种写法到底是哪一种更好。在之前我们提到的Python之禅中有这么一句话“Flat is better than nested.”，之所以提倡代码“扁平化”是因为嵌套结构的嵌套层次多了之后会严重的影响代码的可读性，所以能使用扁平化的结构时就不要使用嵌套。</p>
</blockquote>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h3><p>如果明确的知道循环执行的次数或者要对一个容器进行迭代（后面会讲到），那么我们推荐使用<code>for-in</code>循环。</p>
<ul>
<li><code>range(101)</code>可以产生一个0到100的整数序列。</li>
<li><code>range(1, 100)</code>可以产生一个1到99的整数序列。</li>
<li><code>range(1, 100, 2)</code>可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。</li>
</ul>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>如果要构造不知道具体循环次数的循环结构，我们推荐使用<code>while</code>循环。<code>while</code>循环通过一个能够产生或转换出<code>bool</code>值的表达式来控制循环，表达式的值为<code>True</code>循环继续，表达式的值为<code>False</code>循环结束。下面我们通过一个“猜数字”的小游戏（计算机出一个1~100之间的随机数，人输入自己猜的数字，计算机给出对应的提示信息，直到人猜出计算机出的数字）来看看如何使用<code>while</code>循环。</p>
<blockquote>
<p><strong>说明：</strong> <code>break</code>关键字来提前终止循环，需要注意的是<code>break</code>只能终止它所在的那个循环，这一点在使用嵌套的循环结构需要引起注意。除了<code>break</code>之外，还有另一个关键字是<code>continue</code>，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。</p>
</blockquote>
<h2 id="函数和模块的使用"><a href="#函数和模块的使用" class="headerlink" title="函数和模块的使用"></a>函数和模块的使用</h2><p>编程大师<em>Martin Fowler</em>先生曾经说过：“<strong>代码有很多种坏味道，重复是最坏的一种！</strong>”，要写出高质量的代码首先要解决的就是重复代码的问题。</p>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>在Python中可以使用<code>def</code>关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过<code>return</code>关键字来返回一个值，这相当于数学上说的函数的因变量。</p>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数是绝大多数编程语言中都支持的一个代码的“构建块”，但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JTg3JUJEJUU2JTk1JUIwJUU5JTg3JThEJUU4JUJEJUJE">函数的重载<i class="fa fa-external-link-alt"></i></span>，因为我们在定义一个函数的时候可以让它有多种不同的使用方式.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在参数名前面的*表示args是一个可变参数</span></span><br><span class="line"><span class="comment"># 即在调用add函数时可以传入0个或多个参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">*args</span>):</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> args:</span><br><span class="line">        total += val</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add())</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>))</span><br></pre></td></tr></table></figure>

<h3 id="用模块管理函数"><a href="#用模块管理函数" class="headerlink" title="用模块管理函数"></a>用模块管理函数</h3><p>需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“__main__”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __name__是Python中一个隐含的变量它代表了模块的名字</span></span><br><span class="line"><span class="comment"># 只有被Python解释器直接执行的模块的名字才是__main__</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;call foo()&#x27;</span>)</span><br><span class="line">    foo()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;call bar()&#x27;</span>)</span><br><span class="line">    bar()</span><br></pre></td></tr></table></figure>
<h2 id="字符串和常用数据结构"><a href="#字符串和常用数据结构" class="headerlink" title="字符串和常用数据结构"></a>字符串和常用数据结构</h2><ul>
<li>sorted函数返回列表排序后的拷贝不会修改传入的列表</li>
<li>函数的设计就应该像sorted函数一样尽可能不产生副作用</li>
<li>通过<code>yield</code>关键字将一个普通函数改造成生成器函数。</li>
</ul>
<h3 id="使用元组"><a href="#使用元组" class="headerlink" title="使用元组"></a>使用元组</h3><ol>
<li>元组中的元素是无法修改的</li>
<li>元组在创建时间和占用的空间上面都优于列表。</li>
</ol>
<h2 id="面向对象编程基础"><a href="#面向对象编程基础" class="headerlink" title="面向对象编程基础"></a>面向对象编程基础</h2><p>类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）</p>
<p>在Python中可以使用<code>class</code>关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># __init__是一个特殊方法用于在创建对象时进行初始化操作</span></span><br><span class="line">    <span class="comment"># 通过这个方法我们可以为学生对象绑定name和age两个属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">study</span>(<span class="params">self, course_name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s正在学习%s.&#x27;</span> % (self.name, course_name))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># PEP 8要求标识符的名字用全小写多个单词用下划线连接</span></span><br><span class="line">    <span class="comment"># 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">watch_movie</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.age &lt; <span class="number">18</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s只能观看《熊出没》.&#x27;</span> % self.name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s正在观看岛国爱情大电影.&#x27;</span> % self.name)</span><br></pre></td></tr></table></figure>

<h2 id="面向对象进阶"><a href="#面向对象进阶" class="headerlink" title="面向对象进阶"></a>面向对象进阶</h2><h3 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a>@property装饰器</h3><p>使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问器 - getter方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问器 - getter方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改器 - setter方法</span></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self, age</span>):</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self._age &lt;= <span class="number">16</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s正在玩飞行棋.&#x27;</span> % self._name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s正在玩斗地主.&#x27;</span> % self._name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    person = Person(<span class="string">&#x27;王大锤&#x27;</span>, <span class="number">12</span>)</span><br><span class="line">    person.play()</span><br><span class="line">    person.age = <span class="number">22</span></span><br><span class="line">    person.play()</span><br><span class="line">    <span class="comment"># person.name = &#x27;白元芳&#x27;  # AttributeError: can&#x27;t set attribute</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="slots-魔法"><a href="#slots-魔法" class="headerlink" title="__slots__魔法"></a>__slots__魔法</h3><p>通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。</p>
<ul>
<li><h1 id="限定Person对象只能绑定-name-age和-gender属性"><a href="#限定Person对象只能绑定-name-age和-gender属性" class="headerlink" title="限定Person对象只能绑定_name, _age和_gender属性"></a>限定Person对象只能绑定_name, _age和_gender属性</h1><ul>
<li>__slots__ = (‘_name’, ‘_age’, ‘_gender’)</li>
</ul>
</li>
</ul>
<h3 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">is_valid</span>(<span class="params">a, b, c</span>):</span><br><span class="line">       <span class="keyword">return</span> a + b &gt; c <span class="keyword">and</span> b + c &gt; a <span class="keyword">and</span> a + c &gt; b</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">now</span>(<span class="params">cls</span>):</span><br><span class="line">       ctime = localtime(time())</span><br><span class="line">       <span class="keyword">return</span> cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)</span><br></pre></td></tr></table></figure>

<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。</p>
<h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>dyld和启动流程</title>
    <url>/os/dyld.html</url>
    <content><![CDATA[<h1 id="先看一个断点"><a href="#先看一个断点" class="headerlink" title="先看一个断点"></a>先看一个断点</h1><img src="/images/iOS/dyld_mainluanch.png" class="" title="启动流程">

<h1 id="App-Launch-以及-dyld"><a href="#App-Launch-以及-dyld" class="headerlink" title="App Launch 以及 dyld"></a>App Launch 以及 dyld</h1><p>自行下载参考dyld源码，下面只是我的简要记录</p>
<p>dyldbootstrap::start<br>{<br>rebaseDyld 符号便宜aslr address layout random<br>__guard_setup 栈溢出保护<br>dyld::_main<br>}</p>
<p>rebaseDyld {<br>    遍历所有固定的 chains 然后 rebase dyld<br>    所有基于修正链的映像的基地址为零，因此slide == 加载地址</p>
<pre><code>  // now that rebasing done, initialize mach/syscall layer
mach_init(); // from libc.a
</code></pre>
<p>}</p>
<h2 id="重点分析的方法"><a href="#重点分析的方法" class="headerlink" title="重点分析的方法"></a>重点分析的方法</h2><blockquote>
<p>dyld::_main分析</p>
</blockquote>
<ol>
<li><p>初始化程序运行环境</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//获取主程序的macho_header结构以及主程序的slide偏移值</span></span><br><span class="line">sMainExecutableMachHeader = mainExecutableMH;</span><br><span class="line">sMainExecutableSlide = mainExecutableSlide;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取主程序路径</span></span><br><span class="line"><span class="comment">// Pickup the pointer to the exec path.</span></span><br><span class="line">sExecPath = _simple_getenv(apple, <span class="string">&quot;executable_path&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (!sExecPath) sExecPath = apple[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> ( sExecPath[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span> ) &#123;</span><br><span class="line">    <span class="comment">// have relative path, use cwd to make absolute</span></span><br><span class="line">   ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取进程名称</span></span><br><span class="line"><span class="comment">// Remember short name of process for later logging</span></span><br><span class="line">sExecShortName = ::<span class="built_in">strrchr</span>(sExecPath, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> ( sExecShortName != <span class="literal">NULL</span> )</span><br><span class="line">    ++sExecShortName;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    sExecShortName = sExecPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置进程受限模式</span></span><br><span class="line">configureProcessRestrictions(mainExecutableMH, envp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测环境变量</span></span><br><span class="line">checkEnvironmentVariables(envp);</span><br><span class="line">defaultUninitializedFallbackPaths(envp);</span><br><span class="line"></span><br><span class="line">`所谓的启动优化就是在这里，添加dyly参数，进行打印的`</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否设置了sEnv.DYLD_PRINT_OPTS以及sEnv.DYLD_PRINT_ENV，分别打印argv参数和envp环境变量</span></span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_OPTS )</span><br><span class="line">    printOptions(argv);</span><br><span class="line"><span class="keyword">if</span> ( sEnv.DYLD_PRINT_ENV ) </span><br><span class="line">    printEnvironmentVariables(envp);</span><br><span class="line"><span class="comment">//获取当前程序架构</span></span><br><span class="line">getHostInfo(mainExecutableMH, mainExecutableSlide);</span><br></pre></td></tr></table></figure></li>
<li><p>加载共享缓存 shared cache<br> mapSharedCache();</p>
</li>
<li><p>实例化主程序，并赋值给ImageLoader::LinkContext</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">try &#123;</span><br><span class="line">    <span class="comment">// add dyld itself to UUID list</span></span><br><span class="line">    addDyldImageToUUIDList();</span><br><span class="line">    sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">    gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line">    gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>加载插入的动态库++++++++++++++++++++</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// load any inserted libraries</span></span><br><span class="line"><span class="keyword">if</span>  ( sEnv.DYLD_INSERT_LIBRARIES != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span>* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != <span class="literal">NULL</span>; ++lib) </span><br><span class="line">        loadInsertedDylib(*lib);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>链接主程序++++++++++++++</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">link</span>(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, <span class="literal">true</span>, ImageLoader<span class="type">::RPathChain</span>(<span class="built_in">NULL</span>, <span class="built_in">NULL</span>), <span class="number">-1</span>);</span><br><span class="line">sMainExecutable-&gt;setNeverUnloadRecursive();</span><br></pre></td></tr></table></figure></li>
<li><p>链接插入的动态库++++++++</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">ImageLoader::apply<span class="constructor">InterposingToDyldCache(<span class="params">gLinkContext</span>)</span>;</span><br><span class="line"> <span class="comment">// Bind and notify for the inserted images now interposing has been registered</span></span><br><span class="line"><span class="keyword">if</span> ( sInsertedDylibCount &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">    <span class="keyword">for</span>(unsigned <span class="built_in">int</span> i=<span class="number">0</span>; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">        ImageLoader* image = sAllImages<span class="literal">[<span class="identifier">i</span>+<span class="number">1</span>]</span>;</span><br><span class="line">        image-&gt;recursive<span class="constructor">Bind(<span class="params">gLinkContext</span>, <span class="params">sEnv</span>.DYLD_BIND_AT_LAUNCH, <span class="params">true</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在链接所有插入的image后，执行弱绑定++++++++++++++++++++++++++++++</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked</span></span><br><span class="line">sMainExecutable-&gt;weak<span class="constructor">Bind(<span class="params">gLinkContext</span>)</span>;</span><br><span class="line">gLinkContext.linkingMainExecutable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">sMainExecutable-&gt;recursive<span class="constructor">MakeDataReadOnly(<span class="params">gLinkContext</span>)</span>;   </span><br></pre></td></tr></table></figure></li>
<li><p>执行所有的初始化方法+++++++++++++++++++++</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// run all initializers</span></span><br><span class="line"><span class="built_in">initializeMainExecutable</span>(); </span><br></pre></td></tr></table></figure></li>
<li><p>查找主程序的入口点并返回</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// find entry point for main executable</span></span><br><span class="line">    result = (<span class="built_in">uint</span>ptr_t)sMainExecutable-&gt;getEntryFromLC_MAIN(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="总结dyld-main主要做了以下操作-就不一一分析了-："><a href="#总结dyld-main主要做了以下操作-就不一一分析了-：" class="headerlink" title="总结dyld::_main主要做了以下操作(就不一一分析了)："></a>总结dyld::_main主要做了以下操作(就不一一分析了)：</h2><p>主程序运行环境初始化及配置，拿到Mach-O头文件 (macho_header里面包含整个Mach-O文件信息其中包括所有链入的动态库信息)<br>加载共享缓存 shared cache<br>实例化主程序，并赋值给ImageLoader::LinkContext<br>加载所有插入的动态库，将可执行文件以及相应的依赖库与插入库加载进内存生成对应的ImageLoader类的image(镜像文件)对象<br>链接主程序（必须先链接主程序后才能插入）<br>链接所有的动态库ImageLoader的image(镜像文件)对象，并注册插入的信息，方便后续进行绑定<br>在链接完所有插入的动态库镜像文件之后执行弱绑定<br>执行所有动态库image的初始化方法initializeMainExecutable<br>查找主程序的入口点LC_MAIN并返回result结果，结束整个_dyld_start流程，进入我们App的main()函数！</p>
<h2 id="这里解释一下共享缓存机制：网上自己查询-dyld1-0版本-dyld3-版本，-当前使用dyld3版本"><a href="#这里解释一下共享缓存机制：网上自己查询-dyld1-0版本-dyld3-版本，-当前使用dyld3版本" class="headerlink" title="这里解释一下共享缓存机制：网上自己查询  dyld1.0版本 - dyld3 版本， 当前使用dyld3版本"></a>这里解释一下共享缓存机制：网上自己查询  dyld1.0版本 - dyld3 版本， 当前使用dyld3版本</h2><blockquote>
<p>dyld加载时，为了优化程序启动，在dyld::_main中启用了共享缓存（shared cache）技术。共享缓存会在进程启动时被dyld映射到内存中，之后，当任何Mach-O映像加载时，dyld首先会检查该Mach-O映像与所需的动态库是否在共享缓存中，如果存在，则直接将它在共享内存中的内存地址映射到进程的内存地址空间。在程序依赖的系统动态库很多的情况下，这种做法对程序启动性能会有明显提升。</p>
</blockquote>
<h2 id="分析一下-main的第8步，initializeMainExecutable-倒数第二步"><a href="#分析一下-main的第8步，initializeMainExecutable-倒数第二步" class="headerlink" title="分析一下_main的第8步，initializeMainExecutable()  倒数第二步"></a>分析一下_main的第8步，initializeMainExecutable()  倒数第二步</h2><p>自行根据下面的方法阅读源码<br><code>initializeMainExecutable -&gt; runInitializers -&gt; processInitializers -&gt; recursiveInitialization -&gt; notifySingle</code></p>
<p>最后我想说的就是这个notifySingle，</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">context.notify<span class="constructor">Single(<span class="params">dyld_image_state_dependents_initialized</span>, <span class="params">this</span>, &amp;<span class="params">timingInfo</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>找到一个关键的函数指针* sNotifyObjCInit,  全局搜索找到赋值  </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void register<span class="constructor">ObjCNotifiers(<span class="params">_dyld_objc_notify_mapped</span> <span class="params">mapped</span>, <span class="params">_dyld_objc_notify_init</span> <span class="params">init</span>, <span class="params">_dyld_objc_notify_unmapped</span> <span class="params">unmapped</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// record functions to call</span></span><br><span class="line">    sNotifyObjCMapped   = mapped;</span><br><span class="line">    sNotifyObjCInit     = init;</span><br><span class="line">    sNotifyObjCUnmapped = unmapped;<span class="operator"></span></span><br><span class="line"><span class="operator"></span></span><br><span class="line"><span class="operator">    ...</span></span><br><span class="line"><span class="operator"></span>&#125;</span><br></pre></td></tr></table></figure>

<p>全局搜索，看看registerObjCNotifiers这个方法会被谁调用，找到调用的地方_dyld_objc_notify_register函数</p>
<blockquote>
<p>不用找了，在objc的源码里面， <code>_dyld_objc_notify_register</code> 是 <code>_objc_init</code>进行调用的。而_objc_init函数则是Runtime的入口函数！</p>
</blockquote>
<p>打开Objc源码,搜索_objc_init</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/<span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> <span class="emphasis">_objc_</span>init</span></span><br><span class="line"><span class="strong"><span class="emphasis">* Bootstrap initialization. Registers our image notifier with dyld.</span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="strong">**</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>/</span><br><span class="line"></span><br><span class="line">void <span class="emphasis">_objc_</span>init(void)</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    static bool initialized = false;</span></span><br><span class="line"><span class="code">    if (initialized) return;</span></span><br><span class="line"><span class="code">    initialized = true;</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    // fixme defer initialization until an objc-using image is found?</span></span><br><span class="line"><span class="code">    environ_init();</span></span><br><span class="line"><span class="code">    tls_init();</span></span><br><span class="line"><span class="code">    static_init();</span></span><br><span class="line"><span class="code">    lock_init();</span></span><br><span class="line"><span class="code">    exception_init();</span></span><br><span class="line"><span class="code">    </span></span><br><span class="line"><span class="code">    //注册回调函数</span></span><br><span class="line"><span class="code">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>

<p>看 <code>_dyld_objc_notify_register</code> 注释</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld. </span></span><br><span class="line"><span class="comment">* //引导程序初始化。 用dyld注册我们的image通知程序。</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">* //在库初始化之前由libSystem调用!!!!!</span></span><br><span class="line"><span class="comment">* </span></span><br></pre></td></tr></table></figure>

<p>_objc_init的调用时机是在其他动态库加载之前由libSystem系统库先调用的。</p>
<p>那么到现在就很明确了，其实在dyld::_main主程序的第8步，初始化所有动态库及主程序的时候之前，就先注册了load_images的回调，之后在Runtime调用load_images加载完所有load方法之后，就会回调到dyld::_main的initializeMainExecutable()内部执行回调。</p>
<h1 id="map-images"><a href="#map-images" class="headerlink" title="map_images"></a>map_images</h1><p>自行下载objc源码, 找打 <code>_objc_init</code> 方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _objc_init</span></span><br><span class="line"><span class="comment">* Bootstrap initialization. Registers our image notifier with dyld.</span></span><br><span class="line"><span class="comment">* Called by libSystem BEFORE library initialization time</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _objc_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//读取影响运行时的环境变量。</span></span><br><span class="line">    environ_init();</span><br><span class="line">    </span><br><span class="line">    tls_init();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//运行C ++静态构造函数。libc在dyld调用我们的静态构造函数之前调用_objc_init()</span></span><br><span class="line">    static_init();</span><br><span class="line">    </span><br><span class="line">    lock_init();</span><br><span class="line">    <span class="comment">//初始化libobjc的异常处理系统。由map_images()调用。</span></span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    注册回调函数</span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="map-images直接返回了map-images-nolock-直接看实现"><a href="#map-images直接返回了map-images-nolock-直接看实现" class="headerlink" title="map_images直接返回了map_images_nolock,直接看实现"></a>map_images直接返回了map_images_nolock,直接看实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">map_images_nolock</span><span class="params">(<span class="type">unsigned</span> mhCount, <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> mhPaths[],</span></span><br><span class="line"><span class="params">                  <span class="type">const</span> <span class="keyword">struct</span> mach_header * <span class="type">const</span> mhdrs[])</span></span><br><span class="line">&#123;</span><br><span class="line">    定义一系列变量</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    必要时执行首次初始化</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果是第一次，就准备初始化环境</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        preopt_init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find all images with Objective-C metadata.</span></span><br><span class="line">    hCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    计算<span class="class"><span class="keyword">class</span>数量，根据总数调整各种表的大小。</span></span><br><span class="line"><span class="class">    // <span class="title">Count</span> <span class="title">classes</span>. <span class="title">Size</span> <span class="title">various</span> <span class="title">table</span> <span class="title">based</span> <span class="title">on</span> <span class="title">the</span> <span class="title">total</span>.</span></span><br><span class="line"><span class="class">    <span class="title">int</span> <span class="title">totalClasses</span> =</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> unoptimizedTotalClasses = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    执行一次运行时初始化，必须将其推迟到找到可执行文件本身为止。 这需要在进一步初始化之前完成。（如果可执行文件不包含Objective-C代码，但稍后会动态加载Objective-C，则该可执行文件可能不会出现在此infoList中。</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//初始化sel方法表 并注册系统内部专门的方法。</span></span><br><span class="line">        sel_init(selrefCount);</span><br><span class="line">        arr_init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    直接开始image读取</span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    firstTime = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结map_images_nolock的流程就是:</p>
<ul>
<li>判断firstTime，firstTime为YES，则执行环境初始化的准备，为NO就不执行</li>
<li>计算class数量，根据总数调整各种表的大小并做了GC相关逻辑处理(不支持GC则打印提示信息)</li>
<li>判断firstTime，firstTime为YES，执行各种表初始化操作，为NO则不执行</li>
<li>执行<code>_read_images</code>进行读取，然后将firstTime置为NO，就不再进入上面的逻辑了，下次进入map_images_nolock就开始直接_read_images</li>
</ul>
<h2 id="接下来我们重点分析-read-images"><a href="#接下来我们重点分析-read-images" class="headerlink" title="接下来我们重点分析_read_images"></a>接下来我们重点分析<code>_read_images</code></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* _read_images</span></span><br><span class="line"><span class="comment">* Perform initial processing of the headers in the linked </span></span><br><span class="line"><span class="comment">* list beginning with headerList. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Called by: map_images_nolock</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: runtimeLock acquired by map_images</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="type">void</span> _read_images(header_info **hList, <span class="type">uint32_t</span> hCount, <span class="type">int</span> totalClasses, <span class="type">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    定义一系列局部变量</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="number">1.</span> 重新初始化TaggedPointer环境****************</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">        doneOnce = YES;</span><br><span class="line"></span><br><span class="line">         ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DisableTaggedPointers) &#123;</span><br><span class="line">            disableTaggedPointers();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        initializeTaggedPointerObfuscator();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        注意！！！！！创建表 gdb_objc_realized_classes 和 allocatedClasses</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> namedClassesSize = </span><br><span class="line">            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">        gdb_objc_realized_classes =</span><br><span class="line">            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line">        </span><br><span class="line">        allocatedClasses = NXCreateHashTable(NXPtrPrototype, <span class="number">0</span>, nil);</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Discover classes. Fix up unresolved future classes. Mark bundle classes.</span></span><br><span class="line">    </span><br><span class="line">    <span class="number">2.</span> 开始遍历头文件，进行类与元类的读取操作并标记(旧类改动后会生成新的类，并重映射到新的类上)************************</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="comment">//从头文件中拿到类的信息</span></span><br><span class="line">        <span class="type">classref_t</span> *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (! mustReadClasses(hi)) &#123;</span><br><span class="line">            <span class="comment">// Image is sufficiently optimized that we need not call readClass()</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> headerIsBundle = hi-&gt;isBundle();</span><br><span class="line">        <span class="type">bool</span> headerIsPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            Class cls = (Class)classlist[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//!!!!!!核心操作，readClass读取类的信息及类的更新</span></span><br><span class="line">            Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line">            </span><br><span class="line">            ......</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="number">3.</span> 读取@selector*************************************</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fix up @selector references</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> UnfixedSelectors;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">mutex_locker_t</span> <span class="title function_">lock</span><span class="params">(selLock)</span>;</span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hi-&gt;isPreoptimized()) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line">            SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">            UnfixedSelectors += count;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">char</span> *name = sel_cname(sels[i]);</span><br><span class="line">                sels[i] = sel_registerNameNoLock(name, isBundle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="number">4.</span> 读取协议protocol*************************************</span><br><span class="line">    <span class="comment">// Discover protocols. Fix up protocol refs.</span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">        Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">        assert(cls);</span><br><span class="line">        NXMapTable *protocol_map = protocols();</span><br><span class="line">        <span class="type">bool</span> isPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line">        <span class="type">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line"></span><br><span class="line">        <span class="type">protocol_t</span> **protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                         isPreoptimized, isBundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="number">5.</span> 处理分类category，并rebuild重建这个类的方法列表method <span class="built_in">list</span>*******************************</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Discover categories. </span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="type">category_t</span> **catlist = </span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        <span class="type">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="type">category_t</span> *cat = catlist[i];</span><br><span class="line">            Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">            </span><br><span class="line">            ......</span><br><span class="line">            </span><br><span class="line">            <span class="type">bool</span> classExists = NO;</span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">                ||  cat-&gt;instanceProperties) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: found category -%s(%s) %s&quot;</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                                 classExists ? <span class="string">&quot;on existing class&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">                ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">                <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;ISA());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: found category +%s(%s)&quot;</span>, </span><br><span class="line">                                 cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DebugNonFragileIvars) &#123;</span><br><span class="line">        realizeAllClasses();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    最后是一堆打印***********</span><br><span class="line">    ......</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>_read_images的实现主要分为以下步骤：</p>
<ol>
<li>重新初始化TaggedPointer环境</li>
<li>开始遍历头文件，进行类与元类的读取操作并标记(旧类改动后会生成新的类，并重映射到新的类上)</li>
<li>读取@selector方法</li>
<li>读取协议protocol</li>
<li>处理分类category，并rebuild重建这个类的方法列表method list</li>
</ol>
<p>两个表，一个叫<code>gdb_objc_realized_classes</code>用来存放已命名的类的列表，另一个叫<code>allocatedClasses</code>用来存放已分配的所有类(和元类)</p>
<h2 id="逐步分析-readClass、-selector、-protocol、-category"><a href="#逐步分析-readClass、-selector、-protocol、-category" class="headerlink" title="逐步分析 readClass、@selector、 protocol、 category"></a>逐步分析 readClass、@selector、 protocol、 category</h2><h3 id="从源码中可以看出，-readClass-方法有返回值，并且包含三种逻辑处理："><a href="#从源码中可以看出，-readClass-方法有返回值，并且包含三种逻辑处理：" class="headerlink" title="从源码中可以看出， readClass 方法有返回值，并且包含三种逻辑处理："></a>从源码中可以看出， readClass 方法有返回值，并且包含三种逻辑处理：</h3><ul>
<li>找不到该类的父类，可能是弱绑定，直接返回nil；</li>
<li>找到类了，判断这个类是否是一个future的类(可以理解为需要实现的一个类，也可以理解为这个类是否有变化)，如果有变化则创建新类，并把旧类的数据拷贝一份然后赋值给新类newCls，然后调用addRemappedClass进行重映射，用新的类替换掉旧的类，并返回新类newCls的地址</li>
<li>找到类了，如果类没有任何变化，则不进行任何操作，直接返回class</li>
</ul>
<p>从readClass的底层实现部分做个延伸思考：日常开发中，对于已经启动完成的工程项目，如果我们未修改任何类的数据，那么再次点击运行会很快完成，但是一旦我们在对这些类进行修改后，在读取这些类的信息(包括类本身的信息以及下面我们要继续分析的协议protocol、分类category、方法selector)，就需要对该类的数据进行更新，这个更新实际上是新建一个类，然后拷贝旧类的数据赋值给新类，然后重映射并用新类替换掉新类，这里面的拷贝以及读写过程其实是相当耗时的！这是类信息改动之后项目再次Run运行起来会比较慢的原因之一。</p>
<p>已经读取完成的类，会被存放到了这个表<code>gdb_objc_realized_classes</code>里面！</p>
<p>分析源码注释及源码得出，<code>addClassTableEntry</code>里面会把这个读取完成的类直接先添加到<code>allocatedClasses</code>表里面，然后再判断<code>addMeta</code>是否为YES，然后会把当前这个类的元类metaClass也添加到<code>allocatedClasses</code>这个表里面。</p>
<h3 id="selector"><a href="#selector" class="headerlink" title="@selector"></a>@selector</h3><p>点击sel_registerNameNoLock，找到__sel_registerName，在它里面找到关键代码<br>逻辑其实就是：把方法名插入并存储到namedSelectors这个表里面.</p>
<h3 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h3><p>找到关键函数readProtocol，进入发现其实读取protocol的操作是把protocol存进协议表protocol_map。</p>
<h3 id="category"><a href="#category" class="headerlink" title="category"></a>category</h3><p>分类category的读取，里面主要做了下面这些步骤：</p>
<ol>
<li>从头文件中获取所有的分类列表catlist，然后循环遍历这个列表</li>
<li>在循环中，判断当前分类cat所属的类是否存在，如果不存在则把这个分类置为空catlist[i] = nil; 如果这个分类所属的类存在，那么开始下面两个步骤：</li>
<li>第一个步骤：判断这个分类cat中是否有实例方法instanceMethods，协议protocols以及属性实例instanceProperties，如果有，那么进入remethodizeClass，重新rebuild当前类cls的方法列表</li>
<li>第二个步骤：继续判断这个分类cat中是否有类方法classMethods，协议protocols以及类属性_classProperties，然后重新rebuild当前类所对应元类cls-&gt;ISA()的方法列表。</li>
</ol>
<h1 id="loadimage"><a href="#loadimage" class="headerlink" title="loadimage"></a>loadimage</h1><p>调用load方法，父类-子类-所有分类</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>_objc_init 是系统库，很早就已经 由libSystem系统库先调用的，初始化了很多环境 其中有<code>_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</code></p>
<p>dyld 初始化进程环境，链接动态库，进行 _dyld_objc_notify_register 注册 </p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9lYTY4MDk0MWUwODQ=">https://www.jianshu.com/p/ea680941e084<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>os</category>
        <category>dyld</category>
      </categories>
      <tags>
        <tag>dyld</tag>
        <tag>启动流程</tag>
      </tags>
  </entry>
  <entry>
    <title>总结</title>
    <url>/sumup/sumupthepast.html</url>
    <content><![CDATA[<h1 id="回看过去，做了什么，能否沉淀些东西，简要记录"><a href="#回看过去，做了什么，能否沉淀些东西，简要记录" class="headerlink" title="回看过去，做了什么，能否沉淀些东西，简要记录"></a>回看过去，做了什么，能否沉淀些东西，简要记录</h1><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>详细的内容在另外一个组件化篇幅里记录</p>
<ol>
<li>组件化目的：</li>
</ol>
<ul>
<li>共享基础设施</li>
<li>下沉公共服务</li>
<li>隔离业务代码(模块儿)</li>
<li>二进制加速编译，带上dwarf符号信息，和源文件</li>
<li>开启modular，支持swift混编<ul>
<li>主要是解决头文件引用问题</li>
<li>需要采用’&lt;&gt;’尖括号形式，兼容modular和framework</li>
</ul>
</li>
</ul>
<ol start="2">
<li>X点</li>
</ol>
<ul>
<li>借鉴Beehive, 注解方式注册。 类似于java的框架spring的模式，</li>
<li>使用自定义goto字符串协议</li>
<li>统一管理cocoapods版本号，利用bundle工具管理版本号</li>
<li>由于podfile.lock和menifest.lock文件不一致问题，把pod文件加入版本控制</li>
</ul>
<h2 id="热更新方案"><a href="#热更新方案" class="headerlink" title="热更新方案"></a>热更新方案</h2><ol>
<li><p>方法中带block的, </p>
<ul>
<li>block在原神生成，在脚本中调用</li>
<li>block需要在脚本中生成，在原生调用</li>
</ul>
</li>
<li><p>hook方法，msgforwarding，</p>
</li>
<li><p>利用libffi调用原生C函数，</p>
</li>
<li><p>通过符号找函数地址，dlsym，或者fishhook的方案，利用segment_linkedit, lc_symta（字符表和符号表）b, lc_dysymtab(间接符号表，系统/第三方的导出符号)</p>
</li>
</ol>
<h2 id="CRASH-amp-amp-APM"><a href="#CRASH-amp-amp-APM" class="headerlink" title="CRASH &amp;&amp; APM"></a>CRASH &amp;&amp; APM</h2><ol>
<li>可捕获的<ul>
<li>C++、OC、数组越界、抛异常等软件异常</li>
<li>断言等</li>
</ul>
</li>
<li>不可捕获的，或者说是abort<ul>
<li>oom</li>
<li>anr</li>
<li>死锁</li>
<li>非法应用签名</li>
<li>后台超时</li>
<li>内存紧张</li>
<li>设备过热</li>
</ul>
</li>
<li>crash监控<ul>
<li>注册监听，CPPException，OCException、singal、machException</li>
</ul>
</li>
</ol>
<h2 id="聊天室业务"><a href="#聊天室业务" class="headerlink" title="聊天室业务"></a>聊天室业务</h2><ol>
<li>架构调整</li>
</ol>
<ul>
<li>mvp为主。 管理各种有戏模板，抽取模板抽象类，统一调度，抽取基类，反向调用</li>
<li>vchatBus。 聊天室事件总线，协议为key，实现为value，储存在单例中，统一分发</li>
<li>优先级队列。 通过堆实现</li>
</ul>
<ol start="2">
<li>业务模块儿</li>
</ol>
<ul>
<li>重构Timer，统一调度</li>
<li>实现优先级view，以此重构banner区，房间广播，礼物动效等队列管理</li>
<li>重构IM消息分发，RTC事件回调，基于vchatbus组件</li>
<li>整理视图层级，functionview，popbackgroudview. 管理各种不同层级的视图，和弹窗</li>
</ul>
<ol start="3">
<li>媒体报警日志及问题查询</li>
</ol>
<ul>
<li>媒体查询<ol>
<li>媒体中台</li>
<li>kibanna日志</li>
<li>IM日志捞取</li>
<li>接口回调</li>
<li>hubble警告</li>
</ol>
</li>
<li>crash等问题<ol>
<li>公司内部crash后台分析</li>
<li>MDLog的kibana日志</li>
<li>IM日志捞取</li>
<li>接口查询</li>
</ol>
</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>sdwebimage的问题， 老的下载还在排队，新的下载取消了所有的回调</li>
<li>init方法的问题arc下，过度release</li>
</ul>
<h2 id="书"><a href="#书" class="headerlink" title="书"></a>书</h2><ul>
<li>程序员的自我修养</li>
<li>多线程与内存管理</li>
<li>深入理解osx/ios操作系统</li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac、iOS操作系统</title>
    <url>/os/ios-macos.html</url>
    <content><![CDATA[<p>整体上还算不错，对内核，Mach和BSD的介绍，包括一些函数和调用等，以及对异常处理的描述，对于理解PLC这个崩溃日志生成的库还是很有帮助的。同时一些内核线程、用户线程的概念也算是填补部分知识空白。引导过程虽然讲的很详细，不过兴趣不大。</p>
<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>ASLR：Address Space Layout Randomization 地址空间布局随机化</p>
<p>XNU：X is Not UNIX</p>
<p>POSIX：Portable Operating System Interface 可移植操作系统接口</p>
<p>XPC：高级IPC框架，实现进程间特权的分离</p>
<p>ELF：Executable and Library Format ，Unix下的可执行文件格式</p>
<p>__LINKEDIT：由dyld使用，这个区包含了字符串表、符号表以及其他数据</p>
<p>pthread：就是BSD层实现的POSIX规范的线程，Mach层则是mach_thread</p>
<p>DFU：设备固件更新模式，这个模式用于更新iOS镜像</p>
<p>HFS：Hierarchical File System 层次文件系统</p>
<p>FAT：File Allocation Table 文件分配表</p>
<p>NFS：Network File System网络文件系统</p>
<p>VFS：Virtual File System虚拟文件系统</p>
<p>LR寄存器：保存了当前函数的返回地址</p>
<p>PC寄存器：指令指针，程序计数器，PC寄存器中的内容，是下一条要取来执行的指令的地址</p>
<p>ABI：Application Binary Interface 应用程序二进制接口</p>
<h1 id="第一部分-第一到三章-高级用户指南"><a href="#第一部分-第一到三章-高级用户指南" class="headerlink" title="第一部分 第一到三章 高级用户指南"></a>第一部分 第一到三章 高级用户指南</h1><p>1.iOS系统的GUI是springboard，这是大家熟知的触屏应用加载器。</p>
<p>2.Darwin是操作系统的类UNIX核心，本身由内核，XNU和运行时组成。</p>
<p>3.XNU实际上是由两种技术混合在一起的：Mach和BSD，此外还添加了一些其他的组件，主要是IOKit。</p>
<p>4.在Mac OS中，“bundle”这个词实际上描述的是两种不同的术语：第一种是本节中讨论的目录结构；第二种是共享库目标的一种文件目标格式，共享库由进程显示的加载（普通的库是隐式加载的）。这个词有时候也表示一个插件。</p>
<p>5.OS X是在Mach内核的基础上构建的，而Mach是NeXTSTEP的遗产。BSD层是对Mach内核的包装，但是Mach系统调用仍然可以在用户态访问。</p>
<p>6.内核XNU是Darwin的核心，也是整个OS X的核心。XNU本身由以下几个组件构成：Mach微内核，BSD层，libKern，IOKit。</p>
<p>7.Mach微内核仅能处理操作系统最基本的职责：进程和线程抽象，虚拟内存管理，任务调度，进程间通信和消息传递机制。</p>
<p>8.BSD层建立在Mach层之上，BSD层提供了更高层次的抽象，其中包括：UNIX进程模型，POSIX线程模型（Pthread）及其相关的同步原语，UNIX用户和组，网络协议栈（BSD Socket API），文件系统访问，设备访问（通过/dev目录访问）。</p>
<p>9.OS X提供了一个系统级的通知机制。这是分布式IPC的一种形式，进程可以通过这种机制广播或监听事件。通知机制的核心部分在于notifyd(8) 守护程序，这个守护程序是在系统引导时启动的，这是Darwin的通知服务器。还有一个守护程序 distnoetd(8) 的作用是分布式通知服务器。notify(8) 默认使用Mach消息并注册Mach端口 com.apple.system.notification_center，能够处理大部分通知。notify(8)还有一个有意思的特点，这个API允许通过Mach消息传递文件描述符。</p>
<p>10.苹果通过代码签名，沙盒以及entitlement授权文件来保证iOS和OS X的安全。</p>
<p>11.沙盒机制也有一个专用的守护程序usr/libexec/sandboxd，这个程序运行在用户态，提供了跟踪功能以及内核扩展所需要的辅助服务，这个守护程序是根据需要启动的。</p>
<h1 id="第四章-进程线程和Mach-O"><a href="#第四章-进程线程和Mach-O" class="headerlink" title="第四章 进程线程和Mach-O"></a>第四章 进程线程和Mach-O</h1><p>1.尽管同一个可执行程序可以并发的启动多个实例，但是每一个实例都有一个不同的PID。</p>
<p>2.子进程返回的整数由其父进程收集。进程将要返回的值传递给exit(2) 系统调用（或者从main()函数返回）。</p>
<p>3.一个进程内的所有线程都共享虚拟内存空间，文件描述符和各种句柄。</p>
<p>4.进程的生命周期开始于SIDL状态，在这个状态中，进程仍被定义为”正在初始化“，不会响应任何信号，也不会进行任何操作。</p>
<p>5.睡眠的进程也会被信号唤醒。通过一个特殊的信号（TSTOP或TOSTOP）可以使一个进程停止执行。这相当于”冻结“了进程（即同时挂起这个进程的所有线程），将这个进程置于”深度睡眠“的状态。恢复这个进程的唯一方法就是发送另一个信号（CONT），这个信号可以将进程切换回可运行状态，使得进程中的每一个线程都可以被重新调度了。</p>
<p>6.终止一个进程会同时终止其所有线程。但是在进程完成终止之前，会短暂的处于僵尸（zombie）状态。每一个进程在安息之前都会有很短暂的时间处于这个状态。僵尸进程都是绝对死亡的进程，僵尸进程只是进程的空壳，所有的资源都被释放了，但是仍然占用着PID。</p>
<p>7.pid_suspend”冰冻“一个进程，pid_resume”解冻“一个进程。冰冻背后的挂起操作是在更为底层的Mach任务的层次实现的，而不是进程的层次实现的，所以这个睡眠更深。iOS的springboard大量使用了这些调用，比如用户按下Home键时。</p>
<p>8.iOS还添加了一个私有的系统调用 pid_shutdown_sockets，这在OS X是没有的。这个系统调用可以在进程之外关闭这个进程所有的套接字。只有springboard使用了这个调用，多半是挂起进程时使用的。</p>
<p>9.信号指发送给程序的异步通知，其中不包括数据（或只包括非常少量的数据）。信号是操作系统发送给进程的，用于表示发生了某种条件，而这种条件通常是因为某类硬件错误或程序异常而产生的。除了SIGKILL之外，进程可以通过一些系统调用屏蔽或处理以下的所有错误。</p>
<p>10.通用二进制（胖二进制）格式只不过是其支持的各种架构的二进制文件的打包文件。也就是说，这种格式的文件包含一个非常简单的文件头，文件头后面依次拷贝了每一种支持架构的二进制文件。lipo这个工具可以提取、删除或替换通用二进制文件中制定架构的二进制代码，因此可以用于对通用二进制文件进行”瘦身“。这个工具还可以显示胖二进制文件头的详细信息。</p>
<p>11.调用一个二进制文件时，Mach加载器会首先解析胖二进制文件头，确定其中可用的架构，然后只加载最适合的架构的代码，因此不相关架构的代码不会占用任何内存。</p>
<p>12.Mach-O格式具有一个固定的文件头，文件头一开始是一个魔数值，加载器可以通过这个魔数值快速判断这个二进制文件用于32位还是64位，在魔数值之后跟着的是CPU类型及子类型字段。</p>
<p>13.在iOS中，没有暴露sysct接口，堆和栈都默认不可执行。</p>
<p>14.Mach-O文件头的主要功能在于加载命令load command。otool工具可用于分析Mach-O文件。</p>
<p>15.加载过程在内核的部分负责新进程的基本设置——分配虚拟内存，创建主线程，以及处理任何可能的代码签名/加密的工作。然而对于动态链接的可执行文件（大部分可执行文件都是动态链接的）来说，真正的库加载和符号解析的工作都是通过LC_LOAD_DYLINKER命令指定的动态链接器在用户态完成的。控制权会转交给链接器。</p>
<p>16._PAGEZERO段（空指针陷阱）、_TEXT段（程序代码）、_DATA段（程序数据）和_LINKEDIT（链接器使用的符号和其他表）段提供了LC_SEGMENT命令。段有时候也可以进一步分解为区（section）。</p>
<p>17.当所有的库都完成加载之后，dyld的工作也完成了，之后由LC_UNIXTHREAD命令负责启动二进制程序的主线程（因此主线程总是在可执行文件中，而不会在其他二进制文件中例如库文件）。</p>
<p>18.LC_THREAD用于核心转储文件，Mach-O核心转储文件实际上是一组LC_SEGMENT命令的集合，这些命令负责建立起进程的内存镜像。</p>
<p>19.LC_MAIN命令的作用是设置程序主线程的入口点地址和栈大小。</p>
<p>20.Mach-O二进制文件有一个重要特性就是可以进行数字签名。LC_CODE_SIGNATURE包含了Mach-O二进制文件的代码签名，如果这个签名和代码本身不匹配（或者在iOS上这条命令不存在），那么内核会立即给进程发送一个SIGKILL信号，将进程杀死，没有商量的余地。</p>
<p>21.dyld是一个用户态的进程，dyld不属于内核的一部分，而是作为一个开源的项目由苹果单独维护的。</p>
<p>22.可执行文件很少是独立的，除了极少数的一些静态链接的可执行文件，大部分可执行文件都是动态链接的。</p>
<p>23.内核加载器执行的设置工作包括根据段的描述初始化进程地址空间以及执行其他命令。然而，仅有非常少量的进程只需要内核加载器就可以完成加载，而OS X上几乎所有的程序都是动态链接的。也就是说，Mach-O镜像中有很多”空洞“——即对外部的库和符号的引用——这些空洞要在程序启动时填补。这项工作就需要由动态链接器来完成。这个过程有时候也称为符号绑定（binding）。</p>
<p>24.动态链接器是内核执行LC_DYLINKER 加载命令时启动的。通常情况下，使用的是 /usr/lib/dyld 作为动态链接器，不过这条加载命令可以指定任何程序作为参数。链接器接管刚创建的进程的控制权，因为内核将进程的入口点设置为链接器的入口点。链接器索要完成的工作，就是查找进程中所有的符号和库的依赖关系，然后解决这些关系。这个过程必须递归的完成，因为通常情况下库还会依赖于其他的库。</p>
<p>25.通过otool -L命令可以显示库的依赖关系。</p>
<p>26.LC_LOAD_DYLIB命令告诉链接器在哪里可以找到这些符号。链接器要加载每一个指定的库，并且搜寻匹配的符号。被链接的库有一个符号表，符号表将符号名称和地址关联起来。符号表在Mach-O目标文件中的地址可以通过LC_SYMTAB加载命令指定的symoff找到。</p>
<p>27.libSystem库是系统上所有二进制代码的绝对先决条件，不论是C、C++还是Objective-C的程序。这是因为这个库是对底层系统调用和内核服务的接口，如果没有这些接口就什么事也干不了。</p>
<p>28.共享库缓存指的是一些库经过预先链接，然后保存在磁盘上的一个文件中。iOS中大部分常用的库都被缓存了。这个概念有点类似安卓的prelink-map，在prelink-map中的库被提前链接到地址空间中的固定偏移处。</p>
<p>29.为了节省加载的时间，iOS的dyld采用了一个共享库链接缓存，苹果从iOS3.0开始将所有的基础库都移到了这个缓存中。</p>
<p>30.在OS X中，dyld共享库缓存保存在/private/var/db/dyld目录下。在iOS中，共享库缓存可以在/System/Library/Caches/com.apple.dyld 中找到。这个缓存是一个单独的文件，即dyld_shared_cache_armv7。共享库缓存都会增长到非常庞大，OS X包含整整200多个文件，而iOS包含500多个文件，大小约为200M。</p>
<p>问题：共享库缓存到底是一个文件还是多个文件的组合？如果APP使用的第三方的动态库，是APP启动的时候操作系统才去加载，还是手机开机后自动加载这个共享库缓存目录下的文件？</p>
<p>31.OS X的dyld支持两级名称空间。这个特性是10.1引入的，指的是符号名称还包含其所在库的信息。这种方法更具有优势，因为允许两个不同的库导出相同的符号——而这在其他UNIX中会产生链接错误。有时候又需要禁用这种行为，通过将DYLD_FORCE_FLAT_NAMESPACE 环境变量设置为非零的值即可禁用。</p>
<p>32.函数拦截是传统ld没有而dyld有的特性。DYLD_INTERPOSE宏定义允许一个库将其库函数实现替换为另一个函数的实现。——这也是追踪函数调用和修改函数实现的原理</p>
<img src="/images/system/dyld.png" class="" title="dyld">

<p>33.用户态的一个优点在于虚拟内存的隔离。进程独享一个私有的地址空间。</p>
<p>34.和所有标准的C语言程序一样，OS X中的可执行文件也有一个标准的入口点，默认名称为”main“。不过除了三个标准的参数——argc、argv和envp——之外，Mach-O程序还接受第四个参数：名为”apple“的char**。在Snow Leopard系统之前，”apple“参数只包含一个字符串——程序的完整路径，即启动这个程序所用的execve()系统调用传入的第一个参数。dyld在进程加载的过程中使用了这个参数。从Lion系统开始，”apple“参数被扩展为一个完整的向量，其中包括两个新加入的参数。</p>
<p>35.Cocoa应用程序的入口也是标准的C main()，不过常见做法是将main实现为NSApplicationMain()的包装，然后通过其进入Objective-C的编程模型。</p>
<p>36.重写内存最常用的方法是采用缓冲区溢出（即利用未经保护的内存复制操作越过栈上数组的边界），将函数的返回地址重写为自己的指针。不仅如此，黑客还有更具创意的技术，例如破坏pringtf()格式化字符串以及基于堆的缓冲区溢出等。</p>
<p>37.ASLR：进程每一次启动时，地址空间都会被简单的随机化——只是偏移，而不是搅乱。实现方法是通过内核将Mach-O的段平移某个随机系数。</p>
<p>38.在64位模式下，由于内存空间巨大，所以也就可以遵循其他操作系统采用的模型了，即将内核的地址空间映射到每一个进程的地址空间中。这是64位地址空间和传统的OS X模型的不同之处，传统的OS X内存模型中内核有自己的地址空间，但是新的地址空间允许更快速的用户态/内核态切换（共享CR3寄存器，CR3寄存器是包含了页表指针的控制寄存器）。</p>
<p>39.在内核层面，既没有用户堆也没有栈存在，所有的内存相关操作都要归约为页面。</p>
<p>40.尽管栈在传统上一直是用来保存自动变量的，但是在某些情况下，程序员也可以选择使用栈来动态分配内存，方法是使用鲜为人知的alloca()。如果发生了栈溢出，alloca()会返回NULL，进程会收到SIGSEGV信号。</p>
<p>41.iOS中VM压力释放机制依赖于Jetsam，Jetsam是一种类似于Linux的Out-Of-Memory killer的机制。</p>
<p>42.OS X有一个来自于Mach的独特之处在于，交换空间不是直接在内核层次管理的，而是由一个专用的用户进程dynamic_pager()处理所有的交换请求。这个进程在引导时由launchd通过一个属性列表文件cpm.apple.dynamic_pager.plist启动。</p>
<p>43.线程，作为最大化利用进程时间片的方法应运而生：通过使用多个线程，程序的执行可以分割为表面看上去并发执行的子任务。</p>
<p>44.进程中线程的抢占开销比多任务系统对进程抢占的开销要小。因此从这个角度看，大部分操作系统开始将调度策略从进程转换到线程是有意义的。</p>
<p>45.多处理器更是特别适合线程，因为多个处理器核心共享同样的cache和RAM——这为多线程之间的共享虚拟内存提供了基础。</p>
<p>46.GCD自己维护了一个底层的线程库实现，以支持并发和异步的执行模型，减轻开发者处理并发问题的负担，以及减少类似于死锁之类的潜在错误。GCD的另一个优势是能够自动的随着逻辑处理器的个数而扩展。 ——YYDispatchQueuePool可以根据设备的物理核心数量来创建对应的线程数量。</p>
<h1 id="第五章-进程跟踪和调试"><a href="#第五章-进程跟踪和调试" class="headerlink" title="第五章 进程跟踪和调试"></a>第五章 进程跟踪和调试</h1><p>1.OS X中的调试工具首先要介绍的就是 DTrace。DTrace是一个重要的调试平台，移植自Sun的Solaris。DTrace中的D指的是D语言，这是一门完整的跟踪语言，通过这个语言可以创建专用的跟踪器，或称为探测器。D语言脚本被编译后由内核执行。</p>
<p>2.iOS中根本就没有提供DTrace。Linux上的ptrace提供了完整的进程跟踪和调试能力，因此称为了Linux下strace，gdb的基础。</p>
<p>3.DTrace神器的调试功能来源于能在内核中执行探测器的能力。DTrace的用户态部分由/usr/lib/dtrace.dylib 负责，Instruments和脚本解释器/usr/sbin/dtrace都使用了这个库。这是编译D脚本的运行时系统。然而，对于大部分有用的脚本来说，实际的执行都在内核态。DTrace通过一个特殊的字符设备(/dev/device)和内核组件进行通信。</p>
<img src="/images/system/DTrace.png" class="" title="DTrace">

<p>4.sysctl机制在之前的章节中已经讨论过了，sysctl提供 一些显示进程统计数据的变量。sysctl获得进程ID列表的机制非常重要（事实上，ps和top指令都是通过这个机制获得进程列表的）。</p>
<p>5.除了DTrace和Instruments之外，在OS X中海油一些工具可以获得系统或进程状态的快照：system_profiler，sysdiagnose，allmemory，stackshot，stack_snapshot系统调用。</p>
<p>6.allmemory工具的作用是捕获用户进程的所有内存使用情况。运行时，这个工具遍历系统中的每一个进程，然后将其内存映射导出至/tmp/allmemoryfiles（可以通过-o指定其他文件）。获得了所有进程内存快照之后，allmemory会显示每一个进程的汇总统计数据，还会显示框架的内存使用。</p>
<p>7.stack_snapshot这个系统调用可以捕获指定进程中所有线程的状态。</p>
<p>8.sc_usage工具显示每一个进程的系统调用信息。fs_usage可以显示系统调用，但是显示的是与文件、套接字和目录相关的应用，这个工具可以显示系统范围内的跟踪（除非调用时提供了PID或命令参数）。</p>
<p>9.latency工具显示中断和调度的延迟值。这个工具展示落在阈值内的上下文切换和中断处理程序计数，这两个阈值分别可以通过-st和-it参数设置。</p>
<p>10.XNU包含一个称谓kdebug的内建内核跟踪设施。kdebug利用内核缓冲器来记录日志，而内核缓冲器的空间极为有限。</p>
<p>11.在UNIX中，崩溃和一个信号有关。崩溃的真正原因来自于内核，内核发现进程无法继续执行时，生成这个信号作为最后的补救办法。</p>
<p>12.当一个进程崩溃时，可以选择是否生成核心存储文件。iOS和OS X都没有选择创建巨大的核心转存文件，而是包含了一个CrashReporter，当进程异常终止时自动触发Crash Reporter，生成详细的崩溃日志。这个机制在进程消亡之前进行快速简单的分析，并且在崩溃日志中记录重要的内容。</p>
<p>13.有没有可能在一个应用程序崩溃时自动运行另一个应用程序？在iOS和OS X中，将异常端口绑定至BSD进程底层的Mach任务的机制则能实现这一点。</p>
<p>14.spindump和sample命令的采样方法都是类似的——挂起进程，记录栈跟踪（spindump使用之前描述的stack_snapshot系统调用），然后恢复进程。采样间隔通常大约为10毫秒，整个采样过程通常持续10秒，这两个值是可以配置的。</p>
<p>15.应用程序崩溃的主要原因就是缓冲区溢出（既包含栈也包含堆）和堆内存的破坏。</p>
<img src="/images/system/libcmalloc.png" class="" title="libcmalloc">

<p>16.libgmalloc.dylib这个库可以截获并调试内存分配，这个强大的库的工作原理是截获LibSystem中的分配函数。</p>
<p>17.任何读/写操作如果越过了缓冲区的尾部就会导致读写操作越过页边界，从而导致一个未处理的页错误，使得进程收到总线错误的信号（SIGBUS）而崩溃。</p>
<p>18.标准的UNIX命令ps可以显示进程列表。UNIX的top命令是一个获得当前系统运行状况的关键工具，在OS X和iOS上都可用，而且相比标准版本有所修改。这些修改都和底层的Mach架构有关，使得top既能显示UNIX的信息（来自XNU的BSD层），也能显示Mach的信息。</p>
<p>19.有时候需要查看某个进程在使用哪些文件，或某个文件正在被哪些进程使用。lsof()和fuser()这两个工具就分别能够实现以上两个功能。lsof()是对之前描述的fs_usage的补充，因为后者只能看到新打开文件的操作，而看不到已经打开的文件。lsof()能显示一个进程所有文件描述符（包括套接字）的映射。换句话说，fs_usage可以持续运行，lsof产生的是一个快照。</p>
<p>20.fuser()提供的是反向的映射——从文件到拥有这个文件的进程。这个工具的主要作用是诊断文件锁定或者“文件被占用”的问题。</p>
<p>21.尽管XNU在用户态提供了完整的POSIX API，展示了UNIX兼容的人格，但是底层的实现却主要依靠Mach的基本原语。</p>
<img src="/images/system/infocommand.jpg" class="" title="infocommand">


<p>22.随着苹果转向LLVM-gcc转换，还引入了LLDB作为GDB的替代品。LLDB的语法基本上和GDB类似，但是调试功能大有增强。</p>
<h1 id="第六章-引导过程-第七章-贯穿始终——launchd"><a href="#第六章-引导过程-第七章-贯穿始终——launchd" class="headerlink" title="第六章 引导过程 第七章 贯穿始终——launchd"></a>第六章 引导过程 第七章 贯穿始终——launchd</h1><p>1.固件（firmware）可以看作是一种软件，这种软件因为被写入了芯片，所以是“固化”的。固件代码本身可以保存在只读存储器（ROM）中，也可以保存在电可擦除只读存储器EEPROM中</p>
<p>2.BIOS是一个固定的程序，而且通常都是封闭的。EFI是一套接口。EFI更像是一个运行时环境，规范了一组应用程序编程接口，基于EFI的程序可以利用这些接口实现功能。</p>
<p>3.苹果的EFI实现的另一个重要特性是Boot Camp。Boot Camp是苹果双重引导的解决方案，这个解决方案再Mac硬件上运行非苹果的操作系统（主要是Windows）。</p>
<img src="/images/system/launchd.jpg" class="" title="launchd">


<p>4.一旦苹果关闭了某个iOS版本的时间窗口，将安全服务器配置为拒绝这个版本的签名时，就不可能降级固件了。</p>
<p>5.OS X和iOS中，用户环境始于launchd。launchd作为系统中的第一个用户态进程，负责直接或间接的启动系统中的其他进程。launchd仍然属于Darwin的范畴。</p>
<p>6.launchd是由内核直接启动的。负责加载BSD子系统的主内核线程创建一个线程来执行bdsinit_task。这个线程获得PID 1，并且临时命令为“init”，这是一项来源于BSD的遗产。bsdinit_task然后调用load_init_program()，这个函数调用execve()系统调用（在内核空间中执行）执行守护程序。</p>
<p>7.系统范围的launchd（PID 1）是不可能终止的。事实上，这个launchd是系统上唯一不朽的进程。当系统关闭的时候，launchd也是最后一个退出的进程。</p>
<p>8.launchd的核心职责是根据预定的安排或实际的需要加载其他应用程序或作业。launchd区分两种类型的后台作业：</p>
<p>①守护程序（daemon）和传统的UNIX概念一样，是后台服务，通常和用户没有交互。守护程序由系统自动启动，不考虑是否有用户登录进系统。</p>
<p>②代码程序（agent）是一类特殊的守护程序，只有在用户登录的时候才启动。和守护程序的不同之处在于，代理程序可以和用户交互，有的代理程序还有GUI。</p>
<p>③iOS不支持用户登录的概念，因此只有LaunchDaemon。</p>
<p>④守护程序和代理程序都是通过自己的属性列表文件（.plist）声明的。</p>
<p>9.launchd是用户态出现的第一个进程。当系统还在启动初期的时候，launchd是系统上唯一的进程（尽管这个状态很短暂）。这意味着系统启动和功能的方方面面都和launchd直接或间接相关。</p>
<p>10.launchd的第一个，也是主要的职责就是init守护程序的职责。init的职责是派生出各种各样的后台守护程序，设置好系统，然后转入后台，确保这些守护程序都活着。如果有程序死亡了，launchd要负责重新派生出新的守护程序。</p>
<p>11.传统意义上，init是用户态的第一个进程，从init fork出其他进程（转而可能fork出更多进程），init设置的资源限制会被所有后代继承。而launchd（新时代意义上的用户态第一个进程）还会设置Mach异常端口，内核内部通过异常端口处理异常情况并生成信号。</p>
<p>12.UNIX传统上包含两个守护程序——atd和crond——来定时作业，即在指定时间运行指定的命令。第一个守护程序atd负责一次运行的作业，第二个守护程序crond提供了重复执行作业的支持。</p>
<p>13.inetd/xinetd的用途是启动网络服务。这个守护程序的职责是绑定一些端口（UDP端口或TCP端口），当有连接请求到达的时候，根据需要启动相应的服务程序，并且将服务程序的输入输出描述符（stdin，stderr，stdout）连接到对应的套接字。</p>
<p>14.Mach的IPC服务依赖于“端口”的概念（有点类似TCP和UDP端口的概念），端口是通信的端点。</p>
<p>15.launchd还整合了iOS的Jetsam机制，Jetsam机制可以强制施行虚拟内存使用率的限制，这项特性在没有交换空间的iOS中特别重要。</p>
<p>16.ReportCrash守护程序是默认的崩溃处理程序，截获所有应用程序的崩溃。通过设置作业的Mach异常端口，在发生崩溃的时候自动运行。</p>
<p>17.iOS中amfid守护程序，可以阻止一切无签名无entitlement的代码在iOS中运行。</p>
<p>18.apsd（ApplePushService.framework）守护程序则是苹果推送服务的守护程序，以mobile用户运行。</p>
<p>19.atc守护程序则用于空中流量限制。crash_mover守护程序用于将崩溃日志移动到 /var/Mobile/Library/Logs 目录。</p>
<p>20.mobile_obliterator守护程序则用于远程擦除设备。</p>
<p>21.lockdownd就像是用户态的狱警，是所有越狱者的头号敌人。lockdownd由launchd启动，负责处理设备激活、备份、崩溃报告、设备同步以及其他服务。</p>
<p>22.OS X下的图形shell环境是Finder，iOS使用的择时SpringBoard。</p>
<p>23.和Finder不太一样，SpringBoard几乎全部靠自己完成所有的工作，在CoreServices目录下也只有少量几个可加载的bundle。</p>
<p>lockbundle提供了锁屏时的功能。NowPlayingArtLockScreen.lockbundle负责提供当音乐播放器正在运行且屏幕锁定的时候的锁屏画面，PictureFramePlugin负责显示用户照片库中的图片。iPhone还有一个名为VoiceMemosLockScreen的bundle，负责显示语音信息和未接电话指示器。</p>
<p>24.SpringBoard是一个多线程的应用程序，线程数远多于Finder。如果SpringBoard超过几分钟没有响应，那么看门狗会重启系统。</p>
<p>25.SpringBoard注册的端口中，最重要的是PurpleSystemEventPort，这个端口通过GSEvent消息的方式处理UI事件。SpringBoard中的主线程调用GSEventRun()，GSEventRun()是一个处理UI消息的CFRunloop。其他线程都类似的运行循环，处理SpringBoard中的其他Mach端口。</p>
<p>26.XPC是Lion和iOS5新引入的轻量级进程间通信原语。libxpc.dylib提供了各种各样的C语言层次的XPC原语。默认情况下XPC的消息是异步发送的，应答也是异步的，通过reply_sync函数可以阻塞知道收到应答消息。XPC是通过Mach消息机制实现的。</p>
<h1 id="第二部分-内核"><a href="#第二部分-内核" class="headerlink" title="第二部分 内核"></a>第二部分 内核</h1><ul>
<li>第八章 内核架构</li>
</ul>
<p>1.内核既是一个操作系统，也是一个调度器，还是一个仲裁器，内核同时也提供安全服务。</p>
<p>2.内核从架构上分为巨内核，微内核和混合内核。</p>
<p>3.巨内核采取的方式是将所有的内核功能——不论是基础功能还是高级功能——全部放在一个地址空间中。在这种架构的内核中，线程调度和内存管理，以及文件系统、安全管理、甚至设备驱动全都在一起。</p>
<p>所有的内核功能都实现在同一个地址空间中吗。为了进一步优化，巨内核不进将所有的工呢过都组织在同一个地址空间中们还将这个地址空间映射到每一个进程的内存中。</p>
<p>在巨内核架构中，从用户态到内核态的切换非常搞笑，基本上就是一次线程切换的开销。这是因为内核的你内存页面映射在所有进程的地址空间中，也就是说，除了硬件强制的内核态和用户态之间的隔离外，两者之间其实没有任何分别。所有的进程，不论所有者或功能，都包含一份内核内存的拷贝，就好像包含共享库的拷贝一样。此外，这些拷贝（同样类似于共享库）都映射到了同一组物理页面，而且是常驻内存的物理页面。</p>
<p>4.XNU的核心组件Mach是一个微内核系统。</p>
<p>一个微内核值包含最核心的内核功能，代码量也最精简。内黑只负责完成最最关键的部分——通常包括任务调度和内存管理，其他的功能都交给外部服务程序（通常是用户态）完成。</p>
<p>微内核有几个巨内核没有的有点：正确性，稳定性和健壮性，灵活性（移植）。</p>
<p>尽管微内核架构有着种种优势，但是却有一个致命的缺点——性能。微内核的消息传递在底层需要通过内存复制操作以及数次上下文的切换来实现，而这些操作对计算速度的影响都不小。</p>
<p>5.混合内核试图结合两种内核的好处。内核最核心部分支持底层服务，包括调度、进程间通信和虚拟内存，是自包含的，这一部分就像微内核一样。所有其他的服务都实现在这个核心之外，但是也在内核态中，而且和这个核心在同一个内存空间中。</p>
<p>这种内核不强制要求消息传递。其他组件可以调用这个“内部核心”的服务，但是这个“内部核心”不能调用外部的组件。</p>
<p>6.从技术上说，XNU是一个混合内核。Windows内核也被认为是一个混合型的内核，但是两者差别巨大。Windows更接近巨内核，所以死亡蓝屏概率高，而XNU更接近于微内核。</p>
<p>7.XNU的Mach最早是一个真正的微内核，现在Mach的原语仍然是围绕着消息传递的基础构建的。然而，消息通常是以指针的形式传递的，因此没有昂贵的复制操作。这是因为大部分服务现在都在同一个地址空间中执行（因为也会被归为巨内核）。类似的，建立在Mach之上的BSD层一直都是一个巨内核，而且这个子系统也在同一个地址空间中。</p>
<p>8.32位的OS X应用程序可以享用完整的没有内核预留的地址空间——内核有自己的地址空间。然而在64位的OS X中，苹果却顺从了，就像其他巨内核的系统一样，内核空间和用户空间是共享的。在iOS中也是如此。</p>
<p>9.内核是一个受信任的系统组件。内核的功能和应用程序的功能之间需要有一种严格的分离，否则应用程序的崩溃会使整个系统本科鬼。这种分离需要由硬件强制支持，因为基于软件的强制实施不但会产生很大的开销，也不可靠。区分内核态和用户态非常重要，因此这个功能是由硬件提供的。</p>
<p>10.用户态和内核态的切换有两种类型：</p>
<p>①自愿转换，比如系统调用；</p>
<p>②非自愿转换，当发生异常、中断或处理器陷阱的时候，代码的执行会被挂起，并且保留发生错误时候的完整状态。控制权被转交给预定义的内核态错误处理程序或中断服务程序。</p>
<p>11.一共有三种类型的异常：</p>
<p>①错误（fault）：指令遇到一个可以纠正的异常，并且处理器可以重新启动这条出现异常的指令。</p>
<p>②陷阱（trap）：类似于错误，但是错误处理完成后返回发生陷阱指令之后的那条指令。</p>
<p>③中止（abort）：不可重启指令。</p>
<p>12.BSD系统调用，可以通过current_task获得当前BSD进程的数据结构。</p>
<h1 id="第九章-内核引导和内核崩溃"><a href="#第九章-内核引导和内核崩溃" class="headerlink" title="第九章 内核引导和内核崩溃"></a>第九章 内核引导和内核崩溃</h1><p>1.苹果只开源了针对OS X编译的XNU版本，iOS的版本则是闭源的。</p>
<p>2.和Linux内核类似，Linux可以针对特定架构编译，Mach也能。</p>
<p>3.如果要在一堆源码文件中查找某个特定的函数名、变量名或其他符号，grep是一个不错的工具，grep可以接受任何正则表达式，并且在.h和.c文件中寻找匹配。</p>
<p>4.vstart是i386/x64架构下的“官方”的内核初始化函数，标志着从汇编代码到C语言代码的转换。</p>
<p>5.除了虚拟内存之外，kernel_bootstrap还初始化Mach的一些关键抽象：</p>
<p>IPC——进程间通信是Mach构建的根基，IPC要求一些重要的资源，例如内存、同步对象和Mach接口生成器；</p>
<p>时钟clock——通过时钟抽象实现闹铃；</p>
<p>账本——账本是Mach系统的记账工具；</p>
<p>任务task——任务是Mach的容器，类似BSD的进程；</p>
<p>线程thread——线程是实际的执行单元。任务只不过是一个资源容器，真正被调度和执行的是线程。</p>
<p>6.关于异常处理</p>
<img src="/images/system/exception.png" class="" title="异常处理">


<h1 id="第十章-Mach原语：一切以消息为媒介"><a href="#第十章-Mach原语：一切以消息为媒介" class="headerlink" title="第十章 Mach原语：一切以消息为媒介"></a>第十章 Mach原语：一切以消息为媒介</h1><p>1.XNU的核心是苹果从NeXTSTEP带来的Mach微内核。尽管Mach核心被BSD层包装起来了，而且主要的内核接口是标准的POSIX系统调用，但是这个Mach核心具有一组独特的API和原语。</p>
<p>消息传递原语：讨论消息和端口，这是Mach IPC的基础。</p>
<p>同步原语：锁和信号量是两种内核对象，这些对象用于确保并发执行的安全。</p>
<p>2.Mach采用的是极简主义的概念。Mach和其他操作系统不同，其他操作系统提供了用户态进程实现所基于的完整模型，而Mach只提供了一个极简的模型，操作系统本身可以在这个模型的基础上实现。</p>
<p>在Mach中，所有的东西都是通过自己的对象实现的。进程（在Mach中称为任务）、线程和虚拟内存都是对象，所有对象都有自己的属性。</p>
<p>Mach的独特之处在于选择了通过消息传递的方式实现对象和对象之间的通信。Mach对象不能直接调用另一个对象，而是必须传递消息。源对象发送一条消息，然后这条消息被加入到目标对象的队列中等待处理。类似的，消息处理中可能会产生一个应答，这个应答通过另一条消息被发送回源对象。消息是以FIFO的方式可靠传输的（如果消息被发送出去，那么一定能被收到）。</p>
<p>3.Mach的首要设计目标也是最重要的目标就是要将所有功能移出内核，并且放在用户态中，将内核保持在极简的状态。</p>
<p>4.Mach的设计有一个非常强大的优点——在设计中考虑了多处理。从理论上说，Mach可以轻松扩展成计算机集群使用的操作系统。</p>
<p>5.Mach中最基本的概念是消息，消息在两个端点或端口之间传递。任何两个端口之间都可以传递消息——不论是同一台机器上的端口还是远程主机的端口。Mach消息的设计考虑了参数串行化、对齐、填充和字节顺序的问题，这些问题都被消息实现隐藏了。</p>
<p>6.Mach消息的发送和接收都是通过同一个API函数mach_msg()进行的，这个函数在用户态和内核态都有实现。</p>
<p>7.Mach消息原本是为真正的微内核架构而设计的，也就是说，mach_msg()函数必须在发送者和接受者之间复制消息所在的内存。但是XNU通过单一内核的方式来“作弊”：所有的内核组件都共享同一个地址空间，因此消息传递时只需要传递消息的指针就可以了，从而省去了昂贵的内存复制操作。</p>
<p>8.为了实现消息的发送和接收，mach_msg()函数调用了一个Mach陷阱（trap）。Mach陷阱就是Mach中跟系统调用等同的概念，在用户态调用mach_msg_trap()会引发陷阱机制，切换到内核态，在内核态中，内核实现的mach_msg()会完成实际的工作。</p>
<p>9.消息在端口之间传递。消息从某个端口发送到另一个端口。每个端口都可以接收来自任意发送者的消息，但是只能有一个指定接收者。向一个端口发送消息时实际上是将消息放在一个队列中，直到消息能被接收者处理。</p>
<p>10.所有的Mach原生对象都是通过对对应的端口访问的。</p>
<p>11.端口和权限也可以从一个实体传递到另一个实体。实际上，通过复杂消息将端口从一个任务传递到另一个任务并不罕见。这是IPC设计中的一个非常强大的特性，有一点类似于主流UNIX的domain socket，允许在进程之间传递文件描述符。</p>
<p>12.Mach的消息传递模型是远程过程调用（RPC）的一种实现。</p>
<p>13.IPC所需要的基本原语：消息、发送和接收消息的端口，以及确保安全并发的信号量和锁。</p>
<p>14.每一个Mach任务（Mach任务是一个对应于进程的高层次抽象）包含一个指针指向自己的IPC名称空间，在名称空间中保存了自己的端口。此外，任务也可以获得系统范围内的端口。</p>
<p>15.同步机制的根本是排他访问的能力：当别人在使用一个资源时，排除其他人对这个资源的访问。因此最基本的同步原语是互斥对象，也称为互斥体。互斥体只不过是内核内存中的普通变量，通常是机器字大小的证书，但是有一个特殊要求——硬件必须对这些变量进行原子操作。“原子”的意思就是说，对互斥体的操作决不允许被打断——即使是硬件中断也不能打断。在SMP系统上，对物理互斥还有一个要求，就是要求硬件实现某种内存屏障。</p>
<p>16.Mach的锁依赖两个层次组合而成：硬件相关层——依赖于硬件的特殊性质，并且通过特定的汇编指令实现原子性和互斥性；硬件无关层——通过统一的API包装硬件特定的调用，这些API使得Mach之上的层完全不用关心实现的细节。</p>
<p>17.互斥体有一个最大的缺点，就是一次只能有一个线程持有锁。读写锁就是这个问题的解决方案，读写锁能够区分读访问和写访问，多个读者可以同时持有锁，而一次只能有一个写者。当一个写者持有锁时，所有其他线程都被阻塞。 ——pthread_rwlock_t就是POSIX层的API在iOS下的读写锁，区分pthread_rwlock_rdlock读和pthread_rwlock_wrlock写的加锁，解锁统一用pthread_rwlock_unlock。</p>
<p>18.阻塞一个线程意味着放弃线程的时间片，把处理器让给调度器认为下一个要执行的线程。当锁可用时，调度器会得到通知，然后根据自己的判断将线程从等待队列中取出并重新调度。</p>
<p>19.Mach提供了信号量，信号量是泛化的互斥体。互斥体的值只能是0和1，而信号量的取值可以达到某个正数，即允许并发持有信号量的持有者的个数。信号量可以在用户态使用，而互斥体只能在内核态使用。</p>
<p>20.在XNU上，POSIX信号量的底层实现是通过Mach信号量实现的。</p>
<p>21.信号量可以转换为端口，也可以由端口转换而来。</p>
<p>22.锁集就是锁的数组，通过给定的锁ID可以访问锁。锁也可以传递给其他线程。交出一个锁会阻塞交出锁的线程，并唤醒接受锁的线程。</p>
<p>23.锁集的有趣之处在于允许锁的传递。锁的传递指的是将锁从一个任务传递给另一个任务的过程。Mach在调度中也使用了传递的概念，允许一个线程放弃处理器但是指定哪一个线程接替运行。</p>
<p>24.Mach提供了一组异常丰富的API调用用于查询机器信息，所有这些调用都要求获得主机端口才能工作。</p>
<p>主机API最重要的一个方面就是能提供其他方式几乎无法获得的信息。Mach API是获得内核模块信息，内存映射表信息以及其他POSIX（BSD层）无法获得的信息的最直接方法。</p>
<p>25.所有的用户都可以通过mach_host_self()获得主机端口，但是只有特权用户才能通过调用host_get_host_priv_port()获得特权端口。</p>
<p>26.host_set_exception_ports()获得/设置或交换主机层次的异常处理程序。</p>
<p>27.一个或多个processor_t对象可以分组为处理器集，或称为pset。pset中的处理器通过两个队列进行维护：一个是active_queue，保存当前正在执行线程的处理器；另一个是idle_queue，用于保存当前空闲的处理器。</p>
<h1 id="第十一章-Mach调度"><a href="#第十一章-Mach调度" class="headerlink" title="第十一章 Mach调度"></a>第十一章 Mach调度</h1><p>1.和所有现代的操作系统一样，内核调度的对象是线程，而不是进程。Mach使用了比进程更轻量级的概念：任务task。</p>
<p>2.线程定义了Mach中最小的执行单元。一个或多个线程包含在一个任务中。</p>
<p>3.Mach将任务定义为线程的容器，因此资源是在任务这个层次处理的。线程只能（通过端口）访问包含这个线程的任务中分配的资源和内存。</p>
<p>4.任务task是一种容器对象，虚拟内存空间和其他资源都是通过这个容器对象管理的。这些资源包括设备和其他句柄。资源进一步被抽象为端口。因此资源的共享实际上相当于允许对对应端口进行访问。</p>
<p>5.严格的说，Mach的任务并不是其他操作系统中所谓的进程，因为Mach作为一个微内核的操作系统，并没有提供“进程”的逻辑，而只提供了最基本的实现。不过在BSD的模型中，这两个概念有1：1的简单映射，每一个BSD进程（也就是OS X进程）都在底层关联了一个Mach任务对象。实现这种映射的防范是指定一个透明的指针bsd_info，Mach对bsd_info完全无知。</p>
<p>6.任务是没有生命的，任务存在的目的就是要成为一个或多个线程的容器。大部分针对任务的操作实际上就是遍历给定任务中的所有线程，并对这些线程进行对应的线程操作。</p>
<p>7.在任何时刻，内核都必须能够蝴蝶当前任务和当前线程的句柄。内核分别通过current_task()和current_thread()函数完成这两个任务。</p>
<p>8.thread_suspend/thread_resume表示挂起/恢复线程，会递增/递减挂起计数器。线程只有在其suspend计数器和所在的任务的suspend计数器都为0时才能执行。</p>
<p>9.当调用pthread_create()时，底层会转而调用Mach的API调用thread_create()，并且使用mach_task_self()作为第一个参数。</p>
<p>10.由于每一个处理器核心在同一时刻只能运行一个线程，所以内核必须具有抢占一个线程的执行，将处理器让给另一个线程的能力，从而实现上下文切换。</p>
<p>11.由于Mach具有处理器集的抽象，所以从某种角度说，Mach比Linux和Windows更擅长管理多核处理器：Mach可以将同一个CPU的多个核心放在同一个pset中管理，并且通过不同的pset管理不同的CPU。</p>
<p>12.上下文切换是暂停某个线程的执行，并且将其寄存器状态记录在某个预定义的内存位置中。当一个线程被抢占时，CPU寄存器中会加载另一个线程保存的线程状态，从而恢复那个线程的执行。</p>
<p>13.一个线程在CPU上可以执行任意长时间。执行指的是这样一个事实：CPU寄存器中填满了线程的状态，因此CPU执行该线程函数的代码。这个执行过程一直持续，直到①线程终止；②线程自愿放弃CPU；③外部中断打断了线程执行（时间片用完或更高优先级的线程被唤醒）。</p>
<p>14.每一个操作系统都提供了一个优先级的范围：Windows有32个优先级，Linux有140个优先级，而Mach有128个优先级。</p>
<p>内核线程的最低优先级为80，比用户态线程的优先级要高，可以保证内核以及系统维护管理的线程能够抢占用户态的线程。</p>
<p>通过 ps -l 命令可以查看优先级</p>
<p>15.Mach会针对每一个线程的CPU利用率和整体系统负载动态吊证每一个线程的优先级。因此线程会在自己的优先级范围中“漂移”，如果耗CPU太多则降低优先级，如果不能得到足够的CPU资源则提升优先级。</p>
<p>16.在使用多核、SMP或超线程的现代架构中，还可以设置某个线程和一个或多个指定CPU的亲缘性。这种亲缘性对于线程和系统来说都是有好处的，因为当线程回到同一个CPU上执行时，线程的数据可能还留在CPU的缓存中，从而提升性能。用Mach的说法，线程对CPU的亲缘性的意思就是绑定。</p>
<p>17.Mach含有的特殊特性：</p>
<p>①控制权转交（handoff）允许一个线程主动放弃CPU，但不是将CPU放弃给任何其他线程，而是降CPU转交给自己选择的某个特定的线程。</p>
<p>②使用续体可以使线程不用管理自己的栈，线程可以丢弃自己的栈，系统恢复线程执行时不需要恢复线程的栈。</p>
<p>③异步软件陷阱AST是软件对底层硬件陷阱机制的补充完善。通过使用AST，内核可以响应需要得到关注的带外（out-of-band）事件，例如调度事件。</p>
<p>18.Mach对yield做了改进，允许选择将CPU转交给谁。控制权转交并不是对调度器的强制要求，调度器还可以选择将控制权转交给其他线程（例如，如果指定的线程处于不可运行的状态）。作为控制权转交的结果，当前线程剩下的时间片也会被转交给新调度的线程。</p>
<p>19.如果线程要进行控制权转交而不是简单的yield操作，那么需要调用thread_switch()，Mach将thread_switch()导出为一个陷阱，因此也可以从用户态调用这个函数。</p>
<p>20.上下文切换采用的是每一个线程都有自己独有栈的模型，当线程自愿请求一次上下文切换时可以选择指定一个续体。如果指定了续体，那么当线程恢复执行时，系统会以续体作为入口点重新加载线程，并创建新的栈，之前的状态都不会得到保留。这样可以明显加快上下文切换的速度，因为不需要保存和加载寄存器（此外还能显著地节省内核栈的空间，内核栈本身很小，只有4个页面，即16kb）。续体中的线程只需要4-5kb的空间来保存线程状态，将16kb中的其他空间节省下来用作其他用途。使用续体不需要保存完整的寄存器状态和线程栈，只需要保存续体以及参数。</p>
<p>21.续体是缓解上下文切换开销的简单有效的机制，主要由Mach的内核线程使用。内核线程特别喜欢使用续体，Mach的内核线程是通过续体启动的。</p>
<p>22.Mach支持两种不同模式的抢占——显示抢占和隐式抢占，续体模式只能用于显示抢占。</p>
<p>23.系统中的线程可能会被两种方式抢占：一种是显示的抢占，即线程放弃CPU的控制权或进入阻塞的操作；另一种是隐式的抢占，这种抢占是由中断引起的。显示抢占有时候也被认为是同步的，因为这种抢占是事先可以预知的。而由于中断不可预测的本质，所以隐式的抢占是异步的。</p>
<p>24.发生显示抢占的原因可能是等待某个资源，等待某个IO，或睡眠一定的时间。当用户态的线程调用阻塞的系统调用（例如read(),select()和sleep()）时会发生显示抢占。</p>
<p>25.thread_invoke()函数负责执行上下文切换并负责处理续体。</p>
<p>26.显示抢占本身是有局限性的，将放弃CPU的选择权交给运行的线程是极为不可靠的。线程会陷入费时的处理操作中，甚至会进入死循环。</p>
<p>27.Mac OS X是一个抢占式的多任务系统。简单的说，Mach具有随时抢占一个线程的权利，不论这个线程是否准备好了抢占。和显示的抢占不同，这种隐式的抢占对于线程来说是不可见的。线程可以对这种抢占完全不知情，线程的状态会被透明的保存并恢复。大部分线程不会受到太大的影响，因为大部分线程都是IO密集型的。但是对于CPU密集型的线程来说，这种抢占可能会造成一些问题，特别是要求时间关键的性能时（例如视频和音频解码都是这种类型的任务）。</p>
<p>28.Mach是一个分时系统，而不是一个实时系统。</p>
<p>29.THREAD_AFFINITY_POLICY策略定义了线程的L2缓存亲缘性，这些线程共享同一块缓存。这意味着这些线程很可能运行在同一个CPU上，不论这个CPU有多少核心（毕竟同一个CPU上所有核心都共享同一块L2缓存）。</p>
<p>30.异步软件陷阱AST就是为了支持隐士抢占的。AST是人工引发的非硬件触发的陷阱。AST是内核操作的关键部分，而且是调度时间的底层机制，也是BSD信号的实现基础。</p>
<p>31.ast_taken函数（内核陷阱中和内核线程终止时也可以调用）负责处理除了内核idle线程之外的所有线程的AST。否则，这个函数会检查AST_BSD，这原本是对Mach的一个临时修改，使其能够处理BSD事件（例如信号），但是被永久的保留了。如果设置了AST_BSD，则调用bsd_ast处理信号。</p>
<p>32.Mach的线程调度算法高度可扩展，而且允许更换用于线程调度的算法。不过通常情况下，只启用了一个调度器，即传统调度器。调度器大量使用了AST机制。</p>
<p>33.对于要提供抢占式多任务的系统来说，必须有某种机制允许调度器能够首先得到CPU的控制权，从而抢占当前正在执行的线程，然后才能执行调度算法，并且通过调度算法决定当前的线程可以继续恢复执行还是要抢夺其CPU给更重要的线程使用。</p>
<p>34.为了能够从当前运行的线程抢夺CPU，现在的操作系统都利用了现有的硬件中断机制。由于中断的特点是强迫CPU在发生中断时“放下手中所有的任务”，并longjmp跳转到中断处理程序（也称为中断服务例程ISR）执行，因此可以通过中断机制在发生中断时运行调度器。但是问题是，中断是异步的。</p>
<p>35.内核可以配置时钟使其在给定数目的周期之后产生一个中断。这个中断源通常称为定时器中断。</p>
<p>36.解决方案是采用另一种不同的模型：无tick内核。在这种模型中，每一次定时中断发生时，定时器都会被重新设置为调度器认为需要下一次中断的时刻。这意味着在每一次定时器中断时，中断处理程序都要（非常快）扫描还没超期的截止时间线的列表。相比大量不必要的中断，每一次定时器中断中多做的这些处理工作还是值得的，而且通过只跟踪那些最紧急的截止时间线可以将这些处理工作的开销降到最低。</p>
<p>37.在添加非严格的定时器事件是会加上一个所谓的“宽限slop”值，通过宽限值可以合并一些定时器事件，从而增加这些定时器事件同时超时的概率（从而减少了定时器中断的总数）。</p>
<p>38.Mach只提供了一个异常处理机制用于处理所有类型的异常——包括用户定义的异常、平台无关的异常、以及平台特定的异常。</p>
<p>39.在Mach中，异常是通过内核中的基础设施——消息传递机制——处理的。异常由出错的线程或任务（通过msg_send()）抛出，然后由一个处理程序（通过msg_recv()）捕捉。处理程序可以处理异常，也可以清除异常，可以决定终止线程。</p>
<p>40.Mach的异常处理程序在不同的上下文中运行异常处理程序，出错的线程向预先指定好的异常端口发送消息，然后等待应答。每一个任务都可以注册一个异常端口，这个异常端口会对同一个任务中的所有线程起效。单个的线程还可以通过 thread_set_exception_prots 注册自己的异常端口。通常情况下，任务和线程的异常端口都是NULL，也就是说异常不会被处理。</p>
<p>41.发生异常时，首先尝试将异常抛给线程的异常端口，然后尝试抛给任务的异常端口，最后再抛给主机的异常端口（即主机注册的默认端口）。如果没有一个端口返回 KERN_SUCCESS，那么整个任务被终止。Mach不提供异常处理逻辑——只提供传递异常通知的框架。</p>
<p>42.exception_triage()负责主要的异常处理逻辑，这个逻辑在两种架构上的Mach消息层面都是一样的。这个函数尝试根据前文描述的方式——线程、任务、最终到达主机——利用exception_deliver()投递异常。</p>
<p>43.每一个线程或任务对象，以及主机本身，都有一个异常端口数组，这个数组中的端口通常初始化为IP_NULL。通过xxx_set_exception_ports()调用可以设置这些异常端口，其中的xxx为thread、task或host。</p>
<p>44.[mach]_exception_raise 用于EXCEPTION_DEFAULT，[mach]_exception_state_raise 用于EXCEPTION_STATE。[PLCrashReporter里有相关的使用] 这些函数最终通过调用ux_exception将异常转换为响应的UNIX信号，并且通过threadsignal将信号投递到出错的线程。</p>
<p>45.OS X的最重要的特性之一崩溃报告器（crash reporter）就是利用异常端口的机制实现的。launchd注册了异常端口，然后将所有子进程都应用同样的异常端口，因为异常端口是随着进程fork集成的。launchd将ReportCrash设置为MachExceptionHandler。通过这种方式，当一个launchd作业发生异常时，崩溃报告器会自动根据需要启动。调试器也可以利用异常端口捕捉异常并且在发生错误时中断。</p>
<p>46.Mach异常处理会先于UNIX异常处理发生。</p>
<p>47.使用mach_msg在异常端口上创建一个活动监视者。异常处理可以由同一个程序中的另一个线程来完成，不过更有意思的做法是在另一个程序中实现异常处理的部分。</p>
<p>48.Mach是XNU的微内核核心。XNU暴露给用户的主要接口：BSD层。BSD层使用了Mach作为底层的原语和抽象，向应用程序暴露出流行的POSIX API，使得OS X能够和很多其他的UNIX实现兼容。</p>
<p>常见的架构无关的Mach异常</p>
<p>EXC_BAD_ACCESS 内存访问异常，代码包含发生内存访问异常的地址。</p>
<p>EXC_BAD_INSTRUCTION 指令异常，非法或未定义的指令或操作数。</p>
<p>EXC_BREAKPOINT 和跟踪、断点相关的异常</p>
<p>EXC_SYSCALL 系统调用</p>
<p>EXC_CRASH 异常的进程退出</p>
<h1 id="第十二章-虚拟内存"><a href="#第十二章-虚拟内存" class="headerlink" title="第十二章 虚拟内存"></a>第十二章 虚拟内存</h1><p>1.Mach和所有内核一样，代码中有很大一部分都在负责高效的管理虚拟内存。</p>
<p>2.vm_map：表示任务地址空间内的一个或多个虚拟内存区域。每一个区域都由一个独立的条目vm_map_entry表示，这些条目由一个双向链表vm_map_links维护。</p>
<p>vm_map_entry: 每一个vm_map_entry 都表示了虚拟内存中一块连续的区域。每一个这样的区域都可以通过指定的访问保护权限进行保护（和虚拟内存页面采用同样的权限，即r/w/x权限）。vm_map_entry 通常指向一个vm_object，但是也可以指向一个嵌套的vm_map，即子映射。</p>
<p>vm_object: 用于将vm_map_entry 和实际支撑的内存关联起来。这个数据结构包含一个 vm_page 的链表。</p>
<p>vm_page：vm_page真正表示了vm_object或部分vm_object。vm_page可以有多种状态：驻留内存、交换出、加密、干净和脏等。</p>
<p>3.每一个Mach任务都有一个自己的虚拟内存空间，任务的struct task 中的map字段保存的就是这个虚拟内存空间。</p>
<p>4.purgeable的对象在内存低的情况下可能会丢失，即直接释放，而不是提交到后备存储。</p>
<p>5.Mach的API比POSIX提供的等同API要强大得多，主要是因为Mach API允许一个任务入侵到另一个任务的地址空间。为了访问其他任务的地址空间，要求有相应的权限（具体来说就是任务的端口）。除了这点要求之外，这些调用几乎是无所不能的。事实上，在OS X中很多进程入侵和线程注入技术都依赖这些Mach调用，而不是依赖BSD提供的调用。</p>
<p>6.vmmap()的例子可以很容易扩展得更具有入侵性，比如可以将进程内存映射导出到磁盘，甚至可以写入内存映射。</p>
<p>7.pmap可以嵌套（即包含其他pmap）。这是一个非常常见的技术，共享内存严重依赖这项技术——包括隐式的共享内存（共享库）和显式的共享内存（mmap()）。</p>
<p>8.Mach Zone的概念相当于Linux的内存缓存和Windows的Pool。Zone是一种内存区域，用于快速分配和释放频繁使用的固定大小的对象。Zone的API是内核内部使用的，在用户态不可使用。内核中的Zone和malloc的zone完全不同，后者是C运行时库的一部分，在用户态使用，而且具有很好的文档。</p>
<p>BSD内核zone 直接构建与Mach的zone之上。</p>
<p>9.如果系统内存不足，zone可能会进行垃圾回收。垃圾回收是一个两趟的过程，系统首先扫描所有的zone（跳过标记为不可回收的zone），检查这些zone的空闲列表，判断哪些对象是可以回收的。在第二趟中，将这些对象转换为页面：和非空闲对象共享了一个页面的对象不能被释放，只有页面全部空闲的对象才能被释放。最后，当判定好了可以释放的页面之后，通过kmem_free()释放。</p>
<p>10.所有的内核分配（除了连续物理内存的分配）的路径最终都会到达一个函数，那就是kernel_memory_allocate()。</p>
<p>11.进程的内存需求早晚会超过可用的RAM，系统必须有一种方法能将不活动的页面备份起来并且从RAM中删除，腾出更多的RAM给活动的页面使用，至少暂时能够满足活动页面的需求。在其他的操作系统中，这个工作是由专门的内核线程完成的。例如，Linux中的pdflush和wswapd内核线程。在Mach中，这些专用的任务成为分页器，分页器可以是内核线程，甚至可以是外部的用户态服务程序。</p>
<p>这里提到的分页器及基金实现了各自负责的内存对象的分页操作。这些分页器不会控制系统的分页侧路。分页策略是由vm_pageour守护线程负责的，而vm_pageout守护线程是kernel_bootstrap_thread()完成所有任务之后最后变成的。</p>
<p>12.Mach通过Universal Page List（统一页列表）这个数据结构来维护页的信息，这个列表和分页器的具体实现无关。UPL是连接虚拟地址和实际的物理页面的纽带，有一点类似于Windows的Memory Descriptor List和IOKit的IOMemoryDescriptor。</p>
<p>13.Vnode分页器负责支持文件的内存映射。当内存映射了文件，这些文件的内容需要从文件系统中读取。当内存映射的文件在内存中“脏”了，那么这些脏的页面需要写回文件系统。解密的页面永远不会被标记为脏，因此永远都不会被换出到磁盘上（如果可以从交换文件中提取到明文，那么整个加密就没有意义了）。</p>
<p>14.通过DYLD_INSERT_LIBRARIES强制注入一个库，然后直接从任务中读取内存。这也是为什么尽管App Store的二进制文件被加密，但是iOS应用程序的破解依然很繁荣的原因。</p>
<p>15.pageout守护程序其实不是一个真正的守护程序，而是一个线程。vm_pageout永不返回。初始化之后会派生出两个线程：外部的iothread，和一个垃圾回收线程（其实还有第三个线程，内部的iothread，是默认分页器注册时创建的）。设置完成后，vm_pageout()最终调用vm_pageout_continue()，这个函数周期性的唤醒并执行vm_pageout_scan()。</p>
<p>16.BSD层的Jetsam机制类似于Linux的Low Memory Killer。</p>
<p>17.在iOS中，物理内存非常紧缺而且没有交换空间，这个宏调用了vm_check_memorystatus()，而后者负责唤醒kernel_memorystatus线程，这属于Jetsam机制的一部分。</p>
<p>18.vm_fault()函数调用vm_page_fault()处理实际发生错误（缺页中断）的页面，并且从后备存储中将这个页面取回。实现方法是：查找vm_page对应的vm_object，然后从中获得分页器的端口，分页器的data_request函数负责从后备存储中读入要换入的页面。如果需要的话，换入操作还会对页面进行解密（如果页面在加密的交换文件中），并且验证代码签名。</p>
<p>19.非法访问：访问一个没有映射到进程地址空间（即任务的vm_map）的地址。解引用一个野指针时通常会发生这种错误。发生这种错误时进程会收到SIGSEGV信号。</p>
<p>20.页面保护错误：访问一个映射的地址，但是页面的保护掩码拒绝请求的访问。通常引发这个错误的原因包括跳转到数据段或试图写入（或读取）一个不允许写入（或不允许读取）的页面。发生这种错误时进程会收到SIGBUS信号。</p>
<p>21.dynamic_pager()是一个用户态的守护程序，负责维护系统交换文件，默认情况下交换文件在/private/var/vm/swapfile目录下。内核的default_pager分页器需要在用户态的干预下调整或修改交换条件时，从内核态调用这个守护程序。</p>
<h1 id="第十三章-BSD层"><a href="#第十三章-BSD层" class="headerlink" title="第十三章 BSD层"></a>第十三章 BSD层</h1><p>1.Mach只是一个微内核。尽管Mach的部分应用程序编程接口（API）也暴露给了用户态，但是开发者主要使用的还是更为流行的POSIX API，而这一套API是通过Mach之上的BSD层实现的。</p>
<p>2.ptrace()属于进程控制相关的调用。</p>
<p>3.在Mach提供的这些原语之上还需要建立一个层次提供像文件、设备、用户和组等重要从抽象。Mach最早选择的这个层次就是BSD，而且延续在XNU中了。</p>
<p>4.BSD采用了两个原语，并且组织成立UNIX世界上著名的进程和线程的概念。</p>
<p>5.BSD的进程可以唯一的映射到Mach任务，但是包含的信息比Mach任务提供的基本调度和统计信息要丰富。其中最值得注意的是，BSD进程包含了文件描述符和信号处理程序的数据。进程还支持复杂的谱系，将进程和其父进程、兄弟进程和子进程连接起来。</p>
<p>6.进程就是容器，二进制代码的实际执行单元是线程。</p>
<p>7.用户态的线程始于对pthread_create的调用。这个函数做的工作并不多，因为主要工作是由bsdthread_create()系统调用完成的，bsdthread_create()只不过是对Mach线程创建的复杂包装。真正的线程创建是由底层的Mach层完成的。bsdthread_create()负责的工作是设置线程栈（如果指定了自定义栈），设置（机器相关的）线程状态，以及设置自定义调度参数（如果提供了的话）等。</p>
<p>8.在UNIX中，进程不能被创建出来，只能通过fork()系统调用复制出来。如果fork()操作失败，fork()只会在调用的进程中返回-1。</p>
<p>9.子进程是父进程的完整复制，除了一下几个重要的例外：</p>
<p>①文件描述符，尽管数值和指向的文件都是一样，但只是原始描述符的副本。这意味着后续对这些描述符修改的调用（例如lseek()和close()）只会影响创建这些描述符的进程。</p>
<p>②资源限制，子进程会继承资源限制，但是资源利用率都设置为0。</p>
<p>③子进程的内存映像看上去是子进程私有的，但是事实上子进程和父进程使用的是内存中相通的物理页面。虚拟内存的私有性是通过设置页面的写时复制标志位来保证的，因此不论是哪个进程试图写入页面时都会引发页错误，从而创建页面的副本，并且重新建立映射。</p>
<p>10.vfork()的进程没有对应的Mach任务和线程。只有在接下来调用了execve()之后才会创建任务和线程。事实上，除了有一个execve()跟在后面之外，vfork()没有存在的意义，因为这个系统调用最初的设计就是为了这个目的。子进程的 task_t 和 thread_t （可以分别通过mach_task_self()和mach_thread_self()获得）完全就是父进程的 task_t 和 thread_t ，vm_map也是如此，只有以后调用 execve()载入一个Mach-O镜像才能最终真正创建一个Mach任务和进程。</p>
<p>11.如果将一个进程比作是一个人体，那么在进程中执行的二进制程序就是这个人体的大脑。只是通过fork()新创建出来的进程也没有多大作用，除非执行镜像通过exec()替换为另一个可执行程序。因此，进程创建的核心在于二进制文件的加载和执行。</p>
<p>12.execsw镜像加载器。进程执行镜像的流程太长了，这里不做记录，还是直接看书吧，</p>
<p>13.所有的镜像加载的路径要么终止在一个错误上，要么最终完成加载Mach镜像。</p>
<p>14.XNU中的Mach-O加载逻辑基本上和NeXT在1988年发明这个格式时差不多。经过这么多年苹果对这个过程做了一些修改，其中主要针对代码解密部分进行修改，但是Mach-O文件格式基础基本没什么变化。</p>
<p>苹果将这个修改封装在 exec_mach_imgact()中了，这是Mach二进制文件注册的处理程序。这个函数首先读取Mach文件头，然后解析其架构（32位或64位）和标志位。这个函数拒绝接受Dylib和Bundle文件——这些文件是由用户态的dyld动态链接器负责的。然后再应用posix_spawn()中的参数（如果有的话）。之后，对二进制进行评估以确保满足当前架构的需求。</p>
<p>处理Mach-O加载的主要函数是load_machfile()。load_machfile()函数负责设置内存映射，这个映射最终会加载各种 LC_SEGMENT 命令加载的数据。</p>
<p>Load_machfile()的核心在于parse_machfile。这个函数负责实际解析加载命令的繁杂工作。</p>
<p>其中，load_code_signature 也是load_machfile()函数里众多流程中的一个步骤，也就是验证代码签名。</p>
<p>经过三趟扫描后，在dlp变量中有一个保存的动态链接器命令，将动态链接器加载到新的映射中，可能要根据ASLR偏移进行调整。load_dylinker()函数会递归的调用parse_machfile()。</p>
<p>如果load_machfile()成功返回了，exec_mach_imgact会继续完成后续的工作。具体操作如下：</p>
<p>①通过调用vm_map_set_user_write_limit设置ulimit-m；</p>
<p>②设置代码签名的标志：</p>
<p>​ CS_HARD：拒绝加载无效页；</p>
<p>​ CS_KILL：如果有任何无效页则杀掉进程；</p>
<p>​ CS_EXEC_*：和上面两个标志位一样，只不过来自execve()。</p>
<p>③设置新的进程名称等等。</p>
<p>需要注意的是，这里并没有强制任何事情：真正的代码签名实施是在Mach的VM页错误处理程序中，通过调用 cs_invalid_page 来强制实施策略。</p>
<p>15.Mach提供了丰富的跟踪机制，其中最重要的就是DTrace。另一个机制ptrace()，这个机制在OS X和iOS（故意的）上只有部分功能有效。</p>
<p>16.BSD和其他UNIX系统提供了一个名为ptrace()的一站式系统调用，这个调用支持进程跟踪和调试。这个系统调用对于调试和逆向工程来说非常有用，例如在Linux中，gdb，系统调用跟踪（strace）和库函数调用跟踪（ltrace）就是用了这个系统调用。</p>
<p>17.在Linux中，ptrace的真正实力在于能够读写其他进程的内存，而XNU的ptrace实现则忽略了这些选项。不过Mach的API也能实现类似的功能。</p>
<p>18.挂起一个进程相当于停止一个进程的执行无限长时间，知道这个进程被恢复。冷冻和解冻的决定权通常都在iOS的加载器SpringBoard手中。</p>
<p>19.Mach已经通过异常机制提供了底层的陷阱处理，而BSD则在异常机制之上构建了信号处理机制。硬件产生的信号被Mach层捕捉，然后转换为对应的UNIX信号。为了维护一个统一的机制，操作系统和用户产生的信号首先被转换为Mach异常，然后再转换为信号。</p>
<p>20.当一个BSD进程（也是用户态进程）被bsdinit_task()函数启动时，这个函数还调用了 ux_handler_init()函数，这个函数设置了一个名为 ux_handler 的Mach内核线程。只有在 ux_handler_init()函数返回之后，bsdinit_task() 才能够注册使用 ux_exception_port。</p>
<p>通过调用 host_set_exception_ports()函数，bsdinit_task() 将所有的Mach异常消息都重定向到 ux_exception_port，这个端口由 ux_handler() 线程持有。由于所有后创建的用户态进程都是PID 1的后台，所以这些进程都会自动继承这个异常端口，相当于 ux_handler() 线程要负责处理系统上 UNIX 进程产生的每一个Mach异常。</p>
<p>ux_handler()函数非常简单，这个函数在进入时首先设置好 ux_handler_port，然后进入一个无限的Mach消息循环。消息循环接收Mach异常消息，然后调用mach_exc_server()处理异常。</p>
<p>mach_exc_server会调用mach_exception_raise()，然后会被mach_catch_exception_raise()捕获，信号处理逻辑就在这里。</p>
<p>21.硬件产生的信号始于处理器陷阱。处理器陷阱是平台相关的。ux_exception负责将陷阱转换为信号。</p>
<p>如果信号不是由硬件产生的，那么这个信号来源于两个API调用：kill()或pthread_kill()。这两个函数分别向进程和线程发送信号。</p>
<img src="/images/system/unixsignal.png" class="" title="Mach异常到UNIX信号映射">


<h1 id="第十四章-BSD的高级功能"><a href="#第十四章-BSD的高级功能" class="headerlink" title="第十四章 BSD的高级功能"></a>第十四章 BSD的高级功能</h1><p>1.虚拟内存管理是在Mach层进行的，Mach控制了分页器，并且向用户态导出了各种vm_和mach_vm_消息接口。而用户态的开发者大部分都只知道标准的POSIX调用，因此需要对这些Mach调用进行封装。类似的，BSD层也使用了自己的内存管理函数。</p>
<p>2.OS X和iOS实现了一个低内存情形的处理机制，成为Jetsam，或者称为Memorystatus。这个机制有点类似于Linux的“out-of-memory”杀手，最初的用途就是杀掉消耗太多内存的进程。Jetsam的名字来源于杀掉消耗内存最多的进程并且抛弃这些进程占用的内存页面的过程。</p>
<p>3.Memorystaus维护了两个列表：一个是快照列表，这个列表保存了系统中所有进程的状态以及消耗的内存页面数；还有一个优先级列表，保存了要杀掉的备选进程。</p>
<p>4.用户态也可以通过pid_suspend()和pid_resume()控制进程的休眠。</p>
<p>5.ASLR：Address Space Layout Randomization 内核地址空间布局随机化。</p>
<p>ASLR对内核代码的影响非常小：代码不再使用固定地址，而是转变为使用相对地址，相对地址是针对程序的当前位置确定的。</p>
<p>6.工作队列是OS X中开发的一项机制，作用是为应用程序提供多线程并扩展到多处理器支持。工作队列是GCD的基础机制。</p>
<p>7.overcommit位表示这个队列可以创建新的线程。通常情况下不建议使用这个策略，因为线程数多于CPU数会降低程序的运行速度。</p>
<p>GCD仅通过dispatch_get_global_queue调用可以接受的一个标志（DISPATCH_QUEUE_OVERCOMMIT）来支持overcommit，但是苹果的文档掩盖了这个事实，宣称这个标志位必须为0。</p>
<p>GCD和libdispatch在工作队列不存在或被禁用时也能工作，在这种情况下，GCD和libdispatch会退而使用线程池模型。</p>
<p>补充：</p>
<p>_dispatch_get_root_queue 会获取一个全局队列，它有两个参数，分别表示优先级和是否支持 overcommit。一共有四个优先级，LOW、DEFAULT、HIGH 和 BACKGROUND，因此共有 8 个全局队列。带有 overcommit 的队列表示每当有任务提交时，系统都会新开一个线程处理，这样就不会造成某个线程过载(overcommit)。——参考自<span class="exturl" data-url="aHR0cHM6Ly9iZXN0c3dpZnRlci5jb20vZGVlcC1nY2Qv">https://bestswifter.com/deep-gcd/<i class="fa fa-external-link-alt"></i></span></p>
<p>阅读过 GCD 源码的同学会知道，所有默认创建的 GCD queue 都有一个优先级，但其实每个优先级对应两个 queue，比如一个是 default-priority， 那么另一个就是 default-priority-overcommit。dispatch_async 的时候，会首先将任务丢进 default-priority 队列，如果队列满了，就转而丢进 default-priority-overcommit。</p>
<p>在 Mac 系统里，GCD 允许 overcommit，意味着每次 dispatch_async 都会创建一个新线程，即使 over commit 了，这些过量的线程会根据优先级来竞争 CPU 资源。</p>
<p>而在 iOS 系统里，GCD 会控制 overcommit，如果某个优先级队列 over commit 里，那么排在后面的任务就会处于等待状态。移动设备 CPU 资源比较紧张，这种设计合乎常理。</p>
<p>所以如果在 iOS 里创建过多的 serial queue，那么后面提交的任务可能就会一直处于等待状态。这也是为什么我们需要严格控制 queue 的数量和层级关系，最好是 App 当中每个子系统只能分配固定数量和优先级的 queue，从而避免 thread explosion 导致的代码无法及时执行问题。</p>
<p>——参考自<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzQ2MzA1NQ==">https://zhuanlan.zhihu.com/p/37463055<i class="fa fa-external-link-alt"></i></span></p>
<p>8.MAC：Mandatory Access Control 强制访问控制。</p>
<p>9.iOS的安全机制比OS X的安全机制严格得多。OS X中代码签名是可选的，而iOS会通过kill-9杀掉任何代码签名不正确的进程。</p>
<p>iOS中“坏警察”是由AMFL扮演的，AMFL在用户态也有一个守护程序：/usr/libexec/amfid。这个守护程序是由launchd启动的。也注册了一个主机特殊端口。</p>
<h1 id="第十五-十六章-文件系统"><a href="#第十五-十六章-文件系统" class="headerlink" title="第十五/十六章 文件系统"></a>第十五/十六章 文件系统</h1><p>1.ACL：Access Control List 访问控制列表。OS X允许通过chmod()设置和修改ACL。通过 ls -e 可以显示访问控制列表。 ——比如著名的chomd 777就是把文件改为可读可写可执行的状态</p>
<p>2.Unix要求维护3个时间戳：创建事件、修改时间和访问时间。</p>
<p>3.FIFO是UNIX对“具名管道”的实现。通过pipe()系统调用可以创建匿名管道，但是匿名管道不能在无关的进程间共享。</p>
<p>4.底层的文件系统可以是基于表的（例如FAT），也可以基于B树的（例如NTFS和HFS+）。</p>
<p>5.每一个操作系统都有一个自己的原生文件系统。DOS的原生文件系统是FAT，Windows的原生文件系统是NTFS，HFS+是OS X的原生文件系统。</p>
<p>6.内核不能执行压缩操作，而且也没有提供对外部压缩的支持：在内核层只支持解压缩。</p>
<p>7.HFS+使用的是UTF_16编码——双字节Unicode。HFS+也是大小写不敏感的文件系统。OS X 默认使用HFS+，iOS使用启动了大小写敏感的HFSX。</p>
<p>8.日志是磁盘中一块特殊的区域，用户看不见这个区域，文件系统在向磁盘提交事务之前会将事务记录在这个区域中。如果修改事务被成功提交，那么这些事务就会从日志中删除。但是如果发生了崩溃，文件系统可以快速恢复到一致的状态——要么重放日志（即提交所有记录的事务），要么回滚日志（如果包含未完成的事务）。</p>
<p>日志并不是解决数据丢失的灵丹妙药。然而，日志可以显著的减少系统崩溃导致文件系统无法使用的情况。</p>
<p>9.HFS+有一项很有意思很特别的特性是能够动态适应频繁访问的文件。HFS+为每一个文件维护一个热度值。HFS+能够在工作时进行碎片整理工作。</p>
<p>10.B树是一些文件系统构建的基础，例如NTFS（Windows）、Ext4（Linux）和苹果的HFS及HFS+。</p>
<p>11.任何文件系统最基本的概念就是用于保存和取得文件的机制。需要满足的需求包括：搜索、插入、更新和随机访问。</p>
<p>大部分文件系统都采用了基于树的方案。根据树形结构的设计，上述的要求都能满足，而且还很自然的提供了层次结构，这是平坦的表示结构无法提供的。</p>
<p>12.B数可以看成是二叉树的扩展，相似的地方在于都采用了树形结构，而不同的地方在于B树的节点可以有任意数据的子节点——定义为m——而不只是两个子节点。这种结构可以帮助限制树的深度，从log2(N)（典型的二叉树搜索时间复杂度），到最优情况的logm(N)以及最坏情况的logm/2(N)。</p>
<p>13.和所有的树一样，B树由节点组成，但是和其他树不一样的地方在于，B树的节点可以有具体的子类型，或称为kind。不同的节点类型可以保存不同的数据，但是所有类型的节点都来源于一个基本类型（可以看成是一个基类）。</p>
<p>为了遍历所有的记录，在节点尾部向头部方向依次保存了指向每一条记录的指针，其中也包含节点中包含的任何空闲空间使用的空记录的指针。</p>
<p>14.HFS+的B树总是有一个固定的深度。也就是说，所有的叶子节点都在同一层上。</p>
<p>15.当HFS+挂载时启动了日志功能，那么还会启用一个日志文件。</p>
<h1 id="其他部分-网络协议栈-内核扩展模块-IOKit"><a href="#其他部分-网络协议栈-内核扩展模块-IOKit" class="headerlink" title="其他部分 网络协议栈/内核扩展模块/IOKit"></a>其他部分 网络协议栈/内核扩展模块/IOKit</h1><p>1.一般的Cocoa开发者并不需要了解套接字相关的知识。因为CoreFoundation通过CFNetwork提供了封装了套接字的CFSocket和CFStream，此外还提供了一些协议的封装，例如CFFTP、CFHTTP等。尽管如此，BSD套接字是XNU中所有网络组件的核心（实际上也是所有现代操作系统的核心）。</p>
<img src="/images/system/other.png" class="" title="网络">


<p>2.模块化设计是可扩展性之母。</p>
<p>3.代码签名，如今已经被大多数系统采纳为标准。Windows是一个典型实例，只允许加载具有合法数字签名的驱动程序。在控制权转交给模块入口点之前，内核会验证代码签名，代码签名保存在附加的证书中。证书必须通过私钥签名，内核已知公钥，内核也可以通过一个信任链获得这样一个秘钥。</p>
<p>早在iBoot阶段，未经苹果签名的代码就不能被加载。</p>
<p>4.预链接是苹果在OS X和iOS中使用的方法。引导加载器不按照先加载内核，再以一定顺序加载kext的方式进行加载，而是加载一个kernelcache文件。——好处是加载的速度快得多，并且kernelcache可以添加签名，甚至还可以加密，一旦加载了kernelcache，就可以禁止所有kext加载，这样可以阻断代码进入iOS内核的合法通道。</p>
<p>5.IOKit有一个顶层的抽象基类是OSObject。</p>
<p>6.IOKit提供了一个工作循环（work loop）模型，有一点类似于Objective-C的runloop（或Mach的消息循环）。简而言之，工作循环是一个不断处理事件的消息处理循环。通过使用工作循环可以极大的简化并发问题，而且通常可以避免对锁的使用，锁是会影响性能的。</p>
<p>7.IOKit采用了NeXT的runloop模型，用户态开发者应该会想到CFRunLoop。IOKit版本的runloop成为IOWorkloop，基本思想是一样的：提供一个单线程且线程安全的机制处理所有类型的事件，如果不采用这种机制则是异步的。工作循环的访问被一个互斥体保护，因此不需要考虑可重入的问题以及线程安全的问题。不过要注意的是，不能保证工作循环确实是一个线程。也就是说，工作循环的迭代可能会运行在系统中另一个线程的上下文中。</p>
<p>8.上下文切换：是另一种类型的控制权转移，上下文切换指的是将当前正在执行的线程的上下文切换为另一个线程的上下文。</p>
<p>9.ARM和Intel处理器都在处理器层次提供了线程的支持。事实上，这也是为什么现代操作系统都不调度进程，而是调度线程的原因。</p>
<p>10.在现代操作系统中，实现并发的先决条件是具有能够提供安全锁定机制的能力，通过这种方式能够同步共享资源的访问。同步机制通常都依赖于硬件的支持，因此在ARM和Intel架构上的实现是不同的。Mach底层的hw_lock_lock()函数的实现时候一个很好的示例。从内核的角度看，这个函数提供的方法总是一直的：快速的自旋锁。</p>
<p>11.原子操作是和锁非常接近的功能。院子操作是一类保证了原子性（atomicity，几不可中断性）的操作。原子操作常作为锁操作的底层机制（因为必须以原子的方式访问锁），而且经常可以替代锁的使用（当要保护的对象为机器字大小时）。</p>
<p>原子不一定意味着单周期，原子的意思只是说CPU保证在访问的过程中不会被打断。</p>
<p>12.为了能够最优化的利用内部组件（例如ALU，FPU和加载/存储组件），现代的CPU会采用乱序的方式执行指令。然而在某些情况下，乱序执行可能会在程序中引入bug。在这种情况下，可以使用屏障（barrier）指令来确保程序执行到某个点时所有访问操作都完成了。——比如iOS的内存屏障</p>
]]></content>
      <categories>
        <category>OS</category>
        <category>macos-ios</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue知识</title>
    <url>/vue/qa.html</url>
    <content><![CDATA[<h1 id="对于MVVM的理解？"><a href="#对于MVVM的理解？" class="headerlink" title="对于MVVM的理解？"></a>对于MVVM的理解？</h1><p>MVVM 是 Model-View-ViewModel 的缩写。<br>Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。<br>View 代表UI 组件，它负责将数据模型转化成UI 展现出来。<br>ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。<br>在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。<br>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
<h1 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h1><ol>
<li><code>beforeCreate</code>（创建前） 在数据观测和初始化事件还未开始</li>
<li>created（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来</li>
<li><code>beforeMount</code>（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。</li>
<li><code>mounted</code>（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</li>
<li><code>beforeUpdate</code>（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。</li>
<li><code>updated</code>（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>
<li><code>beforeDestroy</code>（销毁前） 在实例销毁之前调用。实例仍然完全可用。<br>destroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</li>
</ol>
<p>1.什么是vue生命周期？<br>答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</p>
<p>2.vue生命周期的作用是什么？<br>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p>
<p>3.vue生命周期总共有几个阶段？<br>答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。</p>
<p>4.第一次页面加载会触发哪几个钩子？<br>答：会触发 下面这几个beforeCreate, created, beforeMount, mounted 。</p>
<p>5.DOM 渲染在 哪个周期中就已经完成？<br>答：DOM 渲染在 mounted 中就已经完成了。</p>
<h1 id="Vue实现数据双向绑定的原理：Object-defineProperty（）"><a href="#Vue实现数据双向绑定的原理：Object-defineProperty（）" class="headerlink" title="Vue实现数据双向绑定的原理：Object.defineProperty（）"></a>Vue实现数据双向绑定的原理：Object.defineProperty（）</h1><p>vue实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p>
<p>vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令(vue中是用来解析 <code>&#123;&#123;&#125;&#125;</code>)，最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。</p>
<p>js实现简单的双向绑定</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;txt&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> obj = &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;txt&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> obj</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newValue</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;txt&#x27;</span>).<span class="property">value</span> = newValue</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;show&#x27;</span>).<span class="property">innerHTML</span> = newValue</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        obj.<span class="property">txt</span> = e.<span class="property">target</span>.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Vue组件间的参数传递"><a href="#Vue组件间的参数传递" class="headerlink" title="Vue组件间的参数传递"></a>Vue组件间的参数传递</h1><ol>
<li>父组件与子组件传值<br>父组件传给子组件：子组件通过props方法接受数据;<br>子组件传给父组件：$emit方法传递参数</li>
<li>非父子组件间的数据传递，兄弟组件传值<br>eventBus，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适。（虽然也有不少人推荐直接用VUEX，具体来说看需求咯。技术只是手段，目的达到才是王道。）</li>
</ol>
<h1 id="Vue的路由实现：hash模式-和-history模式"><a href="#Vue的路由实现：hash模式-和-history模式" class="headerlink" title="Vue的路由实现：hash模式 和 history模式"></a>Vue的路由实现：hash模式 和 history模式</h1><p><code>hash模式</code>：在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取；<br>特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。<br>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <span class="exturl" data-url="aHR0cDovL3d3dy54eHguY29tLC8=">http://www.xxx.com，<i class="fa fa-external-link-alt"></i></span> 因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。</p>
<p><code>history模式</code>：history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。<br>history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <span class="exturl" data-url="aHR0cDovL3d3dy54eHguY29tL2l0ZW1zL2lkJUUzJTgwJTgyJUU1JTkwJThFJUU3JUFCJUFGJUU1JUE2JTgyJUU2JTlFJTlDJUU3JUJDJUJBJUU1JUIwJTkxJUU1JUFGJUI5">http://www.xxx.com/items/id。后端如果缺少对<i class="fa fa-external-link-alt"></i></span> /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</p>
<h1 id="vue路由的钩子函数"><a href="#vue路由的钩子函数" class="headerlink" title="vue路由的钩子函数"></a>vue路由的钩子函数</h1><p>首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。</p>
<p><code>beforeEach</code>主要有3个参数to，from，next：</p>
<p><code>to</code>：route即将进入的目标路由对象，</p>
<p><code>from</code>：route当前导航正要离开的路由</p>
<p><code>next</code>：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。</p>
<h1 id="vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#vuex是什么？怎么使用？哪种功能场景使用它？" class="headerlink" title="vuex是什么？怎么使用？哪种功能场景使用它？"></a>vuex是什么？怎么使用？哪种功能场景使用它？</h1><p>只用来读取的状态集中放在store中； 改变状态的方式是提交mutations，这是个同步的事物； 异步逻辑应该封装在action中。<br>在main.js引入store，注入。新建了一个目录store，….. export 。<br>场景有：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车</p>
<!-- vuex -->
<img src="/images/vuex.png" class="">

<p><code>state</code><br>Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。<br><code>mutations</code><br>mutations定义的方法动态修改Vuex 的 store 中的状态或数据。<br><code>getters</code><br>类似vue的计算属性，主要用来过滤一些数据。<br><code>action</code><br>actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123; <span class="comment">//store实例</span></span><br><span class="line">      <span class="attr">state</span>: &#123;</span><br><span class="line">         <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">             &#125;,</span><br><span class="line">      <span class="attr">mutations</span>: &#123;                </span><br><span class="line">         increment (state) &#123;</span><br><span class="line">          state.<span class="property">count</span>++</span><br><span class="line">         &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">      <span class="attr">actions</span>: &#123; </span><br><span class="line">         increment (context) &#123;</span><br><span class="line">          context.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>modules</code><br>项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: moduleA,</span><br><span class="line">    <span class="attr">b</span>: moduleB</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="vue-cli如何新增自定义指令？"><a href="#vue-cli如何新增自定义指令？" class="headerlink" title="vue-cli如何新增自定义指令？"></a>vue-cli如何新增自定义指令？</h1><ol>
<li>创建局部指令</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;    </span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 创建指令(可以多个)</span></span><br><span class="line">    <span class="attr">directives</span>: &#123;</span><br><span class="line">        <span class="comment">// 指令名称</span></span><br><span class="line">        <span class="attr">dir1</span>: &#123;</span><br><span class="line">            <span class="title function_">inserted</span>(<span class="params">el</span>) &#123;</span><br><span class="line">                <span class="comment">// 指令中第一个参数是当前使用指令的DOM</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(el);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">                <span class="comment">// 对DOM进行操作</span></span><br><span class="line">                el.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&#x27;200px&#x27;</span>;</span><br><span class="line">                el.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&#x27;200px&#x27;</span>;</span><br><span class="line">                el.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;#000&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>全局指令</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;dir2&#x27;</span>, &#123;</span><br><span class="line">    <span class="title function_">inserted</span>(<span class="params">el</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(el);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>指令的使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-dir1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-dir2</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="vue如何自定义一个过滤器？"><a href="#vue如何自定义一个过滤器？" class="headerlink" title="vue如何自定义一个过滤器？"></a>vue如何自定义一个过滤器？</h1><p>html代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span> /&gt;</span></span><br><span class="line">     &#123;&#123;msg| capitalize &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JS代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm=<span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">msg</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">filters</span>: &#123;</span><br><span class="line">      <span class="attr">capitalize</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">        value = value.<span class="title function_">toString</span>()</span><br><span class="line">        <span class="keyword">return</span> value.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + value.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>全局定义过滤器:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;capitalize&#x27;</span>, <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  value = value.<span class="title function_">toString</span>()</span><br><span class="line">  <span class="keyword">return</span> value.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + value.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>过滤器接收表达式的值 (msg) 作为第一个参数。capitalize 过滤器将会收到 msg的值作为第一个参数。</p>
<h1 id="对keep-alive-的了解？"><a href="#对keep-alive-的了解？" class="headerlink" title="对keep-alive 的了解？"></a>对keep-alive 的了解？</h1><p>keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br>在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。</p>
<p>使用方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include=<span class="string">&#x27;include_components&#x27;</span> exclude=<span class="string">&#x27;exclude_components&#x27;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">component</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="comment">&lt;!-- 该组件是否缓存取决于include和exclude属性 --&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p>参数解释<br>include - 字符串或正则表达式，只有名称匹配的组件会被缓存<br>exclude - 字符串或正则表达式，任何名称匹配的组件都不会被缓存<br>include 和 exclude 的属性允许组件有条件地缓存。二者都可以用“，”分隔字符串、正则表达式、数组。当使用正则或者是数组时，要记得使用v-bind 。</p>
<p>使用示例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 逗号分隔字符串，只有组件a与b被缓存。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;a,b&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 正则表达式 (需要使用 v-bind，符合匹配规则的都会被缓存) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;/a|b/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Array (需要使用 v-bind，被包含的都会被缓存) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="一句话就能回答的面试题"><a href="#一句话就能回答的面试题" class="headerlink" title="一句话就能回答的面试题"></a>一句话就能回答的面试题</h1><ol>
<li><p>css只在当前组件起作用<br>答：在style标签中写入scoped即可 例如：<code>&lt;style scoped&gt;&lt;/style&gt;</code></p>
</li>
<li><p>v-if 和 v-show 区别<br>答：v-if按照条件是否渲染，v-show是display的block或none；</p>
</li>
<li><p>$route和$router的区别<br>答：$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p>
</li>
<li><p>vue.js的两个核心是什么？<br>答：数据驱动、组件系统</p>
</li>
<li><p>vue几种常用的指令<br>答：v-for 、 v-if 、v-bind、v-on、v-show、v-else</p>
</li>
<li><p>vue常用的修饰符？<br>答：.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用</p>
</li>
<li><p>v-on 可以绑定多个方法吗？<br>答：可以</p>
</li>
<li><p>vue中 key 值的作用？<br>答：当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM。</p>
</li>
<li><p>什么是vue的计算属性？<br>答：在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。好处：①使得数据处理结构清晰；②依赖于数据，数据更新，处理结果自动更新；③计算属性内部this指向vm实例；④在template调用时，直接写计算属性名即可；⑤常用的是getter方法，获取数据，也可以使用set方法改变数据；⑥相较于methods，不管依赖的数据变不变，methods都会重新计算，但是依赖数据不变的时候computed从缓存中获取，不会重新计算。</p>
</li>
<li><p>vue等单页面应用及其优缺点<br>答：优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。<br>缺点：不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。</p>
</li>
<li><p>怎么定义 vue-router 的动态路由? 怎么获取传过来的值<br>答：在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.id 获取。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
        <category>Vue面试</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue面试</tag>
      </tags>
  </entry>
  <entry>
    <title>RunLoop相关知识点收集</title>
    <url>/iOS/RunLoop/index.html</url>
    <content><![CDATA[<p>首先是YY大神的理解<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmliaXJlbWUuY29tLzIwMTUvMDUvMTgvcnVubG9vcC8=">runloop<i class="fa fa-external-link-alt"></i></span><br>下面是收集的RunLoop相关知识点，一些应用场景<a href="./iOS/RunLoop/runloop.html">点击这里查看</a></p>
<p><a href="./iOS/RunLoop/runloopfanyi.html">官方文档翻译</a></p>
<h2 id="一、RunLoop概念"><a href="#一、RunLoop概念" class="headerlink" title="一、RunLoop概念"></a>一、RunLoop概念</h2><p>RunLoop是通过内部维护的<code>事件循环(Event Loop)</code>来对<code>事件/消息进行管理</code>的一个对象。</p>
<p>1、没有消息处理时，休眠已避免资源占用，由用户态切换到内核态(CPU-内核态和用户态)<br>2、有消息需要处理时，立刻被唤醒，由内核态切换到用户态</p>
<h3 id="RunLoop源码"><a href="#RunLoop源码" class="headerlink" title="RunLoop源码"></a>RunLoop源码</h3><ol>
<li>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</li>
<li>CFRunLoopRef 的代码是开源的，你可以在这里 <span class="exturl" data-url="aHR0cDovL29wZW5zb3VyY2UuYXBwbGUuY29tL3RhcmJhbGxzL0NGLw==">http://opensource.apple.com/tarballs/CF/<i class="fa fa-external-link-alt"></i></span> 下载到整个 CoreFoundation 的源码来查看。</li>
<li>Swift 开源后，苹果又维护了一个跨平台的 CoreFoundation 版本：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWNvcmVsaWJzLWZvdW5kYXRpb24vJUVGJUJDJThDJUU4JUJGJTk5JUU0JUI4JUFBJUU3JTg5JTg4JUU2JTlDJUFDJUU3JTlBJTg0JUU2JUJBJTkwJUU3JUEwJTgxJUU1JThGJUFGJUU4JTgzJUJEJUU1JTkyJThDJUU3JThFJUIwJUU2JTlDJTg5">https://github.com/apple/swift-corelibs-foundation/，这个版本的源码可能和现有<i class="fa fa-external-link-alt"></i></span> iOS 系统中的实现略不一样，但更容易编译，而且已经适配了 Linux/Windows。</li>
</ol>
<h3 id="为什么main函数不会退出？"><a href="#为什么main函数不会退出？" class="headerlink" title="为什么main函数不会退出？"></a>为什么main函数不会退出？</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UIApplicationMain内部默认开启了主线程的RunLoop，并执行了一段无限循环的代码（不是简单的for循环或while循环）</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无限循环代码模式(伪代码)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span> </span>&#123;        </span><br><span class="line">    BOOL running = YES;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 执行各种任务，处理各种事件</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (running);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UIApplicationMain函数一直没有返回，而是不断地接收处理消息以及等待休眠，所以运行程序之后会保持持续运行状态。</p>
<h2 id="二、RunLoop的数据结构"><a href="#二、RunLoop的数据结构" class="headerlink" title="二、RunLoop的数据结构"></a>二、RunLoop的数据结构</h2><p><code>NSRunLoop(Foundation)</code>是<code>CFRunLoop(CoreFoundation)</code>的封装，提供了面向对象的API<br>RunLoop 相关的主要涉及五个类：</p>
<p><code>CFRunLoop</code>：RunLoop对象<br><code>CFRunLoopMode</code>：运行模式<br><code>CFRunLoopSource</code>：输入源/事件源<br><code>CFRunLoopTimer</code>：定时源<br><code>CFRunLoopObserver</code>：观察者</p>
<p><strong>1、CFRunLoop</strong></p>
<p>由<code>pthread</code>(线程对象，说明<code>RunLoop和线程是一一对应</code>的)、<code>currentMode</code>(当前所处的运行模式)、<code>modes</code>(多个运行模式的集合)、<code>commonModes</code>(模式名称字符串集合)、<code>commonModelItems</code>(Observer,Timer,Source集合)构成</p>
<p><strong>2、CFRunLoopMode</strong></p>
<p>由name、source0、source1、observers、timers构成</p>
<p><strong>3、CFRunLoopSource</strong></p>
<p>分为source0和source1两种</p>
<ul>
<li><code>source0:</code><br>即非基于port的，也就是用户触发的事件。需要手动唤醒线程，将当前线程从内核态切换到用户态</li>
</ul>
<ul>
<li><code>source1:</code><br>基于port的，包含一个 mach_port 和一个回调，可监听系统端口和通过内核和其他线程发送的消息，能主动唤醒RunLoop，接收分发系统事件。<br>具备唤醒线程的能力</li>
</ul>
<p><strong>4、CFRunLoopTimer</strong></p>
<p>基于时间的触发器，基本上说的就是NSTimer。在预设的时间点唤醒RunLoop执行回调。因为它是基于RunLoop的，因此它不是实时的（就是NSTimer 是不准确的。 因为RunLoop只负责分发源的消息。如果线程当前正在处理繁重的任务，就有可能导致Timer本次延时，或者少执行一次）。</p>
<p><strong>5、CFRunLoopObserver</strong></p>
<p>监听以下时间点:<code>CFRunLoopActivity</code></p>
<ul>
<li><p><code>kCFRunLoopEntry</code><br>RunLoop准备启动</p>
</li>
<li><p><code>kCFRunLoopBeforeTimers</code><br>RunLoop将要处理一些Timer相关事件</p>
</li>
<li><p><code>kCFRunLoopBeforeSources</code><br>RunLoop将要处理一些Source事件</p>
</li>
<li><p><code>kCFRunLoopBeforeWaiting</code><br>RunLoop将要进行休眠状态,即将由用户态切换到内核态</p>
</li>
<li><p><code>kCFRunLoopAfterWaiting</code><br>RunLoop被唤醒，即从内核态切换到用户态后</p>
</li>
<li><p><code>kCFRunLoopExit</code><br>RunLoop退出</p>
</li>
<li><p><code>kCFRunLoopAllActivities</code><br>监听所有状态</p>
</li>
</ul>
<p><strong>6、各数据结构之间的联系</strong></p>
<p>线程和RunLoop一一对应， RunLoop和Mode是一对多的，Mode和source、timer、observer也是一对多的</p>
<h2 id="三、RunLoop的Mode"><a href="#三、RunLoop的Mode" class="headerlink" title="三、RunLoop的Mode"></a>三、RunLoop的Mode</h2><p>关于Mode首先要知道一个RunLoop 对象中可能包含多个Mode，且每次调用 RunLoop 的主函数时，只能指定其中一个 Mode(CurrentMode)。切换 Mode，需要重新指定一个 Mode 。主要是为了分隔开不同的 Source、Timer、Observer，让它们之间互不影响。</p>
<p>当RunLoop运行在Mode1上时，是无法接受处理Mode2或Mode3上的Source、Timer、Observer事件的</p>
<p>总共是有五种<code>CFRunLoopMode</code>:</p>
<ul>
<li><code>kCFRunLoopDefaultMode</code>：默认模式，主线程是在这个运行模式下运行</li>
<li><code>UITrackingRunLoopMode</code>：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）</li>
<li><code>UIInitializationRunLoopMode</code>：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用</li>
<li><code>GSEventReceiveRunLoopMode</code>：接受系统内部事件，通常用不到</li>
<li><code>kCFRunLoopCommonModes</code>：伪模式，不是一种真正的运行模式，是同步Source/Timer/Observer到多个Mode中的一种解决方案</li>
</ul>
<h2 id="四、RunLoop的实现机制"><a href="#四、RunLoop的实现机制" class="headerlink" title="四、RunLoop的实现机制"></a>四、RunLoop的实现机制</h2><p>对于RunLoop而言最核心的事情就是保证线程在没有消息的时候休眠，在有消息时唤醒，以提高程序性能。RunLoop这个机制是依靠系统内核来完成的（苹果操作系统核心组件Darwin中的Mach）。</p>
<p>RunLoop通过<code>mach_msg()</code>函数接收、发送消息。它的本质是调用函数<code>mach_msg_trap()</code>，相当于是一个系统调用，会触发内核状态切换。在用户态调用 <code>mach_msg_trap()</code>时会切换到内核态；内核态中内核实现的<code>mach_msg()</code>函数会完成实际的工作。<br>即基于port的source1，监听端口，端口有消息就会触发回调；而source0，要手动标记为待处理和手动唤醒RunLoop</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hNzY0YWFkMzE4NDc=">Mach消息发送机制<i class="fa fa-external-link-alt"></i></span><br>大致逻辑为：<br>1、通知观察者 RunLoop 即将启动。<br>2、通知观察者即将要处理Timer事件。<br>3、通知观察者即将要处理source0事件。<br>4、处理source0事件。<br>5、如果基于端口的源(Source1)准备好并处于等待状态，进入步骤9。<br>6、通知观察者线程即将进入休眠状态。<br>7、将线程置于休眠状态，由用户态切换到内核态，直到下面的任一事件发生才唤醒线程。</p>
<ul>
<li>一个基于 port 的Source1 的事件(图里应该是source0)。</li>
<li>一个 Timer 到时间了。</li>
<li>RunLoop 自身的超时时间到了。</li>
<li>被其他调用者手动唤醒。</li>
</ul>
<p>8、通知观察者线程将被唤醒。<br>9、处理唤醒时收到的事件。</p>
<ul>
<li>如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2。</li>
<li>如果输入源启动，传递相应的消息。</li>
<li>如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop。进入步骤2</li>
</ul>
<p>10、通知观察者RunLoop结束。</p>
<h2 id="五、RunLoop与NSTimer"><a href="#五、RunLoop与NSTimer" class="headerlink" title="五、RunLoop与NSTimer"></a>五、RunLoop与NSTimer</h2><p>一个比较常见的问题：滑动tableView时，定时器还会生效吗？<br>默认情况下RunLoop运行在<code>kCFRunLoopDefaultMode</code>下，而当滑动tableView时，RunLoop切换到<code>UITrackingRunLoopMode</code>，而Timer是在<code>kCFRunLoopDefaultMode</code>下的，就无法接受处理Timer的事件。<br>怎么去解决这个问题呢？把Timer添加到UITrackingRunLoopMode上并不能解决问题，因为这样在默认情况下就无法接受定时器事件了。<br>所以我们需要把Timer同时添加到<code>UITrackingRunLoopMode</code>和<code>kCFRunLoopDefaultMode</code>上。<br>那么如何把timer同时添加到多个mode上呢？就要用到<code>NSRunLoopCommonModes</code>了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[[NSRunLoop currentRunLoop]</span> addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>

<p>Timer就被添加到多个mode上，这样即使RunLoop由<code>kCFRunLoopDefaultMode</code>切换到<code>UITrackingRunLoopMode</code>下，也不会影响接收Timer事件</p>
<p>CFRunLoopTimerRef与NSTimer是 toll-free bridged的</p>
<ol>
<li>对于重复的NSTimer，其多次触发的时刻不是一开始算好的，而是timer触发后计算的。但是计算时参考的是上次应当触发的时间_fireTSR，因此计算出的下次触发的时刻不会有误差。</li>
<li>设置了tolerance的NSTimer，对于iOS和MacOS系统，实质上会采用GCD timer的形式注册到内核中，GCD timer触发后，再由RunLoop处理其回调逻辑。对于没有设置tolerance的timer，则是用mk_timer的形式注册。</li>
<li>RunLoopMode中timer的排序是按照_fireTSR，也就是应当触发的时间排序的。而且，出于对于保证timer严格有序的考虑，保证时间考前的tolerance较大的timer不会影响后面的timer，系统在给GCD timer 传dummy字段时候会保证_fireTSR+dummy小于后面timer的最晚触发时间。</li>
<li>RunLoop层在timer触发后进行回调的时候，不会对tolerance进行验证。也就是说，因为RunLoop忙导致的timer触发时刻超出了tolerance的情况下，timer并不会取消，而不执行回调。</li>
<li>对于RunLoop忙时很长（或者timeInteval很短）的情况，会导致本该在这段时间内触发的几次回调中，只触发一次，也就是说，这种情况下还是会损失回调的次数。</li>
<li>对于RunLoop比较忙的情况，timer的回调时刻有可能不准，且不会受到tolerance的任何限制。tolerance的作用不是决定timer是否触发的标准，而是一个传递给系统的数值，帮助系统合理的规划GCD Timer的mach-port触发时机。设置了tolerance，一定会损失一定的时间精确度，但是可以显著的降低耗电。<br>CFAbsoluteTimeGetCurrent()获取准确的时间</li>
</ol>
<p>请看下节  Runloop 运行</p>
<blockquote>
<p><a href="./iOS/RunLoop/runloopyunxing.html">Runloop 运行</a></p>
</blockquote>
]]></content>
      <categories>
        <category>iOS</category>
        <category>RunLoop</category>
      </categories>
      <tags>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>RunLoop的一些场景</title>
    <url>/iOS/RunLoop/runloop.html</url>
    <content><![CDATA[<h2 id="一、autoreleasePool-在何时被释放？"><a href="#一、autoreleasePool-在何时被释放？" class="headerlink" title="一、autoreleasePool 在何时被释放？"></a>一、<code>autoreleasePool</code> 在何时被释放？</h2><p><code>App</code>启动后，苹果在主线程 <code>RunLoop</code> 里注册了两个 <code>Observer</code>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p>
<p>第一个 <code>Observer</code> 监视的事件是 <code>Entry(即将进入Loop)</code>，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 <code>order</code> 是 <code>-2147483647</code>，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 <code>Observer</code> 监视了两个事件： <code>BeforeWaiting</code>(准备进入休眠) 时调用<code>_objc_autoreleasePoolPop()</code>  和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；<code>Exit</code>(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。这个 <code>Observer</code> 的 <code>order</code> 是 <code>2147483647</code>，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、<code>Timer</code>回调内的。这些回调会被 <code>RunLoop</code> 创建好的 <code>AutoreleasePool</code> 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 <code>Pool</code> 了。</p>
<h2 id="二、PerformSelector-的实现原理？"><a href="#二、PerformSelector-的实现原理？" class="headerlink" title="二、PerformSelector 的实现原理？"></a>二、<code>PerformSelector</code> 的实现原理？</h2><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h2 id="三、PerformSelector-afterDelay-这个方法在子线程中是否起作用？为什么？怎么解决？"><a href="#三、PerformSelector-afterDelay-这个方法在子线程中是否起作用？为什么？怎么解决？" class="headerlink" title="三、PerformSelector:afterDelay:这个方法在子线程中是否起作用？为什么？怎么解决？"></a>三、<code>PerformSelector:afterDelay:</code>这个方法在子线程中是否起作用？为什么？怎么解决？</h2><p>不起作用，子线程默认没有 <code>Runloop</code>，也就没有 <code>Timer</code>。</p>
<p>解决的办法是可以使用 <code>GCD</code> 来实现：<code>Dispatch_after</code></p>
<h2 id="四、为什么-NSTimer-有时候不好使？"><a href="#四、为什么-NSTimer-有时候不好使？" class="headerlink" title="四、为什么 NSTimer 有时候不好使？"></a>四、为什么 <code>NSTimer</code> 有时候不好使？</h2><p>因为创建的  <code>NSTimer</code> 默认是被加入到了 <code>defaultMode</code>，所以当 <code>Runloop</code> 的 <code>Mode</code> 变化时，当前的 <code>NSTimer</code> 就不会工作了。</p>
<h2 id="五、解释一下-GCD-在-Runloop-中的使用？"><a href="#五、解释一下-GCD-在-Runloop-中的使用？" class="headerlink" title="五、解释一下 GCD 在 Runloop 中的使用？"></a>五、解释一下 <code>GCD</code> 在 <code>Runloop</code> 中的使用？</h2><p><code>GCD</code>由 子线程 返回到 主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。</p>
<h2 id="六、解释一下-NSTimer。"><a href="#六、解释一下-NSTimer。" class="headerlink" title="六、解释一下 NSTimer。"></a>六、解释一下 <code>NSTimer</code>。</h2><p><code>NSTimer</code> 其实就是 <code>CFRunLoopTimerRef</code>，他们之间是 <code>toll-free bridged</code> 的。一个 <code>NSTimer</code> 注册到 <code>RunLoop</code> 后，<code>RunLoop</code> 会为其重复的时间点注册好事件。例如 <code>10:00</code>, <code>10:10</code>, <code>10:20</code> 这几个时间点。<code>RunLoop</code> 为了节省资源，并不会在非常准确的时间点回调这个<code>Timer</code>。<code>Timer</code> 有个属性叫做 <code>Tolerance</code> (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p><code>CADisplayLink</code> 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 <code>Source</code>）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 <code>NSTimer</code> 相似），造成界面卡顿的感觉。在快速滑动 <code>TableView</code> 时，即使一帧的卡顿也会让用户有所察觉。<code>Facebook</code> 开源的 <code>AsyncDisplayLink</code> 就是为了解决界面卡顿的问题，其内部也用到了 <code>RunLoop</code>。</p>
<h2 id="七、等待补充中。。。"><a href="#七、等待补充中。。。" class="headerlink" title="七、等待补充中。。。"></a>七、等待补充中。。。</h2><ul>
<li>Timer</li>
<li>autoreleasePool创建</li>
<li>线程保活</li>
<li>检测卡顿</li>
<li>scrollview的更新 TrackingRunloopMode下不做操作，添加到 defaultmode下</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
        <category>RunLoop</category>
        <category>RunLoop的一些场景</category>
      </categories>
      <tags>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>RunLoop的运行</title>
    <url>/iOS/RunLoop/runloopyunxing.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>iOS</category>
        <category>RunLoop</category>
        <category>RunLoop的运行</category>
      </categories>
      <tags>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>RunTime知识</title>
    <url>/iOS/RunTime/index.html</url>
    <content><![CDATA[<p>这里主要收集RunTime相关东西</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jMTc5M2JjMmNhMTM=">为什么会有元类<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="如何运用-Runtime-进行模型的归解档"><a href="#如何运用-Runtime-进行模型的归解档" class="headerlink" title="如何运用 Runtime 进行模型的归解档"></a>如何运用 <code>Runtime</code> 进行模型的归解档</h2><p><code>Runtime</code> 遍历 <code>ivar_list</code>。</p>
<h2 id="如何运用-Runtime-字典转模型？"><a href="#如何运用-Runtime-字典转模型？" class="headerlink" title="如何运用 Runtime 字典转模型？"></a>如何运用 <code>Runtime</code> 字典转模型？</h2><p><code>Runtime</code> 遍历 <code>ivar_list</code>,结合 <code>KVC</code> 赋值。</p>
<h2 id="如何给-Category-添加属性？关联对象以什么形式进行存储？"><a href="#如何给-Category-添加属性？关联对象以什么形式进行存储？" class="headerlink" title="如何给 Category 添加属性？关联对象以什么形式进行存储？"></a>如何给 <code>Category</code> 添加属性？关联对象以什么形式进行存储？</h2><p>查看的是 <code>关联对象</code> 的知识点。</p>
<p>详细的说一下 <code>关联对象</code>。<br><code>关联对象</code> 以哈希表的格式，存储在一个全局的单例中。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Extension</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>  ) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    </span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>,<span class="keyword">@selector</span>(name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="什么时候会报unrecognized-selector的异常？"><a href="#什么时候会报unrecognized-selector的异常？" class="headerlink" title="什么时候会报unrecognized selector的异常？"></a>什么时候会报unrecognized selector的异常？</h2><p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，会进入消息转发阶段，如果消息三次转发流程仍未实现，则程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。</p>
<h2 id="runtime如何实现weak变量的自动置nil？知道SideTable吗？"><a href="#runtime如何实现weak变量的自动置nil？知道SideTable吗？" class="headerlink" title="runtime如何实现weak变量的自动置nil？知道SideTable吗？"></a>runtime如何实现weak变量的自动置nil？知道SideTable吗？</h2><blockquote>
<p>runtime 对注册的类会进行布局，对于 weak 修饰的对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。</p>
</blockquote>
<p><strong>更细一点的回答：</strong></p>
<p>1.初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。<br>2.添加引用时：objc_initWeak函数会调用objc_storeWeak() 函数， objc_storeWeak()的作用是更新指针指向，创建对应的弱引用表。<br>3.释放时,调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</p>
<p>SideTable结构体是负责管理类的引用计数表和weak表，</p>
<p>详解：参考自《Objective-C高级编程》一书<br><strong>1.初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    NSObject *obj <span class="operator">=</span> [[NSObject alloc] init]<span class="comment">;</span></span><br><span class="line">    id __weak obj1 <span class="operator">=</span> obj<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们初始化一个weak变量时，runtime会调用 NSObject.mm 中的objc_initWeak函数。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器的模拟代码</span></span><br><span class="line"> id obj1;</span><br><span class="line"> objc<span class="constructor">_initWeak(&amp;<span class="params">obj1</span>, <span class="params">obj</span>)</span>;</span><br><span class="line"><span class="comment">/*obj引用计数变为0，变量作用域结束*/</span></span><br><span class="line"> objc<span class="constructor">_destroyWeak(&amp;<span class="params">obj1</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>通过objc_initWeak函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过objc_destoryWeak函数释放该变量（obj1）。</p>
<p><strong>2.添加引用时：objc_initWeak函数会调用objc_storeWeak() 函数， objc_storeWeak()的作用是更新指针指向，创建对应的弱引用表。</strong></p>
<p>objc_initWeak函数将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用objc_storeWeak函数。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">obj1 = <span class="number">0</span>；</span><br><span class="line">obj<span class="constructor">_storeWeak(&amp;<span class="params">obj1</span>, <span class="params">obj</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>也就是说：</strong></p>
<p>weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）</p>
<p>然后obj_destroyWeak函数将0（nil）作为参数，调用objc_storeWeak函数。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">objc<span class="constructor">_storeWeak(&amp;<span class="params">obj1</span>, 0)</span>;</span><br></pre></td></tr></table></figure>
<p>前面的源代码与下列源代码相同。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器的模拟代码</span></span><br><span class="line">id obj1;</span><br><span class="line">obj1 = <span class="number">0</span>;</span><br><span class="line">objc<span class="constructor">_storeWeak(&amp;<span class="params">obj1</span>, <span class="params">obj</span>)</span>;</span><br><span class="line"><span class="comment">/* ... obj的引用计数变为0，被置nil ... */</span></span><br><span class="line">objc<span class="constructor">_storeWeak(&amp;<span class="params">obj1</span>, 0)</span>;</span><br></pre></td></tr></table></figure>
<p>objc_storeWeak函数把第二个参数的赋值对象（obj）的内存地址作为键值，将第一个参数__weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除。</p>
<p>由于一个对象可同时赋值给多个附有__weak修饰符的变量中，所以对于一个键值，可注册多个变量的地址。</p>
<p>可以把objc_storeWeak(&amp;a, b)理解为：objc_storeWeak(value, key)，并且当key变nil，将value置nil。在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</p>
<p><strong>3.释放时,调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。</strong></p>
<p>当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？当释放对象时，其基本流程如下：</p>
<p>1.调用objc_release<br>2.因为对象的引用计数为0，所以执行dealloc<br>3.在dealloc中，调用了_objc_rootDealloc函数<br>4.在_objc_rootDealloc中，调用了object_dispose函数<br>5.调用objc_destructInstance<br>6.最后调用objc_clear_deallocating</p>
<p>对象被释放时调用的objc_clear_deallocating函数:</p>
<p>1.从weak表中获取废弃对象的地址为键值的记录<br>2.将包含在记录中的所有附有 weak修饰符变量的地址，赋值为nil<br>3.将weak表中该记录删除<br>4.从引用计数表中删除废弃对象的地址为键值的记录</p>
<p><strong>总结:</strong></p>
<p>其实Weak表是一个hash（哈希）表，Key是weak所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象指针的地址）数组。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>RunTime</category>
      </categories>
      <tags>
        <tag>RunTime</tag>
      </tags>
  </entry>
  <entry>
    <title>scrollView左右上下单方向滑动下问题</title>
    <url>/iOS/ScrollView/index.html</url>
    <content><![CDATA[<h1 id="解决iOS的scrollView属性directionalLockEnabled的问题修正"><a href="#解决iOS的scrollView属性directionalLockEnabled的问题修正" class="headerlink" title="解决iOS的scrollView属性directionalLockEnabled的问题修正"></a>解决iOS的scrollView属性directionalLockEnabled的问题修正</h1><p>苹果官方文档说明</p>
<blockquote>
<p>“If this property is NO, scrolling is permitted in both horizontal and vertical directions. If this property is YES and the user begins dragging in one general direction (horizontally or vertically), the scroll view disables scrolling in the other direction. If the drag direction is diagonal, then scrolling will not be locked and the user can drag in any direction<br>until the drag completes. The default value is NO”</p>
</blockquote>
<p>问题出现了，当你斜着滑动的时候，这个属性就失效了，就会出现斜着滑动的情况</p>
<h2 id="解决办法如下："><a href="#解决办法如下：" class="headerlink" title="解决办法如下："></a>解决办法如下：</h2><span id="more"></span>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGPoint</span> scrollViewStartPosPoint;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="type">int</span>     scrollDirection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> scrollViewStartPosPoint = _scrollViewStartPosPoint;</span><br><span class="line"><span class="keyword">@synthesize</span> scrollDirection = _scrollDirection;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame</span><br><span class="line">&#123;</span><br><span class="line">     _scrollDirection = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.scrollDirection == <span class="number">0</span>)&#123;<span class="comment">//we need to determine direction</span></span><br><span class="line">        <span class="comment">//use the difference between positions to determine the direction.</span></span><br><span class="line">        <span class="keyword">if</span> (abs(<span class="keyword">self</span>.scrollViewStartPosPoint.x-scrollView.contentOffset.x)&lt;</span><br><span class="line">            abs(<span class="keyword">self</span>.scrollViewStartPosPoint.y-scrollView.contentOffset.y))&#123;</span><br><span class="line">            <span class="comment">//Vertical Scrolling</span></span><br><span class="line">            <span class="keyword">self</span>.scrollDirection = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//Horitonzal Scrolling</span></span><br><span class="line">            <span class="keyword">self</span>.scrollDirection = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Update scroll position of the scrollview according to detected direction.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.scrollDirection == <span class="number">1</span>) &#123;</span><br><span class="line">        scrollView.contentOffset = <span class="built_in">CGPointMake</span>(<span class="keyword">self</span>.scrollViewStartPosPoint.x,scrollView.contentOffset.y);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.scrollDirection == <span class="number">2</span>)&#123;</span><br><span class="line">        scrollView.contentOffset = <span class="built_in">CGPointMake</span>(scrollView.contentOffset.x,<span class="keyword">self</span>.scrollViewStartPosPoint.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.scrollViewStartPosPoint = scrollView.contentOffset;</span><br><span class="line">    <span class="keyword">self</span>.scrollDirection = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)scrollViewDidEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView willDecelerate:(<span class="type">BOOL</span>)decelerate </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (decelerate) &#123;</span><br><span class="line">        <span class="keyword">self</span>.scrollDirection =<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)scrollViewDidEndDecelerating:(<span class="built_in">UIScrollView</span> *)scrollView </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.scrollDirection =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="variable language_">super</span> touchesBegan:touches withEvent:event]; <span class="comment">// always forward touchesBegan -- there&#x27;s no way to forward it later</span></span><br><span class="line"><span class="comment">//    if (_isHorizontalScroll)</span></span><br><span class="line"><span class="comment">//        return; // UIScrollView is in charge now</span></span><br><span class="line"><span class="comment">//    if ([touches count] == [[event touchesForView:self] count]) &#123; // initial touch</span></span><br><span class="line"><span class="comment">//        _originalPoint = [[touches anyObject] locationInView:self];</span></span><br><span class="line"><span class="comment">//        _currentChild = [self honestHitTest:_originalPoint withEvent:event];</span></span><br><span class="line"><span class="comment">//        _isMultitouch = NO;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    _isMultitouch |= ([[event touchesForView:self] count] &gt; 1);</span></span><br><span class="line"><span class="comment">//    [_currentChild touchesBegan:touches withEvent:event];</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">     [<span class="variable language_">super</span> touchesMoved:touches withEvent:event];</span><br><span class="line"><span class="comment">//    if (!_isHorizontalScroll &amp;&amp; !_isMultitouch) &#123;</span></span><br><span class="line"><span class="comment">//        CGPoint point = [[touches anyObject] locationInView:self];</span></span><br><span class="line"><span class="comment">//        if (fabsf(_originalPoint.x - point.x) &gt; kThresholdX &amp;&amp; fabsf(_originalPoint.y - point.y) &lt; kThresholdY) &#123;</span></span><br><span class="line"><span class="comment">//            _isHorizontalScroll = YES;</span></span><br><span class="line"><span class="comment">//            [_currentChild touchesCancelled:[event touchesForView:self] withEvent:event]</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    if (_isHorizontalScroll)</span></span><br><span class="line"><span class="comment">//        [super touchesMoved:touches withEvent:event]; // UIScrollView only kicks in on horizontal scroll</span></span><br><span class="line"><span class="comment">//    else</span></span><br><span class="line"><span class="comment">//        [_currentChild touchesMoved:touches withEvent:event];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>scrollView</tag>
      </tags>
  </entry>
  <entry>
    <title>RunLoop翻译</title>
    <url>/iOS/RunLoop/runloopfanyi.html</url>
    <content><![CDATA[<p>这是一篇对Run Loop开发文档《Threading Program Guide:Run Loops》的翻译，来源于苹果开发文档。</p>
<p>Run loops 是和线程相关的基础部分。一个run loop是一个用来调度工作和协调接受的事件的循环。一个run loop的目的是有任务的时候保持线程忙碌，没有任务的时候线程休眠。</p>
<p>Runloop的管理并不是完全自动的，你必须编写线程代码在合适的时间点启动runloop，并且响应接收的事件。Cocoa和Core框架都提供了runloop对象供开发者配置和管理线程的runloop。然而你的应用显示不需要创建这些对象，app的框架在程序启动的过程中已经自动设置并且运行了在主线程的runloop。</p>
<p>下面的章节提供了更多关于run loops和怎么在应用中配置run loops的信息，更多的关于runloop 对象的信息查看NSRunLoop Class Reference和CFRunLoop Reference</p>
<h2 id="Run-Loop解析"><a href="#Run-Loop解析" class="headerlink" title="Run Loop解析"></a>Run Loop解析</h2><p>一个run loop和它的名字听起来非常相似，它是一个你的线程进入的循环，并且用户使用它运行事件处理程序来应答事件。 你的代码控制实现runloop的真正的循环部分。换句话说，你的代码提供了for或者while用来驱动run loop。在你的循环内，你使用一个run loop对象来启动事件处理代码—-这些代码能够接收事件并且调用已安装的事件处理程序。</p>
<p>runloop接收的事件来自两个不同类型的源，input source负责分发异步事件，消息通常来自其他的线程或者一个不同的应用程序。timer source 分发同步事件，这些事件发生在计划的时间点或者重复的时间间隔。两种类型的事件源都用一个应用程序特定的程序处理方式来处理到来的事件。</p>
<p>图标3-1展示了runloop和各种各样的事件源的概念结构，输入源异步地将事件发送给相应的处理程序，并且导致 runUntilDate:方法被在特定线程相关的run loop调用使得runloop终止，定时器源会给把事件传递给处理程序，但是不会导致runloop的终止。</p>
<p>图略，自己查看<br>除了处理输入源，run loops也会生成关于run loop的行为的通知，注册run-loop 观察者可以接收这些通知并且可以使用这些通知在线程上做额外的处理。你可以使用Core Foundation在线程上添加run loop观察者。</p>
<p>下面的节提供了更多关于run loop组成和run loop处理模式的信息，同样描述了runloop在处理事件的不同时刻获取到的通知。</p>
<h2 id="Run-Loop模式"><a href="#Run-Loop模式" class="headerlink" title="Run Loop模式"></a>Run Loop模式</h2><p>一个run loop模式是一个将要被监听额输入源和定时器的集合，以及等待run loop通知的观察者集合。你每次启动run loop，你显示或者隐士的指定一个“模式”来运行，在run loop的运行过程中，只有和指定模式相关的源才会被监听和分发它们的事件（相似的，只有和指定模式关联的观察者才能获得run loop运行进度的通知），和其他模式相关的输入源会将任何接收到的事件保存起来，直到后来以合适的模式运行run loop。</p>
<p>在你的代码中，你可以通过名字识别运行模式，Cocoa和Core Foundation都定义了一个默认的模式和其他几个通用的模式，可以通过字符串在代码中指定。你可以通过简单为自定义的模式指定字符串名的方式实现自定义模式。虽然你在自定义模式下赋值的名字是任意的，但是这些模式的内容却不是随意的，你必须确保为你创建的模式添加一个或多个输入源、定时器或者run loop观察者，这样自定义的模式才会可用。</p>
<p>你使用模式可以在特定run loop运行中过滤掉不想要的源的事件。大多数情况下，你会在“default”模式运行代码。一个模态的面板，然而可能运行在“modal”模式下，因为在这种模式下，只有和模态面板相关的源才能够把事件传递到线程上。（这里是Mac开发的吧，不理解） ,对于次要的线程，你可以使用自定义的模式阻止低优先级的输入源在时间要求比较严格的操作期间传递事件。</p>
<blockquote>
<p>注意:模式和事件的输入源要区别对待，模式不是事件的类型。比如：你不能使用模式去单独匹配鼠标按下事件或者单独匹配键盘事件。你可以使用模式来监听一组不同的端口（ports）,暂时挂起定时器。也可以改变正在被监控的源和run loop的观察者。</p>
</blockquote>
<p>表3-1列举了Cocoa和Core Foundationd的标准模式和使用的描述信息，name这一栏列举了在代码中指定模式所使用的常量。图略。。。</p>
<p><code>Default</code>:大多数操作都使用的模式，大多数情况下你应该在这个模式下开启run loop，配置输入源。</p>
<p><code>Connection</code>:Cocoa使用这个模式结合NSConnection对象来检查依赖。你自己几乎不会用到这种模式</p>
<p><code>Modal</code>：Cocoa使用这个模式区分发送到模态面板的事件。</p>
<p><code>Event tracking</code>:Cocoa用这个模式在鼠标拖拽和其他类型用户界面操作跟踪过程中限制输入的事件。</p>
<p><code>Common modes</code>:这是一个可以通常使用的模式的课配置的组合，和这个模式相关的输入源同样会和组里面的任意一个模式关联。对于Cocoa application，这个组默认包含了default、modal、event tracking模式，Core Foundation初始化时仅仅包含了default模式，你可以使用CFRunLoopAddCommonMode 添加自定义的模式。</p>
<h2 id="输入源"><a href="#输入源" class="headerlink" title="输入源"></a>输入源</h2><p>输入源异步的向你的线程分发事件，事件的来源取决于输入源的类型，通常是两种类型的一种，基于端口的输入源监控你的应用程序的Mach端口，自定义的输入源监控自定义事件源。就你的run loop而言，它不会关心一个输入源是自定义还是基于端口的。系统通常会实现两种输入源，你只管使用就可以了。两种输入源的唯一区别是他们的信号是怎么获得的。基于端口的源由内核发送信号，自定义的源必须手动的在其他线程发信号。</p>
<p>当你创建了一个输入源，你给它指定一种或者多种运行模式，模式决定了那些输入源在任意给定的时刻会被监视。大多数时间你在default模式下运行，但是也可以指定自定义的模式。如果一个输入源并不在当前模式的监视范围，它产生的任意事件都会被保存直到run loop运行在正确的模式。</p>
<h3 id="基于端口的源"><a href="#基于端口的源" class="headerlink" title="基于端口的源"></a>基于端口的源</h3><p>Cocoa和Core Foundation为使用端口相关对象和功能创建基于端口的输入源提供内置支持，比如在Cocoa里面，你从来不需要直接创建输入源，你只需要创建一个端口对象，调用NSPort的方法在run loop上添加端口，端口对象处理需要的输入源的创建和配置。</p>
<p>在Core Foundation，你必须手动的创建端口和run loop输入源。在创建端口和输入源的情况下，需要使用和对外不透透明的(开发文档没有描述)的类型（CFMachPortRef, CFMessagePortRef, or CFSocketRef）相关的函数创建合适的对象。</p>
<p>比如怎么创建一个和配置一个定制的基于端口的输入源，参考 7.7 配置基于端口的输入源</p>
<h3 id="自定义输入源"><a href="#自定义输入源" class="headerlink" title="自定义输入源"></a>自定义输入源</h3><p>创建一个定制的输入源，必须使用在Core Foundation中不透明类CFRunLoopSourceRef相关的函数，配置定制的输入源用到几个回调函数。Core Foundation会在不同的点调用这些函数配置源、处理到来的事件、在源从run loop移除的时候销毁源。</p>
<p>除了定义自定输入源在事件到来时的行为，你必须也定义事件的传递机制，输入源的这部分运行在一个单独的线程上，并且负责提供输入源的数据、在数据准备处理的时候发信号给输入源。事件的传递机制取决于你，但是不需要过于复杂。</p>
<p>有关如何创建自定义输入源的示例，请7.1 定义一个自定义的输入源。有关自定义输入源的参考信息，请参阅“CFRunLoopSource”。</p>
<h3 id="Cocoa执行消息选择器源–（Cocoa-Perform-Selector-Sources）"><a href="#Cocoa执行消息选择器源–（Cocoa-Perform-Selector-Sources）" class="headerlink" title="Cocoa执行消息选择器源–（Cocoa Perform Selector Sources）"></a>Cocoa执行消息选择器源–（Cocoa Perform Selector Sources）</h3><p>除了基于端口的输入源，Cocoa定义了一个自定义的输入源允许你在任意线程上执行selector的，就像基于端口的输入源，在目标线程上执行selector的请求被序列化了，减少了许多在多个方法同时执行在一个线程的情况下发生的同步问题。和基于端口不同的是，一个perform selector输入源在执行完selector后会自动把自己从run loop移除。</p>
<p>在10.5 之前的OS X上，perform selector 输入源主要给主线程发信息，在OS X10.5之后，可以给任意线程发消息。</p>
<p>当在线程上执行一个selector的时候，该线程必须有一个活跃的run loop，对于你创建的线程，这意味着一直等待到你的代码显示的开启run loop。因为主线程已经开启它的run loop了，所以程序一调用applicationDidFinishLaunching:就向该线程发出调用，run loop每进行一次循环就会处理队列化的perform selector的调用，而不是每次run loop循环处理队列中的选一个处理。</p>
<p>表3-2列举了定义在NSObject可以在其他线程上执行selecors的方法,因为这些方法定义在NSObject类里面，你可以在任何你可以访问到Objective-C对象的线程中使用，包括POSIX线程。这些方法实际上并不创建新的线程去执行selector。  </p>
<p>表略。。。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">performSelectorOnMainThread:withObject:waitUntilDone:</span><br><span class="line">performSelectorOnMainThread:withObject:waitUntilDone:modes:</span><br></pre></td></tr></table></figure>

<p>执行特定的selector在主线程的下一个run loop回路。这两个方法给你提供了选项来阻断当前线程直到selector被执行完毕。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">performSelector:onThread:withObject:waitUntilDone:</span><br><span class="line">performSelector:onThread:withObject:waitUntilDone:modes:</span><br></pre></td></tr></table></figure>

<p>执行特定的selector在任意线程上，这些线程通过NSThread对象表示。同样提供了阻断当前线程直到selector被执行。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">performSelector:withObject:afterDelay:</span><br><span class="line">performSelector:withObject:afterDelay:inModes:</span><br></pre></td></tr></table></figure>

<p>在当前线程上下一个run loop回路中执行selector，并附加了延迟选项。因为它等待下一个run loop回路到来才执行selector，这些方法从当前执行的代码中提供了一个自动的微小延迟。多个排队的selector会按照顺序一个一个的执行。</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="symbol">cancelPreviousPerformRequestsWithTarget:</span></span><br><span class="line"><span class="symbol">cancelPreviousPerformRequestsWithTarget:</span>selector:<span class="type">object</span>:</span><br></pre></td></tr></table></figure>

<p>让你取消一个通过performSelector:withObject:afterDelay: or performSelector:withObject:afterDelay:inModes: method方法发送到当前线程的消息。</p>
<p>每个方法更多详细信息见NSObject Class Reference.</p>
<h3 id="定时器源"><a href="#定时器源" class="headerlink" title="定时器源"></a>定时器源</h3><p>定时器源在一个未来预先设置的时间同步地传递事件给你的线程，定时器也是一种线程通知自己做某些事情的实现方式。比如一个搜索框可以使用一个定时器去初始化一个自动搜索，在用户用户连续输入关键字的时间间隔大于某个数时触发搜索。延时的使用给了用户一个在搜索开始之前尽可能多的去打印期望的关键字的机会。</p>
<p>虽然定时器产生了基于时间的通知，但是一个定时器并不是真正实时机制。就像输入源一样，定时器关联了你的run loop里的特定的模式。如果一个timer并不是处于run loop当前监控的模式，定时器在你以定时器支持的模式运行run loop之前就不会启动。</p>
<p>相似的，一个定时器如果在run loop执行处理代码的过程中开启了，定时器会等到下一次run loop调用它的处理程序。如果run loop没有运行，定时器永远不会启动。</p>
<p>你可以配置定时器一次或者重复的产生事件，一个重复的定时器自动的在一个预定的启动(fire)时间开始重复调度自己，并不是从真正的定时器fire的时间开始算。比如，一个定时器被设定在特定的时间点启动而且从那以后5秒钟一次。预定的fire时间将永远会落在于原来5s的时间间隔，如果真正的启动时间延迟。如果启动的时间延迟非常多以至于定时器错过了一次或多次预定的fire时间点，定时器只会在错过的时间片段内启动一次，在错过的时间段fire后，定时器会重新设定下次预设的fire时间。</p>
<p>配置定时器更多参考 7.6 配置定时器, NSTimer Class Reference or CFRunLoopTimer Reference.</p>
<h2 id="run-loop-观察者"><a href="#run-loop-观察者" class="headerlink" title="run loop 观察者"></a>run loop 观察者</h2><p>与输入源相反，当一个合适的同步或者异步事件发生时输入源会fire.而run loop观察者在run loop本身自己执行的过程中会在一个特殊的地方fire。你可以用run loop观察者让你的线程去处理一个给定的事件或者为run loop将要进入睡眠准备线程。你同样可以将run loop观察者和run loop下面的事件关联起来。</p>
<p>run loop的入口</p>
<p>run loop将要处理一个定时器</p>
<p>run loop 将要处理一个输入源</p>
<p>run loop 将要进入睡眠</p>
<p>run loop 已经唤醒，但是还没有处理唤醒run loop的事件</p>
<p>退出run loop</p>
<p>你可以给app用 Core Foundation 添加run loop观察者，创建一个run loop观察者，你创建了一个CFRunLoopObserverRef的类型的对象，这个类型持续跟踪你自定义的回调和它关心的run loop活动部分。</p>
<p>和定时器相似，run loop观察者可以重复或者单次使用，一个单次使用的观察者会在它fire后在run loop中移除，一个重复的观察者依然依附在run loop上。单次还是重复可以在创建的时候指定。</p>
<p>有关如何创建run loop 观察者的示例，请参阅6.2 配置run loop。有关参考信息，请参阅CFRunLoopObserver。</p>
<h2 id="run-loop一些列的事件"><a href="#run-loop一些列的事件" class="headerlink" title="run loop一些列的事件"></a>run loop一些列的事件</h2><p>每次你运行run loop，你的线程的run loop会处理挂起的事件，并且会给它的观察者发送通知。处理的顺序是非常特别的，就是下面顺序。</p>
<p>1.通知观察者run loop已经进入了循环。</p>
<p>2.通知观察者所有准备就绪的定时器将要 fire</p>
<p>3.通知观察者所有非基于端口的输入源将要 fire</p>
<p>4.fire所有非基于端口的准备fire的输入源</p>
<p>5.如果一个基于端口的输入源准备好了并且等待fire。立刻fire。到第9部。</p>
<p>6.通知观察者线程将要睡眠</p>
<p>7.将线程睡眠直到下面任意一个事件发生。</p>
<p>一个事件到达了基于端口的源</p>
<p>定时器fire</p>
<p>run loop设置了到期的超时事件</p>
<p>显示的指定run loop唤醒</p>
<p>8.通知观察者线程已经唤醒。</p>
<p>9.处理挂起的事件。</p>
<p>如果一个用户定义的定时器fire。处理定时器事件并且重新启动run loop。到步骤2.</p>
<p>如果一个输入源fire，传递事件。</p>
<p>如果run loop是被显示的被唤醒，但超时事件还没有到，重新启动run loop进入步骤2.</p>
<p>10.通知观察者run loop已经退出。</p>
<p>因为观察者从定时器和输入源来的通知会在那些事件实际发生之前被传递过来，可能在事件发生的时刻和收到通知的时刻之间有间隔，如果在事件上时效性是非常严格的，你可以使用睡眠和从睡眠中醒来的通知来帮助你关联事件之间的时间。</p>
<p>因为定时器和其他的周期性的事件会在你运行run loop的时候传递，所以要避免run loop对事件传递的打断。一个经典行为：每当你通过一个循环不断的从应用程序请求事件来实现一个鼠标的跟踪程序的时候。因为你的代码是直接捕获的事件，而不是让应用程序正常的分发这些事件，活跃的定时器将在你的鼠标跟踪程序退出并将控制权返回给应用程序后失效。</p>
<p>一个run loop可以用run loop对象显示的唤醒，其他的事件同样可以使run loop唤醒。比如添加其他的非基于端口的输入源可以唤醒run loop可以使得输入源可以立即被处理，而不是等到其他事件发生的时候。</p>
<h2 id="什么时候会用一个run-loop"><a href="#什么时候会用一个run-loop" class="headerlink" title="什么时候会用一个run loop"></a>什么时候会用一个run loop</h2><p>唯一需要显示的运行一个run loop的场景是在应用程序中创建了辅助线程。应用程序主线程的run loop是基础设施的关键部分。所以app的框架提供了运行主线程run loop的代码并且自动开启。iOS的UIAppliaction的run方法（或者OS X 的NSApplication）开启一个应用程序的main loop作为一些列程序启动流程的一部分。如果你使用xcode模板工程创建应用，你应该从来不显示的调用这些例程。</p>
<p>对于辅助线程，你需要决定一个run loop是不是必要的，如果是，就配置并开启它。你并不需要在任意情况下都开启一个线程的run loop。比如：如果你使用一个线程执行某些长时间运行并且是事先确定的任务，你可以避免开启run loop。run loops的目的是为了应用在你想和线程有更多的交互的场合上的。比如：如果你想做下面的任何事情你就需要开启run loop。</p>
<p>使用端口或者自定义的输入源和其他线程通信</p>
<p>在线程上使用定时器</p>
<p>在cocoa应用中使用任意一个performSelector…方法</p>
<p>使得线程不被杀死去做周期性任务</p>
<p>如果你选择使用一个run loop，配置和创建是非常简单的。和所有的线程编程一样，你为在合适的场合下结束你的辅助线程指定计划。通常来说让线程以结束的退出（exit）的方式要比强制让线程终止的办法好。怎么配置和退出run loop的描述信息在 6. 使用run loop对象.</p>
<h2 id="使用run-loop对象"><a href="#使用run-loop对象" class="headerlink" title="使用run loop对象"></a>使用run loop对象</h2><p>一个run loop对象提供了添加输入源，定时器，观察者和运行run loop的主要接口，每一个线程都单独有一个run loop对象和它关联。在 Cocoa中这个对象是NSRunLoop类的一个实例，在低层次的应用中，是一个CFRunLoopRef类型的指针。</p>
<p>6.1 获取一个run loop对象</p>
<p>获取当前线程的run loop只需要用下面的一种方法：</p>
<p>在Cocoa应用，使用NSRunLoop类的类方法currentRunLoop返回一个NSRunLoop对象</p>
<p>使用CFRunLoopGetCurrent函数</p>
<p>虽然这两个并不是可以自由的桥接类型，但是你在必要的时候可以从一个NSRunLoop对象中获取一个CFRunLoop类型。 通过NSRunLoop的getCFRunLoop方法获得，然后传递给Core Foundation的代码。因为两个对象引用了相同的run loop，你可以根据需要随意调用。</p>
<p>6.2 配置run loop</p>
<p>当你在一个辅助线程上开启run loop之前，必须给run loop添加至少一个输入源或者一个定时器。如果一个run loop没有任何源来监控，就会立刻退出。参考Configuring Run Loop Sources</p>
<p>除了添加输入源，你可以添加run loop观察者，并且使用他们监测run loop不同阶段的操作，添加观察者要创建一个 CFRunLoopObserverRef 类型的对象，用CFRunLoopAddObserve函数添加到run loop上。观察者必须用Core Foundation创建，即使在Cocoa应用中。</p>
<p>3-1是一个绑定了观察者的线程开启它的run loop的代码。这个案例主要展示怎么创建run loop观察者，所以代码只是简单的创建了一个观察者来监控run loop的所有的活动。基本的处理程序（没有展示）简单地在处理定时器请求的时候记录了run loop的活动。</p>
<p>Listing 3-1 Creating a run loop observer</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)threadMain</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The application uses garbage collection, so no autorelease pool is needed.</span></span><br><span class="line">    <span class="built_in">NSRunLoop</span>* myRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">    <span class="comment">// Create a run loop observer and attach it to the run loop.</span></span><br><span class="line">    <span class="built_in">CFRunLoopObserverContext</span>  context = &#123;<span class="number">0</span>, <span class="keyword">self</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="built_in">CFRunLoopObserverRef</span>    observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</span><br><span class="line">            kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, &amp;myRunLoopObserver, &amp;context);</span><br><span class="line">    <span class="keyword">if</span> (observer)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span>    cfLoop = [myRunLoop getCFRunLoop];</span><br><span class="line">        <span class="built_in">CFRunLoopAddObserver</span>(cfLoop, observer, kCFRunLoopDefaultMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Create and schedule the timer.</span></span><br><span class="line">    [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.1</span> target:<span class="keyword">self</span></span><br><span class="line">                selector:<span class="keyword">@selector</span>(doFireTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSInteger</span>    loopCount = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Run the run loop 10 times to let the timer fire.</span></span><br><span class="line">        [myRunLoop runUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1</span>]];</span><br><span class="line">        loopCount--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (loopCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当给长时间存在的线程配置run loop时，最好添加一个输入源来接收消息。即使你可以进入一个只有一个定时器的run loop，一旦定时器fire，就无效了。会导致run loop退出。绑定一个重复的定时器可以使得run loop在一个长的时间段运行。但是需要定期的触发定时器唤醒你的线程。这实际上是另一种形式的轮询。相反，一个输入源会等待事件的发生，在次之前会保持线程的休眠。</p>
<p>6.3 开启run loop</p>
<p>在应用中开启run loop仅仅对于辅助线程是必要的，run loop必须有至少一个输入源或者定时器去监控，如果一个都没有就会立刻结束。</p>
<p>下面是几种开启run loop的方法：</p>
<p>无条件的（Unconditionally）</p>
<p>带有时间限制设置的（With a set time limit）</p>
<p>在特定的模式下（In a particular mode）</p>
<p>无条件的进入run loop是最简单的选项，但是也是最不需要的。无条件的运行run loop将线程放在一个永久的循环中，对run loop本身的控制就非常少。你可以添加或者移除输入源或者定时器，但是唯一使得run loop停止的方式是杀死它，而且没有办法在定制的模式下运行run loop。</p>
<p>与其无条件启动run loop，不如给run loop设置一个超时时间运行反而更好。当你用一个超时时间值时，run loop会一直运行直到事件的到来或者分配的时间用完。如果一个事件到来了，事件就会被分发给处理程序去处理，然后run loop退出。如果分配的时间过期了，你可以简单的重启run loop或者花时间处理任何需要的事物。</p>
<p>除了设置超时事件值外，你也可以给run loop以指定的模式运行run loop，模式和超时时间值并不互斥，可以同时添加。模式限制了传递给run loop事件的输入源的类型。（详细信息1. Run Loop模式.）</p>
<p>3-2 是一个线程的主要代码结构，关键部分是这个案例展示了run loop的基本结构，实际上你可以给run loop添加自己的输入源和定时器然后重复的从多个程序例程中调用一个来启动run loop。每次run loop例程程序返回，你检查看看是否有任何可能导致线程结束的条件出现了。这个例子用了Core Foundation run loop程序，所以它可以检查返回结果并且知道为什么run loop退出了，如果你用Cocoa，同样可以用 NSRunLoop的方法以一个相似的方式运行run loop而且不用检查返回值，在3-14.</p>
<p>Listing 3-2 Running a run loop</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">- (void)skeletonThreadMain</span><br><span class="line">&#123;</span><br><span class="line">    <span class="regexp">//</span> Set up an autorelease pool here <span class="keyword">if</span> not using garbage collection.</span><br><span class="line">    BOOL done = NO;</span><br><span class="line">    <span class="regexp">//</span> Add your sources or timers to the run loop and <span class="keyword">do</span> any other setup.</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="regexp">//</span> Start the run loop but return after each source is handled.</span><br><span class="line">        SInt32    result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, <span class="number">10</span>, YES);</span><br><span class="line">        <span class="regexp">//</span> If a source explicitly stopped the run loop, or <span class="keyword">if</span> there are no</span><br><span class="line">        <span class="regexp">//</span> sources or timers, go ahead and <span class="keyword">exit</span>.</span><br><span class="line">        <span class="keyword">if</span> ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished))</span><br><span class="line">            done = YES;</span><br><span class="line">        <span class="regexp">//</span> Check <span class="keyword">for</span> any other <span class="keyword">exit</span> conditions here and set the</span><br><span class="line">        <span class="regexp">//</span> done variable as needed.</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!done);</span><br><span class="line">    </span><br><span class="line">    <span class="regexp">//</span> Clean up code here. Be sure to release any allocated autorelease pools.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归的运行一个run loop是有可能的，换句话说，你可以在输入源或者定时器的处理程序中调用CFRunLoopRun,CFRunLoopRunInMode,或者其他的任意的NSRunLoop方法。当这样做的时候，你可以使用任何你想要的模式运行嵌套的run loop，包括外层的run loop使用的模式。</p>
<p>6.4 退出 Run Loop</p>
<p>在使得一个run loop处理事件之前有两种办法结束run loop。</p>
<p>给run loop配置一个超时时间。</p>
<p>告诉run loop停止</p>
<p>使用超时时间当然是最好的，你可以管理它。指定超时时间让run loop结束它所有的在退出之前通常进行的操作，包括给观察者发通知。</p>
<p>用CFRunLoopStop函数显示的让run loop和通过设置超时时间产生的效果是相似的。run loop会发出所有剩下run loop相关的通知然后退出，区别在于你可以在无条件启动的run loop上使用这个技术</p>
<p>虽然移除run loop的输入源和定时器同样会导致run loop退出，但是这并不是一个可靠的停止run loop的方式。有些系统程序给run loop增加输入源处理必要的事件。因为你代码可能没有意识到这些输入源的存在，它不能移除掉这些输入源，这会阻止run loop的退出。</p>
<h2 id="线程安全和Run-Loop对象-7"><a href="#线程安全和Run-Loop对象-7" class="headerlink" title="线程安全和Run Loop对象 7"></a>线程安全和Run Loop对象 7</h2><p>线程安全的差异取决于你操作run loop所使用的API，在Core Foundation的函数通常是线程安全的，而且可以被任何线程调用。然而如果你在执行run loop配置的操作，尽可能的从该run loop对应的线程上操作依然是一个好的做法。</p>
<p>Cocoa的NSRunLoop类并不是像在Core Foundation中那样线程安全的，如果你使用NSRunLoop来修改你的run loop，你应该仅仅在run loop对应的那个线程上操作。添加一个输入源或者定时器给非当前线程的run loop会导致你的代码崩溃或者产生不可预测的行为。</p>
<h2 id="8-配置-Run-Loop-资源"><a href="#8-配置-Run-Loop-资源" class="headerlink" title="8. 配置 Run Loop 资源"></a>8. 配置 Run Loop 资源</h2><p>下面章节的代码是一些如何设置不同类型输入源的案例（Cocoa和Foundation）</p>
<ul>
<li>8.1 定义一个自定义的输入源</li>
</ul>
<p>创建一个自定义的输入源包含如下定义选项</p>
<p>输入源希望处理的信息</p>
<p>一个调度程序让感兴趣的客户（client）知道怎么和你的输入源取得联系</p>
<p>一个处理程序负责执行客户（client）发来的请求</p>
<p>一个取消程序让你输入源无效</p>
<p>因为你自己创建一个自定义的输入源来处理自定义的信息，实际的配置的设计是灵活的。调度程序和取消程序是关键程序，你的自定义输入源几乎总是需要的，剩下的大部分输入源行为发生在这些程序之外。比如你可以定义传递数据给你的输入源的机制和将输入源的存在传递给其他线程。</p>
<p>图3-2是一个自定义输入源配置的案例。这案例中程序的主线程维护对输入源、自定义输入源的自定义命令缓冲区、输入源所在的run loop的引用。当主线程有一个任务要交给工作线程的时候，它会向命令缓冲区发送一个命令和工作线程需要的所有开始任务所需要的信息。（因为主线程和工作线程都有访问命令缓冲区的权限，访问必须是同步的）一旦受到唤醒的命令，run loop调用输入源的处理程序来处理在命令缓冲区的命令。</p>
<p>3-2 操作一个自定义的输入源.png</p>
<p>下面的章节解释了上面图标自定义输入源的实现，和关键要实现的代码</p>
<ul>
<li>7.2 定义输入源</li>
</ul>
<p>自定义一个输入源需要用Core Foundation的代码来配置run loop资源，并且将它和run loop依附在一起。虽然基础的处理程序是C函数，但是并不排除你需要用OC或者C++来封装这些函数来实现你的代码主体。</p>
<p>图3-2中介绍的输入源使用了OC对象来管理一个命令行缓冲区，协调run loop。3-3展示的是这个对象的定义，RunLoopSource对象管理一个命令行缓冲区，用缓冲区接收其他线程的消息。3-3同样展示了RunLoopContext对象的定义，这是一个真正的用来传递一个RunLoopSource对象和run loop的引用到应用程序主线程的容器对象。</p>
<p>Listing 3-3 The custom input source object definition</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RunLoopSource</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopSourceRef</span> runLoopSource;</span><br><span class="line">    <span class="built_in">NSMutableArray</span>* commands;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)init;</span><br><span class="line">- (<span class="type">void</span>)addToCurrentRunLoop;</span><br><span class="line">- (<span class="type">void</span>)invalidate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handler method</span></span><br><span class="line">- (<span class="type">void</span>)sourceFired;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client interface for registering commands to process</span></span><br><span class="line">- (<span class="type">void</span>)addCommand:(<span class="built_in">NSInteger</span>)command withData:(<span class="type">id</span>)data;</span><br><span class="line">- (<span class="type">void</span>)fireAllCommandsOnRunLoop:(<span class="built_in">CFRunLoopRef</span>)runloop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// These are the CFRunLoopSourceRef callback functions.</span></span><br><span class="line"><span class="type">void</span> RunLoopSourceScheduleRoutine (<span class="type">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line"><span class="type">void</span> RunLoopSourcePerformRoutine (<span class="type">void</span> *info);</span><br><span class="line"><span class="type">void</span> RunLoopSourceCancelRoutine (<span class="type">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// RunLoopContext is a container object used during registration of the input source.</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RunLoopContext</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span>        runLoop;</span><br><span class="line">    RunLoopSource*        source;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">CFRunLoopRef</span> runLoop;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) RunLoopSource* source;</span><br><span class="line"></span><br><span class="line">- (<span class="type">id</span>)initWithSource:(RunLoopSource*)src andLoop:(<span class="built_in">CFRunLoopRef</span>)loop;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>虽然输入源的自定义的数据是OC代码管理的，但是将输入源和run loop关联在一起的代码需要基于C的回调函数，这些函数的第一个会在你真正将run loop源和run loop绑定的时候调用，在3-4，因为输入源只有一个客户（主线程）它使用调度程序中的函数发送一个信息来将自己在那个线程的应用代理上注册自己。当代理想和输入源取得联系的时候，就会使用RunLoopContext对象来实现。</p>
<p>Listing 3-4 Scheduling a run loop source</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RunLoopSourceScheduleRoutine</span> <span class="params">(<span class="type">void</span> *info, CFRunLoopRef rl, CFStringRef mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    RunLoopSource* obj = (RunLoopSource*)info;</span><br><span class="line">    AppDelegate*   del = [AppDelegate sharedAppDelegate];</span><br><span class="line">    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];</span><br><span class="line">    [del performSelectorOnMainThread:@selector(registerSource:)</span><br><span class="line">                                withObject:theContext waitUntilDone:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的回调程序之一是用来在输入源收到到信号时处理自定义数据的，3-5展示了执行和RunLoopSource对象相关的回调代码。这个函数简单的转发了工作请求给sourceFired方法，这个方法会在以后处理命令缓冲区内出现的任何命令。</p>
<p>Listing 3-5 Performing work in the input source</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RunLoopSourcePerformRoutine</span> <span class="params">(<span class="type">void</span> *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    RunLoopSource*  obj = (RunLoopSource*)info;</span><br><span class="line">    [obj sourceFired];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用CFRunLoopSourceInvalidate函数将输入源移除，系统会调用输入源的取消代码。你可以用这个代码通知客户们你的输入源已经不再有效了，他们应该移除和它的所有的关联。3-6是RunLoopSource对象注册的取消回调代码。这个函数发送另一个RunLoopContext对象给应用代理，但是这次是请求代理移除run loop源的关联。</p>
<p>Listing 3-6 Invalidating an input source</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RunLoopSourceCancelRoutine</span> <span class="params">(<span class="type">void</span> *info, CFRunLoopRef rl, CFStringRef mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    RunLoopSource* obj = (RunLoopSource*)info;</span><br><span class="line">    AppDelegate* del = [AppDelegate sharedAppDelegate];</span><br><span class="line">    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];</span><br><span class="line"></span><br><span class="line">    [del performSelectorOnMainThread:@selector(removeSource:)</span><br><span class="line">                                withObject:theContext waitUntilDone:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注：应用程序代理的registerSource: and removeSource:方法在Coordinating with Clients of the Input Source</p>
<ul>
<li>8.3 在run loop上添加输入源</li>
</ul>
<p>3-7展示了RunLoopSource的init和addToCurrentRunLoop方法。init方法创建了必须依附到RunLoop上的CFRunLoopSourceRef非透明类型对象，它通过传递RunLoopSource对象本身作为上下文信息，所以回调程序会有指向该对象的指针。输入源的安装工作不会在工作线程调用addToCurrentRunLoop方法前进行，addToCurrentRunLoop调用时RunLoopSourceScheduleRoutine的回调函数就会被调用，一旦输入源添加到run loop，线程就可以运行它的run loop来等待事件。</p>
<p>Listing 3-7 Installing the run loop source</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopSourceContext</span>    context = &#123;<span class="number">0</span>, <span class="keyword">self</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">                                        &amp;RunLoopSourceScheduleRoutine,</span><br><span class="line">                                        RunLoopSourceCancelRoutine,</span><br><span class="line">                                        RunLoopSourcePerformRoutine&#125;;</span><br><span class="line">    runLoopSource = <span class="built_in">CFRunLoopSourceCreate</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;context);</span><br><span class="line">    commands = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="type">void</span>)addToCurrentRunLoop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">    <span class="built_in">CFRunLoopAddSource</span>(runLoop, runLoopSource, kCFRunLoopDefaultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>8.4 协调输入源的客户</li>
</ul>
<p>为了输入输入源起作用，你应该巧妙控制它并且在另一个线程给它发信号。输入源的要点让和它关联的线程睡眠直到有事可做。所以让其他的线程能够获得输入源的信息和并且和输入源进行通信是现实的需求。</p>
<p>一个通知输入源的客户的方式是当输入源第一次安装在run loop上的时候发送注册请求。可以为一个输入源注册多个客户，也可以简单的注册到一些中心机构，然后在把输入源给感兴趣的客户。3-8展示了应用程序代理的注册并在RunLoopSource对象的调度函数被调用时执行的注册方法，这个方法接收RunLoopSource对象提供的RunLoopContext对象，并且把它添加到源列表上，下面的代码也包含了在从run loop移除的时候如何反注册输入源。</p>
<p>Listing 3-8 Registering and removing an input source with the application delegate</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>registerSource:<span class="params">(RunLoopContext*)</span>sourceInfo;</span><br><span class="line">&#123;</span><br><span class="line">    [sourcesToPing addObject:sourceInfo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- <span class="params">(void)</span>removeSource:<span class="params">(RunLoopContext*)</span>sourceInfo</span><br><span class="line">&#123;</span><br><span class="line">    id    objToRemove = nil;</span><br><span class="line"></span><br><span class="line">    for <span class="params">(RunLoopContext* context in sourcesToPing)</span></span><br><span class="line">    &#123;</span><br><span class="line">        if <span class="params">([context isEqual:sourceInfo])</span></span><br><span class="line">        &#123;</span><br><span class="line">            objToRemove = context;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if <span class="params">(objToRemove)</span></span><br><span class="line">        [sourcesToPing removeObject:objToRemove];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回调函数调用的方法在上面的3-4和3-6</p>
<ul>
<li>8.5 给输入源发信号</li>
</ul>
<p>当一个客户把它的数据传递给输入源后，必须给输入源发信号唤醒它的run loop，给输入源发信号让run loop知道输入源已经准备好，等待处理。因为一个信号发生的时候线程可能正在休眠，你应该总是显示的唤醒run loop。如果不这样做可能会导致处理输入源的数据上产生延迟。</p>
<p>3-9展示了RunLoopSource 对象的fireCommandsOnRunLoop方法，客户在他们为输入源做好处理缓冲区数据的准备时调用这个方法。</p>
<p>Listing 3-9 Waking up the run loop</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)fireCommandsOnRunLoop:(CFRunLoopRef)runloop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopSourceSignal</span>(runLoopSource);</span><br><span class="line">    <span class="built_in">CFRunLoopWakeUp</span>(runloop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注：你不应该尝试通过发送自定义输入源来处理SIGHUP或其他类型的进程级信号，用于唤醒Run Loop的Core Foundation功能不是信号安全的，不应该在应用程序的信号处理程序中使用。 有关信号处理程序例程的更多信息，请参阅sigaction手册页。</p>
<ul>
<li>8.6 配置定时器</li>
</ul>
<p>要创建定时器源，你只需创建一个定时器对象并在Run Loop中调度。 在Cocoa中，您可以使用NSTimer类来创建新的定时器对象，而在Core Foundation中，您可以使用CFRunLoopTimerRef类型。 在内部，NSTimer类只是Core Foundation的扩展，它提供了一些方便的功能，例如使用相同方法创建和计划定时器的能力。</p>
<p>在Cocoa中，您可以使用以下任一类方法一次创建和调度定时器器：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">scheduledTimerWithTimeInterval:</span>target:selector:userInfo:repeats:</span><br><span class="line"><span class="symbol">scheduledTimerWithTimeInterval:</span>invocation:repeats:</span><br></pre></td></tr></table></figure>
<p>这些方法创建定时器，并以默认模式（NSDefaultRunLoopMode）将其添加到当前线程的Run Loop中。 如果您想通过创建NSTimer对象然后使用NSRunLoop的addTimer：forMode：方法将其添加到运行循环中，也可以手动调度计时器。这两种技术基本上都是一样的，但是给你不同级别的控制定时器配置。 例如，如果创建定时器并手动将其添加到运行循环中，则可以使用除默认模式之外的模式来执行此操作。 清单3-10显示了如何使用这两种技术创建定时器。 第一个定时器的初始延迟为1秒，但随后每0.1秒钟定时fire。 第二个定时器在初始0.2秒延迟后开始首次fire，然后每0.2秒fire一次。</p>
<p>Listing 3-10 Creating and scheduling timers using NSTimer</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSRunLoop</span>* myRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create and schedule the first timer.</span></span><br><span class="line"><span class="built_in">NSDate</span>* futureDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1.0</span>];</span><br><span class="line"><span class="built_in">NSTimer</span>* myTimer = [[<span class="built_in">NSTimer</span> alloc] initWithFireDate:futureDate</span><br><span class="line">                        interval:<span class="number">0.1</span></span><br><span class="line">                        target:<span class="keyword">self</span></span><br><span class="line">                        selector:<span class="keyword">@selector</span>(myDoFireTimer1:)</span><br><span class="line">                        userInfo:<span class="literal">nil</span></span><br><span class="line">                        repeats:<span class="literal">YES</span>];</span><br><span class="line">[myRunLoop addTimer:myTimer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create and schedule the second timer.</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.2</span></span><br><span class="line">                        target:<span class="keyword">self</span></span><br><span class="line">                        selector:<span class="keyword">@selector</span>(myDoFireTimer2:)</span><br><span class="line">                        userInfo:<span class="literal">nil</span></span><br><span class="line">                        repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>清单3-11显示了使用Core Foundation函数配置定时器所需的代码。 虽然此示例不会在上下文结构中传递任何用户定义的信息，但您可以使用此结构传递定时器所需的任何自定义数据。 有关此结构的内容的更多信息，请参阅CFRunLoopTimer参考中的描述。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"><span class="built_in">CFRunLoopTimerContext</span> context = &#123;<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="built_in">CFRunLoopTimerRef</span> timer = <span class="built_in">CFRunLoopTimerCreate</span>(kCFAllocatorDefault, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                        &amp;myCFTimerCallback, &amp;context);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopAddTimer</span>(runLoop, timer, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure>
<ul>
<li>8.7 配置基于端口的输入源</li>
</ul>
<p>Cocoa和Core Foundation都提供基于端口的对象，用于线程之间或进程之间的通信。 以下部分将介绍如何使用几种不同类型的端口设置端口通信。</p>
<ul>
<li>8.7.1 配置NSMachPort对象</li>
</ul>
<p>要建立与NSMachPort对象的本地连接，你将创建端口对象并将其添加到主线程的Run Loop中。 启动辅助线程时，将相同的对象传递给线程的入口点函数。 辅助线程可以使用相同的对象将消息发送回主线程。</p>
<ul>
<li>8.7.2 实现主线程代码</li>
</ul>
<p>清单3-12显示了启动辅助工作线程的主线程代码。 因为Cocoa框架执行了许多用于配置端口和run loop的介入步骤，所以launchThread方法明显短于其Core Foundation中等效的配置（清单3-17）;然而，两者的行为几乎相同。 一个区别是，该方法不是将本地端口的名称发送给工作线程，而是直接发送NSPort对象。</p>
<p>Listing 3-12 Main thread launch method</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)launchThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSPort</span>* myPort = [<span class="built_in">NSMachPort</span> port];</span><br><span class="line">    <span class="keyword">if</span> (myPort)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// This class handles incoming port messages.</span></span><br><span class="line">        [myPort setDelegate:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Install the port as an input source on the current run loop.</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:myPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Detach the thread. Let the worker release the port.</span></span><br><span class="line">        [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(LaunchThreadWithPort:)</span><br><span class="line">               toTarget:[MyWorkerClass <span class="keyword">class</span>] withObject:myPort];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了在线程之间建立一个双向通信通道，你可能希望工作线程在登录消息中将自己的本地端口发送到主线程。 接收签入消息让你的主线程知道在启动第二个线程时一切顺利，并且还可以向你发送更多消息到该线程。清单3-13显示了主线程的handlePortMessage：方法。 当数据到达线程自己的本地端口时调用此方法。 当一个签到消息到达时，该方法直接从端口消息中检索次要线程的端口，并保存以备以后使用。</p>
<p>Listing 3-13 Handling Mach port messages</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kCheckinMessage 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle responses from the worker thread.</span></span><br><span class="line">- (<span class="type">void</span>)handlePortMessage:(<span class="built_in">NSPortMessage</span> *)portMessage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> message = [portMessage msgid];</span><br><span class="line">    <span class="built_in">NSPort</span>* distantPort = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (message == kCheckinMessage)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get the worker thread’s communications port.</span></span><br><span class="line">        distantPort = [portMessage sendPort];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Retain and save the worker port for later use.</span></span><br><span class="line">        [<span class="keyword">self</span> storeDistantPort:distantPort];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Handle other messages.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>8.7.3实现次要线程代码</li>
</ul>
<p>对于辅助工作线程，你必须配置线程并使用指定的端口将信息传回主线程。</p>
<p>清单3-14显示了设置工作线程的代码。 为线程创建自动释放池后，该方法将创建一个工作对象来驱动线程执行。 工作对象的sendCheckinMessage：方法（如清单3-15所示）为工作线程创建一个本地端口，并将一个签入消息发送回主线程。</p>
<p>Listing 3-14 Launching the worker thread using Mach ports</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span>(void)<span class="type">LaunchThreadWithPort</span>:(id)inData</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">NSAutoreleasePool</span><span class="operator">*</span>  pool <span class="operator">=</span> [[<span class="type">NSAutoreleasePool</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the connection between this thread and the main thread.</span></span><br><span class="line">    <span class="type">NSPort</span><span class="operator">*</span> distantPort <span class="operator">=</span> (<span class="type">NSPort</span><span class="operator">*</span>)inData;</span><br><span class="line"></span><br><span class="line">    <span class="type">MyWorkerClass</span><span class="operator">*</span>  workerObj <span class="operator">=</span> [[<span class="keyword">self</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    [workerObj sendCheckinMessage:distantPort];</span><br><span class="line">    [distantPort release];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let the run loop process things.</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        [[<span class="type">NSRunLoop</span> currentRunLoop] runMode:<span class="type">NSDefaultRunLoopMode</span></span><br><span class="line">                            beforeDate:[<span class="type">NSDate</span> distantFuture]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="operator">!</span>[workerObj shouldExit]);</span><br><span class="line"></span><br><span class="line">    [workerObj release];</span><br><span class="line">    [pool release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用NSMachPort时，本地和远程线程可以使用相同的端口对象进行线程之间的单向通信。 换句话说，由一个线程创建的本地端口对象将成为另一个线程的远程端口对象。</p>
<p>清单3-15显示了次要线程的签入例程。 该方法设置自己的本地端口用于将来的通信，然后发送一个检入消息回主线程。 该方法使用在LaunchThreadWithPort：方法中接收的端口对象作为消息的目标。</p>
<p>Listing 3-15 Sending the check-in message using Mach ports</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="type">void</span>)sendCheckinMessage:(<span class="built_in">NSPort</span>*)outPort</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Retain and save the remote port for future use.</span></span><br><span class="line">    [<span class="keyword">self</span> setRemotePort:outPort];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and configure the worker thread port.</span></span><br><span class="line">    <span class="built_in">NSPort</span>* myPort = [<span class="built_in">NSMachPort</span> port];</span><br><span class="line">    [myPort setDelegate:<span class="keyword">self</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:myPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the check-in message.</span></span><br><span class="line">    <span class="built_in">NSPortMessage</span>* messageObj = [[<span class="built_in">NSPortMessage</span> alloc] initWithSendPort:outPort</span><br><span class="line">                                         receivePort:myPort components:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (messageObj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Finish configuring the message and send it immediately.</span></span><br><span class="line">        [messageObj setMsgId:setMsgid:kCheckinMessage];</span><br><span class="line">        [messageObj sendBeforeDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>8.7.4 配置一个NSMessagePort对象</li>
</ul>
<p>要建立与NSMessagePort对象的本地连接，您不能简单地在线程之间传递端口对象。 远程消息端口必须以名称获取。 在Cocoa中可能需要使用特定的名称注册本地端口，然后将该名称传递给远程线程，以便它可以获取适当的端口对象进行通信。 清单3-16显示了要使用消息端口的端口创建和注册过程。</p>
<p>Listing 3-16 Registering a message port</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSPort</span><span class="operator">*</span> localPort <span class="operator">=</span> [[<span class="type">NSMessagePort</span> alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the object and add it to the current run loop.</span></span><br><span class="line">[localPort setDelegate:<span class="keyword">self</span>];</span><br><span class="line">[[<span class="type">NSRunLoop</span> currentRunLoop] addPort:localPort forMode:<span class="type">NSDefaultRunLoopMode</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the port using a specific name. The name must be unique.</span></span><br><span class="line"><span class="type">NSString</span><span class="operator">*</span> localPortName <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;MyPortName&quot;</span>];</span><br><span class="line">[[<span class="type">NSMessagePortNameServer</span> sharedInstance] registerPort:localPort</span><br><span class="line">                     name:localPortName];</span><br></pre></td></tr></table></figure>
<ul>
<li>8.7.6 Core Foundation中配置基于端口的输入源</li>
</ul>
<p>本节介绍如何使用Core Foundation在应用程序的主线程和工作线程之间设置双向通信通道。清单3-17显示了应用程序主线程调用的代码，以启动工作线程。 代码的第一件事是设置一个CFMessagePortRef opaque类型来监听来自工作线程的消息。 工作线程需要进行连接的端口名称，以便将字符串值传递给工作线程的入口点函数。 端口名称通常在当前用户上下文中是唯一的; 否则，您可能会遇到冲突。</p>
<p>Listing 3-17 ：将Core Foundation消息端口附加到新线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kThreadStackSize        (8 *4096)</span></span><br><span class="line"></span><br><span class="line">OSStatus <span class="title function_">MySpawnThread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create a local port for receiving responses.</span></span><br><span class="line">    CFStringRef myPortName;</span><br><span class="line">    CFMessagePortRef myPort;</span><br><span class="line">    CFRunLoopSourceRef rlSource;</span><br><span class="line">    CFMessagePortContext context = &#123;<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    Boolean shouldFreeInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a string with the port name.</span></span><br><span class="line">    myPortName = CFStringCreateWithFormat(<span class="literal">NULL</span>, <span class="literal">NULL</span>, CFSTR(<span class="string">&quot;com.myapp.MainThread&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the port.</span></span><br><span class="line">    myPort = CFMessagePortCreateLocal(<span class="literal">NULL</span>,</span><br><span class="line">                myPortName,</span><br><span class="line">                &amp;MainThreadResponseHandler,</span><br><span class="line">                &amp;context,</span><br><span class="line">                &amp;shouldFreeInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (myPort != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The port was successfully created.</span></span><br><span class="line">        <span class="comment">// Now create a run loop source for it.</span></span><br><span class="line">        rlSource = CFMessagePortCreateRunLoopSource(<span class="literal">NULL</span>, myPort, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rlSource)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Add the source to the current run loop.</span></span><br><span class="line">            CFRunLoopAddSource(CFRunLoopGetCurrent(), rlSource, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Once installed, these can be freed.</span></span><br><span class="line">            CFRelease(myPort);</span><br><span class="line">            CFRelease(rlSource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the thread and continue processing.</span></span><br><span class="line">    MPTaskID        taskID;</span><br><span class="line">    <span class="keyword">return</span>(MPCreateTask(&amp;ServerThreadEntryPoint,</span><br><span class="line">                    (<span class="type">void</span>*)myPortName,</span><br><span class="line">                    kThreadStackSize,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    <span class="number">0</span>,</span><br><span class="line">                    &amp;taskID));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在安装端口并启动线程的情况下，主线程可以在等待线程检入时继续其正常执行。当检入消息到达时，它将被分派到主线程的MainThreadResponseHandler函数，如清单3- 18。 此函数提取工作线程的端口名称，并创建未来通信的管道。</p>
<p>Listing 3-18 Receiving the checkin message</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kCheckinMessage 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Main thread port message handler</span></span><br><span class="line">CFDataRef <span class="title function_">MainThreadResponseHandler</span><span class="params">(CFMessagePortRef local,</span></span><br><span class="line"><span class="params">                    SInt32 msgid,</span></span><br><span class="line"><span class="params">                    CFDataRef data,</span></span><br><span class="line"><span class="params">                    <span class="type">void</span>* info)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (msgid == kCheckinMessage)</span><br><span class="line">    &#123;</span><br><span class="line">        CFMessagePortRef messagePort;</span><br><span class="line">        CFStringRef threadPortName;</span><br><span class="line">        CFIndex bufferLength = CFDataGetLength(data);</span><br><span class="line">        UInt8* buffer = CFAllocatorAllocate(<span class="literal">NULL</span>, bufferLength, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        CFDataGetBytes(data, CFRangeMake(<span class="number">0</span>, bufferLength), buffer);</span><br><span class="line">        threadPortName = CFStringCreateWithBytes (<span class="literal">NULL</span>, buffer, bufferLength, kCFStringEncodingASCII, FALSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// You must obtain a remote message port by name.</span></span><br><span class="line">        messagePort = CFMessagePortCreateRemote(<span class="literal">NULL</span>, (CFStringRef)threadPortName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (messagePort)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Retain and save the thread’s comm port for future reference.</span></span><br><span class="line">            AddPortToListOfActiveThreads(messagePort);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Since the port is retained by the previous function, release</span></span><br><span class="line">            <span class="comment">// it here.</span></span><br><span class="line">            CFRelease(messagePort);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clean up.</span></span><br><span class="line">        CFRelease(threadPortName);</span><br><span class="line">        CFAllocatorDeallocate(<span class="literal">NULL</span>, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Process other messages.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置主线程之后，唯一剩下的就是新创建的工作线程创建自己的端口并签入。清单3-19显示了工作线程的入口点函数。 该函数提取主线程的端口名称，并使用它来创建一个远程连接回主线程。 该函数然后为其自身创建本地端口，将端口安装在线程的运行循环上，并向包含本地端口名称的主线程发送检入消息。</p>
<p>Listing 3-19 Setting up the thread structures</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OSStatus <span class="title function_">ServerThreadEntryPoint</span><span class="params">(<span class="type">void</span>* param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Create the remote port to the main thread.</span></span><br><span class="line">    CFMessagePortRef mainThreadPort;</span><br><span class="line">    CFStringRef portName = (CFStringRef)param;</span><br><span class="line"></span><br><span class="line">    mainThreadPort = CFMessagePortCreateRemote(<span class="literal">NULL</span>, portName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free the string that was passed in param.</span></span><br><span class="line">    CFRelease(portName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a port for the worker thread.</span></span><br><span class="line">    CFStringRef myPortName = CFStringCreateWithFormat(<span class="literal">NULL</span>, <span class="literal">NULL</span>, CFSTR(<span class="string">&quot;com.MyApp.Thread-%d&quot;</span>), MPCurrentTaskID());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the port in this thread’s context info for later reference.</span></span><br><span class="line">    CFMessagePortContext context = &#123;<span class="number">0</span>, mainThreadPort, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    Boolean shouldFreeInfo;</span><br><span class="line">    Boolean shouldAbort = TRUE;</span><br><span class="line"></span><br><span class="line">    CFMessagePortRef myPort = CFMessagePortCreateLocal(<span class="literal">NULL</span>,</span><br><span class="line">                myPortName,</span><br><span class="line">                &amp;ProcessClientRequest,</span><br><span class="line">                &amp;context,</span><br><span class="line">                &amp;shouldFreeInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldFreeInfo)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Couldn&#x27;t create a local port, so kill the thread.</span></span><br><span class="line">        MPExit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CFRunLoopSourceRef rlSource = CFMessagePortCreateRunLoopSource(<span class="literal">NULL</span>, myPort, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!rlSource)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Couldn&#x27;t create a local port, so kill the thread.</span></span><br><span class="line">        MPExit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the source to the current run loop.</span></span><br><span class="line">    CFRunLoopAddSource(CFRunLoopGetCurrent(), rlSource, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Once installed, these can be freed.</span></span><br><span class="line">    CFRelease(myPort);</span><br><span class="line">    CFRelease(rlSource);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Package up the port name and send the check-in message.</span></span><br><span class="line">    CFDataRef returnData = nil;</span><br><span class="line">    CFDataRef outData;</span><br><span class="line">    CFIndex stringLength = CFStringGetLength(myPortName);</span><br><span class="line">    UInt8* buffer = CFAllocatorAllocate(<span class="literal">NULL</span>, stringLength, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    CFStringGetBytes(myPortName,</span><br><span class="line">                CFRangeMake(<span class="number">0</span>,stringLength),</span><br><span class="line">                kCFStringEncodingASCII,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                FALSE,</span><br><span class="line">                buffer,</span><br><span class="line">                stringLength,</span><br><span class="line">                <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    outData = CFDataCreate(<span class="literal">NULL</span>, buffer, stringLength);</span><br><span class="line"></span><br><span class="line">    CFMessagePortSendRequest(mainThreadPort, kCheckinMessage, outData, <span class="number">0.1</span>, <span class="number">0.0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up thread data structures.</span></span><br><span class="line">    CFRelease(outData);</span><br><span class="line">    CFAllocatorDeallocate(<span class="literal">NULL</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enter the run loop.</span></span><br><span class="line">    CFRunLoopRun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦进入其run loop，发送到线程端口的所有未来事件都将由ProcessClientRequest函数处理。 该功能的实现取决于线程工作的类型，此处未显示。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>面试总结</category>
        <category>RunLoop翻译</category>
      </categories>
      <tags>
        <tag>RunLoop</tag>
        <tag>RunLoop翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 算法收集</title>
    <url>/iOS/algorithm/index.html</url>
    <content><![CDATA[<h2 id="回溯算法-问题"><a href="#回溯算法-问题" class="headerlink" title="回溯算法 问题"></a>回溯算法 问题</h2><table>
<thead>
<tr>
<th>类型</th>
<th>题目链接</th>
</tr>
</thead>
<tbody><tr>
<td>子集、组合</td>
<td>子集、子集 II、组合、组合总和、组合总和 II</td>
</tr>
<tr>
<td>全排列</td>
<td>全排列、全排列 II、字符串的全排列、字母大小写全排列</td>
</tr>
<tr>
<td>搜索</td>
<td>解数独、单词搜索、N皇后、分割回文串、二进制手表</td>
</tr>
</tbody></table>
<p>参考力扣解法<br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3Vic2V0cy9zb2x1dGlvbi9jLXpvbmctamllLWxpYW8taHVpLXN1LXdlbi10aS1sZWkteGluZy1kYWktbmktZ2FvLS8=">C++<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvc3Vic2V0cy9zb2x1dGlvbi9lci1qaW4temhpLXdlaS16aHUtZ2UtbWVpLWp1LWRmc3Nhbi1jaG9uZy1zaS1sdS05Yy8=">java<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>①递归树<br>②找结束条件<br>③找准选择列表<br>④判断是否需要剪枝<br>⑤做出选择<br>⑥撤销选择</p>
<blockquote>
<p>总结：可以发现“排列”类型问题和“子集、组合”问题不同在于：“排列”问题使用used数组来标识选择列表，而“子集、组合”问题则使用start参数</p>
</blockquote>
<h2 id="1、不用中间变量-用两种方法交换A和B的值"><a href="#1、不用中间变量-用两种方法交换A和B的值" class="headerlink" title="1、不用中间变量,用两种方法交换A和B的值"></a><strong>1、不用中间变量,用两种方法交换A和B的值</strong></h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.中间变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> temp = a;</span><br><span class="line">   a = b;</span><br><span class="line">   b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.加法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">   a = a + b;</span><br><span class="line">   b = a - b;</span><br><span class="line">   a = a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.异或（相同为0，不同为1. 可以理解为不进位加法）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">   a = a ^ b;</span><br><span class="line">   b = a ^ b;</span><br><span class="line">   a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、求最大公约数"><a href="#2、求最大公约数" class="headerlink" title="2、求最大公约数"></a><strong>2、求最大公约数</strong></h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 1.直接遍历法 */</span></span><br><span class="line"><span class="built_in">int</span> max<span class="constructor">CommonDivisor(<span class="params">int</span> <span class="params">a</span>, <span class="params">int</span> <span class="params">b</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;=b; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i<span class="operator"> == </span><span class="number">0</span><span class="operator"> &amp;&amp; </span>b % i<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">            max = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 2.辗转相除法 */</span></span><br><span class="line"><span class="built_in">int</span> max<span class="constructor">CommonDivisor(<span class="params">int</span> <span class="params">a</span>, <span class="params">int</span> <span class="params">b</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> r;</span><br><span class="line">    <span class="keyword">while</span>(a % b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r = a % b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = r;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展：最小公倍数 = (a * b)/最大公约数</span></span><br></pre></td></tr></table></figure>

<h2 id="3、模拟栈操作"><a href="#3、模拟栈操作" class="headerlink" title="3、模拟栈操作"></a><strong>3、模拟栈操作</strong></h2><ul>
<li>栈是一种数据结构，特点：先进后出 -</li>
<li>练习：使用全局变量模拟栈的操作</li>
</ul>
<p><strong>#include &lt;stdio.h&gt;<br>#include &lt;stdbool.h&gt;<br>#include &lt;assert.h&gt;</strong></p>
<p>//保护全局变量：在全局变量前加static后，这个全局变量就只能在本文件中使用<br>static int data[1024];//栈最多能保存1024个数据<br>static int count = 0;//目前已经放了多少个数(相当于栈顶位置)</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据入栈 push</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>&#123;</span><br><span class="line">    assert(!full());<span class="comment">//防止数组越界</span></span><br><span class="line">    data[count++] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数据出栈 pop</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">pop</span>()</span>&#123;</span><br><span class="line">    assert(!empty());</span><br><span class="line">    <span class="keyword">return</span> data[--count];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查看栈顶元素 top</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">top</span>()</span>&#123;</span><br><span class="line">    assert(!empty());</span><br><span class="line">    <span class="keyword">return</span> data[count<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询栈满 full</span></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">full</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(count &gt;= <span class="number">1024</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询栈空 empty</span></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">empty</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span>&#123;</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        push(i);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">while</span>(!empty())&#123;</span><br><span class="line">        printf(<span class="string">&quot;%d &quot;</span>, top()); <span class="comment">//栈顶元素</span></span><br><span class="line">        pop(); <span class="comment">//出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、排序算法"><a href="#4、排序算法" class="headerlink" title="4、排序算法"></a><strong>4、排序算法</strong></h2><p>选择排序、冒泡排序、插入排序三种排序算法可以总结为如下：<br>都将数组分为已排序部分和未排序部分。</p>
<p>1.选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。</p>
<p>2.冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。</p>
<p>3.插入排序将已排序部分定义在左端，将未排序部分元的第一个元素插入到已排序部分合适的位置。</p>
<p><strong>4.1、选择排序</strong></p>
<ul>
<li>【选择排序】：最值出现在起始端</li>
<li>第1趟：在n个数中找到最小(大)数与第一个数交换位置</li>
<li>第2趟：在剩下n-1个数中找到最小(大)数与第二个数交换位置</li>
<li>重复这样的操作…依次与第三个、第四个…数交换位置</li>
<li>第n-1趟，最终可实现数据的升序（降序）排列。</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> selectSort(<span class="type">int</span> *arr, <span class="type">int</span> <span class="built_in">length</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">length</span> - <span class="number">1</span>; i++) &#123; <span class="comment">//趟数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">length</span>; j++) &#123; <span class="comment">//比较次数</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.2、冒泡排序</strong></p>
<ul>
<li>【冒泡排序】：相邻元素两两比较，比较完一趟，最值出现在末尾</li>
<li>第1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n个元素位置</li>
<li>第2趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第n-1个元素位置</li>
<li>……   ……</li>
<li>第n-1趟：依次比较相邻的两个数，不断交换（小数放前，大数放后）逐个推进，最值最后出现在第2个元素位置</li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> bublleSort(<span class="type">int</span> *arr, <span class="type">int</span> <span class="built_in">length</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">length</span> - <span class="number">1</span>; i++) &#123; <span class="comment">//趟数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">length</span> - i - <span class="number">1</span>; j++) &#123; <span class="comment">//比较次数</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、折半查找（二分查找）"><a href="#5、折半查找（二分查找）" class="headerlink" title="#### 5、折半查找（二分查找）"></a>#### 5、折半查找（二分查找）</h2><p>折半查找：优化查找时间（不用遍历全部数据）<br>折半查找的原理：</p>
<ul>
<li>1&gt; 数组必须是有序的</li>
<li>2&gt; 必须已知min和max（知道范围）</li>
<li>3&gt; 动态计算mid的值，取出mid对应的值进行比较</li>
<li>4&gt; 如果mid对应的值大于要查找的值，那么max要变小为mid-1</li>
<li>5&gt; 如果mid对应的值小于要查找的值，那么min要变大为mid+1</li>
</ul>
<p>// 已知一个有序数组, 和一个key, 要求从数组中找到key对应的索引位置</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">int findKey(int *arr, int <span class="built_in">length</span>, int key) &#123;</span><br><span class="line">    int <span class="built_in">min</span> = <span class="number">0</span>, <span class="built_in">max</span> = <span class="built_in">length</span> - <span class="number">1</span>, <span class="built_in">mid</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">min</span> &lt;= <span class="built_in">max</span>) &#123;</span><br><span class="line">        <span class="built_in">mid</span> = (<span class="built_in">min</span> + <span class="built_in">max</span>) / <span class="number">2</span>; <span class="comment">//计算中间值</span></span><br><span class="line">        <span class="keyword">if</span> (key &gt; arr[<span class="built_in">mid</span>]) &#123;</span><br><span class="line">            <span class="built_in">min</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; arr[<span class="built_in">mid</span>]) &#123;</span><br><span class="line">            <span class="built_in">max</span> = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">mid</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6、集合结构-线性结构-树形结构-图形结构"><a href="#6、集合结构-线性结构-树形结构-图形结构" class="headerlink" title="6、集合结构 线性结构 树形结构 图形结构"></a>6、集合结构 线性结构 树形结构 图形结构</h2><ul>
<li>1.1、集合结构 说白了就是一个集合，就是一个圆圈中有很多个元素，元素与元素之间没有任何关系  这个很简单</li>
<li>1.2、线性结构 说白了就是一个条线上站着很多个人。 这条线不一定是直的。也可以是弯的。也可以是值的 相当于一条线被分成了好几段的样子 （发挥你的想象力）。 线性结构是一对一的关系</li>
<li>1.3、树形结构 说白了  做开发的肯定或多或少的知道xml 解析  树形结构跟他非常类似。也可以想象成一个金字塔。树形结构是一对多的关系</li>
<li>1.4、图形结构 这个就比较复杂了。他呢 无穷。无边  无向（没有方向）图形机构 你可以理解为多对多 类似于我们人的交集关系</li>
</ul>
<h2 id="7、数据结构的存储"><a href="#7、数据结构的存储" class="headerlink" title="7、数据结构的存储"></a>7、数据结构的存储</h2><p>数据结构的存储一般常用的有两种   顺序存储结构 和 链式存储结构</p>
<ul>
<li>2.1  顺序存储结构</li>
</ul>
<p>发挥想象力啊。 举个列子。数组。1-2-3-4-5-6-7-8-9-10。这个就是一个顺序存储结构 ，存储是按顺序的  举例说明啊。 栈。做开发的都熟悉。栈是先进后出 ，后进先出的形式 对不对 ？！他的你可以这样理解</p>
<p>hello world 在栈里面从栈底到栈顶的逻辑依次为 h-e-l-l-o-w-o-r-l-d 这就是顺序存储 再比如 队列 ，队列是先进先出的对吧，从头到尾 h-e-l-l-o-w-o-r-l-d 就是这样排对的</p>
<ul>
<li>2.2 链式存储结构</li>
</ul>
<p>再次发挥想象力 这个稍微复杂一点 这个图片我一直弄好 ，回头找美工问问，再贴上  例如 还是一个数组</p>
<p>1-2-3-4-5-6-7-8-9-10  链式存储就不一样了 1(地址)-2(地址)-7(地址)-4(地址)-5(地址)-9(地址)-8(地址)-3(地址)-6(地址)-10(地址)。每个数字后面跟着一个地址 而且存储形式不再是顺序 ，也就说顺序乱了，1（地址） 1后面跟着的这个地址指向的是2，2后面的地址指向的是3，3后面的地址指向是谁你应该清楚了吧。他执行的时候是 1(地址)-2(地址)-3(地址)-4(地址)-5(地址)-6(地址)-7(地址)-8(地址)-9(地址)-10(地址)，但是存储的时候就是完全随机的。明白了？！</p>
<h2 id="8、单向链表-双向链表-循环链表"><a href="#8、单向链表-双向链表-循环链表" class="headerlink" title="8、单向链表\双向链表\循环链表"></a>8、单向链表\双向链表\循环链表</h2><p>还是举例子。理解最重要。不要去死记硬背 哪些什么。定义啊。逻辑啊。理解才是最重要滴</p>
<ul>
<li>3.1 单向链表</li>
</ul>
<p>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H. 这就是单向链表 H 是头 A 是尾 像一个只有一个头的火车一样 只能一个头拉着跑<br><img src="https://upload-images.jianshu.io/upload_images/13252132-681296a63ca929e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<ul>
<li>3.2 双向链表</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13252132-b3d7480416c4f332.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<blockquote>
<p>数组和链表区别：<br>数组：数组元素在内存上连续存放，可以通过下标查找元素；插入、删除需要移动大量元素，比较适用于元素很少变化的情况<br>链表：链表中的元素在内存中不是顺序存储的，查找慢，插入、删除只需要对元素指针重新赋值，效率高</p>
</blockquote>
<ul>
<li>3.3 循环链表</li>
</ul>
<p>循环链表是与单向链表一样，是一种链式的存储结构，所不同的是，循环链表的最后一个结点的指针是指向该循环链表的第一个结点或者表头结点，从而构成一个环形的链。发挥想象力  A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G-&gt;H-&gt;A. 绕成一个圈。就像蛇吃自己的这就是循环  不需要去死记硬背哪些理论知识。</p>
<h2 id="9、二叉树／平衡二叉树"><a href="#9、二叉树／平衡二叉树" class="headerlink" title="9、二叉树／平衡二叉树"></a>9、二叉树／平衡二叉树</h2><ul>
<li>4.1 什么是二叉树</li>
</ul>
<p>树形结构下,两个节点以内 都称之为二叉树 不存在大于2 的节点 分为左子树 右子树 有顺序 不能颠倒 ，懵逼了吧，你肯定会想这是什么玩意，什么左子树右子树 ，都什么跟什么鬼？  现在我以普通话再讲一遍，你把二叉树看成一个人 ，人的头呢就是树的根 ，左子树就是左手，右子树就是右手，左右手可以都没有（残疾嘛，声明一下，绝非歧视残疾朋友，勿怪，勿怪就是举个例子，i am very sorry）  , 左右手呢可以有一个，就是不能颠倒。这样讲应该明白了吧</p>
<p><strong>二叉树有五种表现形式</strong></p>
<p>1.空的树（没有节点）可以理解为什么都没 像空气一样<br>2.只有根节点。 （理解一个人只有一个头 其他的什么都没，说的有点恐怖）<br>3.只有左子树 （一个头 一个左手 感觉越来越写不下去了）<br>4.只有右子树<br>5.左右子树都有</p>
<p>二叉树可以转换成森林 树也可以转换成二叉树。这里就不介绍了 你做项目绝对用不到<br>数据结构大致介绍这么多吧。理解为主, 别死记，死记没什么用</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS算法</category>
      </categories>
      <tags>
        <tag>iOS算法收集</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS动画</title>
    <url>/iOS/animation/index.html</url>
    <content><![CDATA[<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><code>AirBnb</code> 的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FpcmJuYi9sb3R0aWUtaW9z">Lottie<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Layar的认识"><a href="#Layar的认识" class="headerlink" title="Layar的认识"></a>Layar的认识</h2><p><code>layer</code> 层是涂层绘制、渲染、以及动画的完成者，它无法直接的处理触摸事件（也可以捕捉事件）<br><code>layer</code> 包含的方面非常多，常见的属性有 <code>Frame</code>、<code>Bounds</code>、<code>Position</code>、<code>AnchorPoint</code>、<code>Contents</code> 等等。<br>想详细了解 <code>CALayer</code> 以及动画的 ，可以看看这本书 - <span class="exturl" data-url="aHR0cHM6Ly9sZWdhY3kuZ2l0Ym9vay5jb20vYm9vay96c2lzbWUvaW9zLS9kZXRhaWxz">Core-Animation<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS动画</category>
      </categories>
      <tags>
        <tag>Objetive-C</tag>
      </tags>
  </entry>
  <entry>
    <title>Block相关知识点</title>
    <url>/iOS/block/index.html</url>
    <content><![CDATA[<h2 id="Block的几种形式"><a href="#Block的几种形式" class="headerlink" title="Block的几种形式"></a>Block的几种形式</h2><p>   分为全局Block(<code>_NSConcreteGlobalBlock</code>)、栈Block(<code>_NSConcreteStackBlock</code>)、堆Block<br>(<code>_NSConcreteMallocBlock</code>)三种形式<br>   其中栈Block存储在栈(stack)区，堆Block存储在堆(heap)区，全局Block存储在已初始化数据(.data)区</p>
<p><strong>1、不使用外部变量的block是全局block</strong></p>
<p>比如：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;globalBlock&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">__NSGlobalBlock__</span></span><br></pre></td></tr></table></figure>

<p><strong>2、使用外部变量并且未进行copy操作的block是栈block</strong></p>
<p>比如:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> num = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;stackBlock:%zd&quot;</span>,num);</span><br><span class="line">  &#125; <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">__NSStackBlock__</span></span><br></pre></td></tr></table></figure>

<p>日常开发常用于这种情况:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> testWithBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="keyword">self</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testWithBlock:(dispatch_block_t)block &#123;</span><br><span class="line">    block();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[block <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、对栈block进行copy操作，就是堆block，而对全局block进行copy，仍是全局block</strong></p>
<ul>
<li>比如堆1中的全局进行copy操作，即赋值：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (^globalBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;globalBlock&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[globalBlock <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">__NSGlobalBlock__</span></span><br></pre></td></tr></table></figure>

<p>仍是全局block</p>
<ul>
<li>而对2中的栈block进行赋值操作：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (^mallocBlock)(<span class="type">void</span>) = ^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;stackBlock:%zd&quot;</span>,num);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[mallocBlock <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">__NSMallocBlock__</span></span><br></pre></td></tr></table></figure>

<p>对栈blockcopy之后，并不代表着栈block就消失了，左边的mallock是堆block，右边被copy的仍是栈block<br>比如:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> testWithBlock:^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="keyword">self</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)testWithBlock:(dispatch_block_t)block</span><br><span class="line">&#123;</span><br><span class="line">    block();</span><br><span class="line">    </span><br><span class="line">    dispatch_block_t tempBlock = block;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@,%@&quot;</span>,[block <span class="keyword">class</span>],[tempBlock <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">__NSStackBlock__</span>,<span class="emphasis">__NSMallocBlock__</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>即如果对栈Block进行copy，将会copy到堆区，对堆Block进行copy，将会增加引用计数，对全局Block进行copy，因为是已经初始化的，所以什么也不做。</strong></li>
</ul>
<p>另外，__block变量在copy时，由于__forwarding的存在，栈上的__forwarding指针会指向堆上的__forwarding变量，而堆上的__forwarding指针指向其自身，所以，如果对__block的修改，实际上是在修改堆上的__block变量。</p>
<p><strong>即__forwarding指针存在的意义就是，无论在任何内存位置，都可以顺利地访问同一个__block变量</strong>。</p>
<ul>
<li>另外由于block捕获的__block修饰的变量会去持有变量，那么如果用__block修饰self，且self持有block，并且block内部使用到__block修饰的self时，就会造成多循环引用，即self持有block，block 持有__block变量，而__block变量持有self，造成内存泄漏。<br>比如:</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">__block <span class="keyword">typeof</span>(<span class="keyword">self</span>) blockSelf = <span class="keyword">self</span>;</span><br><span class="line">   </span><br><span class="line">   _testBlock = ^&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,blockSelf);</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   _testBlock();</span><br></pre></td></tr></table></figure>

<p>如果要解决这种循环引用，可以主动断开__block变量对self的持有，即在block内部使用完blockSelf后，将其置为nil，但这种方式有个问题，如果block一直不被调用，那么循环引用将一直存在。<br>所以，我们最好还是用__weak来修饰self</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>OC语言</category>
      </categories>
      <tags>
        <tag>Objetive-C</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS程序崩溃抓获与分析</title>
    <url>/iOS/crashreport/crashanalysis.html</url>
    <content><![CDATA[<h1 id="iOS-App程序崩溃的抓取与分析"><a href="#iOS-App程序崩溃的抓取与分析" class="headerlink" title="iOS App程序崩溃的抓取与分析"></a>iOS App程序崩溃的抓取与分析</h1><blockquote>
<p>备用: <span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscy94bnUv">xun开源代码地址<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol>
<li>cpu无法执行，除以0，无权限内存地址(pagezero-4g)无效<ul>
<li>pagezero，拦截空指针的访问。 隔绝32位操作系统</li>
</ul>
</li>
<li>被系统强杀<ul>
<li>oom</li>
<li>ANR</li>
<li>资源异常</li>
<li>死锁</li>
<li>非法应用签名</li>
<li>后台超时</li>
<li>内存紧张</li>
<li>设备过热</li>
</ul>
</li>
<li>oc异常<ul>
<li>数组越界</li>
<li>C++异常</li>
<li>断言</li>
</ul>
</li>
<li>中断<ul>
<li>外部中断(IO)</li>
<li>异常中断</li>
<li>系统调用</li>
</ul>
</li>
</ol>
<h2 id="具体处理"><a href="#具体处理" class="headerlink" title="具体处理"></a>具体处理</h2><ol>
<li>Mach异常捕获方式<ul>
<li>mach_port_allocate 创建一场端口</li>
<li>mach_port_insert_right 申请 set_exception_ports 的权限</li>
<li>xxx_set_exception_ports 设置异常端口</li>
<li>循环等待异常消息</li>
</ul>
</li>
<li>Unix 信号方式 signal(SIGSEGV, signalHandler)<ul>
<li>除了OC层面的异常捕捉之外，很多内存错误、访问错误的地址产生的crash则需要利用unix标准的signal机制，注册SIGABRT, SIGBUS, SIGSEGV等信号发生时的处理函数。该函数中我们可以输出栈信息，版本信息等其他一切我们所想要的。</li>
</ul>
</li>
<li>Mach异常 + Unix信号方式<ul>
<li>某个NSException导致程序Crash的，只有拿到这个NSException，获取它的reason，name，callStackSymbols信息才能确定出问题的程序位置。</li>
<li>方法很简单，可通过注册NSUncaughtExceptionHandler捕获异常信息<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> my_uncaught_exception_handler (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">    <span class="comment">//这里可以取到 NSException 信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;my_uncaught_exception_handler);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="多个-Crash-日志收集服务共存"><a href="#多个-Crash-日志收集服务共存" class="headerlink" title="多个 Crash 日志收集服务共存"></a>多个 Crash 日志收集服务共存</h2><ul>
<li>拒绝传递 UncaughtExceptionHandler</li>
<li>开发测试阶段，可以利用 fishhook 框架去hookNSSetUncaughtExceptionHandler方法,这样就可以清晰的看到handler的传递流程断在哪里，快速定位污染环境者。</li>
<li>Mach异常端口换出+信号处理Handler覆盖</li>
<li>影响系统崩溃日志准确性<ul>
<li>若程序因NSException而Crash，系统日志中的Last Exception Backtrace信息是完整准确的，不会受应用层的胡来而影响，可作为排查问题的参考线索。</li>
</ul>
</li>
</ul>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Mach: 微内核，负责操作系统中基本职责：进程和线程抽象、虚拟内存管理、任务调度、进程间通信和消息传递机制。</p>
<p>大家熟知的NSSetUncaughtExceptionHandler() + signal() / sigaction()的方式收集Crash,但是stack overflow并不能被此方法扑捉到;</p>
<p>通常我们所说的异常，一般是有处理器陷阱引发的,通用的Mach异常处理程序exception_triage()，负责将异常转换成Mach 消息。exception_triage()通过调用exception_deliver()尝试把异常投递到thread、task最后是host。首先尝试将异常抛给thread端口，然后尝试抛给task端口，最后再抛给host端口(默认端口)，如果没有一个端口返回KERN_SUCCESS，那么任务就会被终止。</p>
<blockquote>
<p>代码太多，不再贴了，自行下载源码，找到 osfmk/kern/exception.c 文件。 里面有<code>exception_triage()和exception_deliver()函数</code>。关于<code>Exception</code>的相关定义，可以在<code>osfmk/mach/exception_types.h</code>里面查看。下面只贴伪代码</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 位于 osfmk/kern/exception.c</span></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">xception_triage</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">exception_type_t</span> exception,</span></span><br><span class="line"><span class="params">    <span class="type">mach_exception_data_t</span> code,</span></span><br><span class="line"><span class="params">    <span class="type">mach_msg_type_number_t</span> codeCnt</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">thread_t</span> thread;</span><br><span class="line">    <span class="type">task_t</span> task;</span><br><span class="line">    <span class="type">host_priv_t</span> host_priv;</span><br><span class="line">    <span class="type">lck_mtx_t</span> *mutex;</span><br><span class="line">    <span class="type">kern_return_t</span> kr = KERN_FAILURE;</span><br><span class="line">    assert(exception != EXC_RPC_ALERT);</span><br><span class="line">    <span class="keyword">if</span> (panic_on_exception_triage) &#123;</span><br><span class="line">        panic(<span class="string">&quot;called exception_triage when it was forbidden by the boot environment&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    thread = current_thread();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// ================ 分别尝试把异常投递到thread、task最后是host。================</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to raise the exception at the activation level.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mutex = &amp;thread-&gt;mutex;</span><br><span class="line">    <span class="keyword">if</span> (KERN_SUCCESS == check_exc_receiver_dependency(exception, thread-&gt;exc_actions, mutex))</span><br><span class="line">    &#123;</span><br><span class="line">        kr = exception_deliver(thread, exception, code, codeCnt, thread-&gt;exc_actions, mutex);</span><br><span class="line">        <span class="keyword">if</span> (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Maybe the task level will handle it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    task = current_task();</span><br><span class="line">    mutex = &amp;task-&gt;lock;</span><br><span class="line">    <span class="keyword">if</span> (KERN_SUCCESS == check_exc_receiver_dependency(exception, task-&gt;exc_actions, mutex))</span><br><span class="line">    &#123;</span><br><span class="line">        kr = exception_deliver(thread, exception, code, codeCnt, task-&gt;exc_actions, mutex);</span><br><span class="line">        <span class="keyword">if</span> (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * How about at the host level?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    host_priv = host_priv_self();</span><br><span class="line">    mutex = &amp;host_priv-&gt;lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (KERN_SUCCESS == check_exc_receiver_dependency(exception, host_priv-&gt;exc_actions, mutex))</span><br><span class="line">    &#123;</span><br><span class="line">        kr = exception_deliver(thread, exception, code, codeCnt, host_priv-&gt;exc_actions, mutex);</span><br><span class="line">        <span class="keyword">if</span> (kr == KERN_SUCCESS || kr == MACH_RCV_PORT_DIED)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> ((exception != EXC_CRASH) &amp;&amp; (exception != EXC_RESOURCE) &amp;&amp;</span><br><span class="line">        (exception != EXC_GUARD) &amp;&amp; (exception != EXC_CORPSE_NOTIFY))</span><br><span class="line">        thread_exception_return();</span><br><span class="line">    <span class="keyword">return</span> kr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 位于 osfmk/kern/exception.c</span></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">exception_deliver</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">thread_t</span>        thread,</span></span><br><span class="line"><span class="params">    <span class="type">exception_type_t</span>    exception,</span></span><br><span class="line"><span class="params">    <span class="type">mach_exception_data_t</span>   code,</span></span><br><span class="line"><span class="params">    <span class="type">mach_msg_type_number_t</span>  codeCnt,</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> exception_action *excp,</span></span><br><span class="line"><span class="params">    <span class="type">lck_mtx_t</span>           *mutex)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...  <span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (behavior) &#123;</span><br><span class="line">        <span class="keyword">case</span> EXCEPTION_STATE: &#123;</span><br><span class="line">            <span class="type">mach_msg_type_number_t</span> state_cnt;</span><br><span class="line">            <span class="type">thread_state_data_t</span> state;</span><br><span class="line">            </span><br><span class="line">            c_thr_exc_raise_state++;</span><br><span class="line">            state_cnt = _MachineStateCount[flavor];</span><br><span class="line">            kr = thread_getstatus(thread, flavor,</span><br><span class="line">                                  (<span class="type">thread_state_t</span>)state,</span><br><span class="line">                                  &amp;state_cnt);</span><br><span class="line">            <span class="keyword">if</span> (kr == KERN_SUCCESS) &#123;</span><br><span class="line">                <span class="keyword">if</span> (code64) &#123;</span><br><span class="line">                    kr = mach_exception_raise_state(exc_port,</span><br><span class="line">                                                    exception,</span><br><span class="line">                                                    code,</span><br><span class="line">                                                    codeCnt,</span><br><span class="line">                                                    &amp;flavor,</span><br><span class="line">                                                    state, state_cnt,</span><br><span class="line">                                                    state, &amp;state_cnt);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    kr = exception_raise_state(exc_port, exception,</span><br><span class="line">                                               small_code,</span><br><span class="line">                                               codeCnt,</span><br><span class="line">                                               &amp;flavor,</span><br><span class="line">                                               state, state_cnt,</span><br><span class="line">                                               state, &amp;state_cnt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (kr == MACH_MSG_SUCCESS &amp;&amp; exception != EXC_CORPSE_NOTIFY)</span><br><span class="line">                    kr = thread_setstatus(thread, flavor,</span><br><span class="line">                                          (<span class="type">thread_state_t</span>)state,</span><br><span class="line">                                          state_cnt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> kr;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> EXCEPTION_DEFAULT:</span><br><span class="line">            c_thr_exc_raise++;</span><br><span class="line">            <span class="keyword">if</span> (code64) &#123;</span><br><span class="line">                kr = mach_exception_raise(exc_port,</span><br><span class="line">                                          retrieve_thread_self_fast(thread),</span><br><span class="line">                                          retrieve_task_self_fast(thread-&gt;task),</span><br><span class="line">                                          exception,</span><br><span class="line">                                          code,</span><br><span class="line">                                          codeCnt);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                kr = exception_raise(exc_port,</span><br><span class="line">                                     retrieve_thread_self_fast(thread),</span><br><span class="line">                                     retrieve_task_self_fast(thread-&gt;task),</span><br><span class="line">                                     exception,</span><br><span class="line">                                     small_code, </span><br><span class="line">                                     codeCnt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> kr;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> EXCEPTION_STATE_IDENTITY: &#123;</span><br><span class="line">            <span class="type">mach_msg_type_number_t</span> state_cnt;</span><br><span class="line">            <span class="type">thread_state_data_t</span> state;</span><br><span class="line">            </span><br><span class="line">            c_thr_exc_raise_state_id++;</span><br><span class="line">            state_cnt = _MachineStateCount[flavor];</span><br><span class="line">            kr = thread_getstatus(thread, flavor,</span><br><span class="line">                                  (<span class="type">thread_state_t</span>)state,</span><br><span class="line">                                  &amp;state_cnt);</span><br><span class="line">            <span class="keyword">if</span> (kr == KERN_SUCCESS) &#123;</span><br><span class="line">                <span class="keyword">if</span> (code64) &#123;</span><br><span class="line">                    kr = mach_exception_raise_state_identity(exc_port,</span><br><span class="line">                                                             retrieve_thread_self_fast(thread),</span><br><span class="line">                                                             retrieve_task_self_fast(thread-&gt;task),</span><br><span class="line">                                                             exception,</span><br><span class="line">                                                             code, </span><br><span class="line">                                                             codeCnt,</span><br><span class="line">                                                             &amp;flavor,</span><br><span class="line">                                                             state, state_cnt,</span><br><span class="line">                                                             state, &amp;state_cnt);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    kr = exception_raise_state_identity(exc_port,</span><br><span class="line">                                                        retrieve_thread_self_fast(thread),</span><br><span class="line">                                                        retrieve_task_self_fast(thread-&gt;task),</span><br><span class="line">                                                        exception,</span><br><span class="line">                                                        small_code, </span><br><span class="line">                                                        codeCnt,</span><br><span class="line">                                                        &amp;flavor,</span><br><span class="line">                                                        state, state_cnt,</span><br><span class="line">                                                        state, &amp;state_cnt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (kr == MACH_MSG_SUCCESS &amp;&amp; exception != EXC_CORPSE_NOTIFY)</span><br><span class="line">                    kr = thread_setstatus(thread, flavor,</span><br><span class="line">                                          (<span class="type">thread_state_t</span>)state,</span><br><span class="line">                                          state_cnt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> kr;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            panic (<span class="string">&quot;bad exception behavior!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> KERN_FAILURE; </span><br><span class="line">    &#125;<span class="comment">/* switch */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>当第一个BSD进程调用bsdinit_task()函数(<code>源码位于bsd/kern/bsd_init.c</code>)启动时，这函数还调用了ux_handler_init()函数(<code>位于bsd/uxkern/ux_exception.c</code>)设置了一个Mach内核线程跑ux_handler()的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 位于bsd/kern/bsd_init.c</span></span><br><span class="line"><span class="comment">/* Called with kernel funnel held */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bsdinit_task</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//  ...省略</span></span><br><span class="line"></span><br><span class="line">  ux_handler_init(); <span class="comment">// 初始化handler</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置port</span></span><br><span class="line">  thread = current_thread();</span><br><span class="line">  (<span class="type">void</span>) host_set_exception_ports(host_priv_self(),</span><br><span class="line">     EXC_MASK_ALL &amp; ~(EXC_MASK_RPC_ALERT),<span class="comment">//pilotfish (shark) needs this port</span></span><br><span class="line">     (<span class="type">mach_port_t</span>) ux_exception_port,</span><br><span class="line">     EXCEPTION_DEFAULT| MACH_EXCEPTION_CODES,</span><br><span class="line">     <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  ut = (<span class="type">uthread_t</span>)get_bsdthread_info(thread);</span><br><span class="line"></span><br><span class="line">  bsd_init_task = get_threadtask(thread);</span><br><span class="line">  init_task_failure_data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_MACF</span></span><br><span class="line">  mac_cred_label_associate_user(p-&gt;p_ucred);</span><br><span class="line">  mac_task_label_update_cred (p-&gt;p_ucred, (<span class="keyword">struct</span> task *) p-&gt;task);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  load_init_program(p);</span><br><span class="line">  lock_trace = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>每一个thread、task及host自身都有一个异常端口数组，通过调用xxx_set_exception_ports()（xxx为thread、task或host）可以设置这些异常端口。 xxx_set_exception_ports()第四个参数为exception_behavior_t behavior，这将会使用到与行为相匹配的实现（exc.defs 或  mach_exc.defs）。<br>各种行为都在host层被catch_[mach]_exception_xxx处理，64位的对应的是有mach函数(可在/bsd/uxkern/ux_exception.c查看)。<br>这些函数通过调用ux_exception()将异常转换为对应的UNIX信号，并通过threadsignal()将信号投递到出错线程。</p>
<p>所以，如果异常是栈溢出，那么signal是SIGSEGV而不是SIGBUS；如果进程退出了或者线程/进程未准备好处理signal，所注册的signal()是无法接收信号的。</p>
<img src="/images/iOS/exception_handler.png" class="" title="exception_handler">

<p>把Mach exception 和 UNIX signal 的转换制表后，如下</p>
<table>
<thead>
<tr>
<th>exception type</th>
<th>signal</th>
</tr>
</thead>
<tbody><tr>
<td>EXC_BAD_ACCESS</td>
<td>1、SIGSEGV (KERN_INVALID_ADDRESS)  <br>  2、SIGBUS(其它)</td>
</tr>
<tr>
<td>EXC_BAD_INSTRUCTION</td>
<td>SIGILL</td>
</tr>
<tr>
<td>EXC_ARITHMETIC</td>
<td>SIGFPE</td>
</tr>
<tr>
<td>EXC_EMULATION</td>
<td>SIGEMT</td>
</tr>
<tr>
<td>EXC_SOFTWARE</td>
<td>1、SIGSYS(EXC_UNIX_BAD_SYSCALL) <br> 2、SIGPIPE(EXC_UNIX_BAD_PIPE) <br> 3、SIGABRT(EXC_UNIX_ABORT) <br> 4、SIGKILL(EXC_SOFT_SIGNAL)</td>
</tr>
<tr>
<td>EXC_BREAKPOINT</td>
<td>SIGTRAP ()</td>
</tr>
</tbody></table>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>在Mach中，异常是通过内核中的主要设施-消息传递机制-进行处理的。一个异常与一条消息并无差别，由出错的线程或任务（通过 msg_send()）发送，并通过一个处理程（通过 msg_recv()）接收。<br>由于Mach的异常以消息机制处理而不是通过函数调用，exception messages可以被转发到先前注册的Mach exception处理程序。这意味着你可以插入一个exception处理程序，而不干扰现有的无论是调试器或Apple’s crash reporter。可以使用mach_msg() // flag MACH_SEND_MSG发送原始消息到以前注册的处理程序的Mach端口，将消息转发到一个现有的处理程序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">catchMACHExceptions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">kern_return_t</span> rc = <span class="number">0</span>;</span><br><span class="line">    <span class="type">exception_mask_t</span> excMask = EXC_MASK_BAD_ACCESS |</span><br><span class="line">    EXC_MASK_BAD_INSTRUCTION |</span><br><span class="line">    EXC_MASK_ARITHMETIC |</span><br><span class="line">    EXC_MASK_SOFTWARE |</span><br><span class="line">    EXC_MASK_BREAKPOINT;</span><br><span class="line">    </span><br><span class="line">    rc = <span class="built_in">mach_port_allocate</span>(<span class="built_in">mach_task_self</span>(), MACH_PORT_RIGHT_RECEIVE, &amp;myExceptionPort);</span><br><span class="line">    <span class="keyword">if</span> (rc != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;-------&gt;Fail to allocate exception port\\\\\\\\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rc = <span class="built_in">mach_port_insert_right</span>(<span class="built_in">mach_task_self</span>(), myExceptionPort, myExceptionPort, MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line">    <span class="keyword">if</span> (rc != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;--------&gt;Fail to insert right&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rc = <span class="built_in">thread_set_exception_ports</span>(<span class="built_in">mach_thread_self</span>(), excMask, myExceptionPort, EXCEPTION_DEFAULT, MACHINE_THREAD_STATE);</span><br><span class="line">    <span class="keyword">if</span> (rc != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;--------&gt;Fail to  set exception\\\\\\\\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// at the end of catchMachExceptions, spawn the exception handling thread</span></span><br><span class="line">    <span class="type">pthread_t</span> thread;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;thread, <span class="literal">NULL</span>, exc_handler, <span class="literal">NULL</span>);</span><br><span class="line">&#125; <span class="comment">// end catchMACHExceptions</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">exc_handler</span><span class="params">(<span class="type">void</span> *ignored)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Exception handler – runs a message loop. Refactored into a standalone function</span></span><br><span class="line">    <span class="comment">// so as to allow easy insertion into a thread (can be in same program or different)</span></span><br><span class="line">    <span class="type">mach_msg_return_t</span> rc;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Exc handler listening\\\\\\\\n&quot;</span>);</span><br><span class="line">    <span class="comment">// The exception message, straight from mach/exc.defs (following MIG processing) // copied here for ease of reference.</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">mach_msg_header_t</span> Head;</span><br><span class="line">        <span class="comment">/* start of the kernel processed data */</span></span><br><span class="line">        <span class="type">mach_msg_body_t</span> msgh_body;</span><br><span class="line">        <span class="type">mach_msg_port_descriptor_t</span> thread;</span><br><span class="line">        <span class="type">mach_msg_port_descriptor_t</span> task;</span><br><span class="line">        <span class="comment">/* end of the kernel processed data */</span></span><br><span class="line">        NDR_record_t NDR;</span><br><span class="line">        <span class="type">exception_type_t</span> exception;</span><br><span class="line">        <span class="type">mach_msg_type_number_t</span> codeCnt;</span><br><span class="line">        <span class="type">integer_t</span> code[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> flavor;</span><br><span class="line">        <span class="type">mach_msg_type_number_t</span> old_stateCnt;</span><br><span class="line">        <span class="type">natural_t</span> old_state[<span class="number">144</span>];</span><br><span class="line">    &#125; Request;</span><br><span class="line">    </span><br><span class="line">    Request exc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rep_msg</span> &#123;</span><br><span class="line">        <span class="type">mach_msg_header_t</span> Head;</span><br><span class="line">        NDR_record_t NDR;</span><br><span class="line">        <span class="type">kern_return_t</span> RetCode;</span><br><span class="line">    &#125; rep_msg;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="comment">// Message Loop: Block indefinitely until we get a message, which has to be</span></span><br><span class="line">        <span class="comment">// 这里会阻塞，直到接收到exception message，或者线程被中断。</span></span><br><span class="line">        <span class="comment">// an exception message (nothing else arrives on an exception port)</span></span><br><span class="line">        rc = <span class="built_in">mach_msg</span>( &amp;exc.Head,</span><br><span class="line">                      MACH_RCV_MSG|MACH_RCV_LARGE,</span><br><span class="line">                      <span class="number">0</span>,</span><br><span class="line">                      <span class="built_in">sizeof</span>(Request),</span><br><span class="line">                      myExceptionPort, <span class="comment">// Remember this was global – that&#x27;s why.</span></span><br><span class="line">                      MACH_MSG_TIMEOUT_NONE,</span><br><span class="line">                      MACH_PORT_NULL);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(rc != MACH_MSG_SUCCESS) &#123;</span><br><span class="line">            <span class="comment">/*... */</span></span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Normally we would call exc_server or other. In this example, however, we wish</span></span><br><span class="line">        <span class="comment">// to demonstrate the message contents:</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Got message %d. Exception : %d Flavor: %d. Code %lld/%lld. State count is %d\\\\\\\\n&quot;</span> ,</span><br><span class="line">               exc.Head.msgh_id, exc.exception, exc.flavor,</span><br><span class="line">               exc.code[<span class="number">0</span>], exc.code[<span class="number">1</span>], <span class="comment">// can also print as 64-bit quantity</span></span><br><span class="line">               exc.old_stateCnt);</span><br><span class="line">        </span><br><span class="line">        rep_msg.Head = exc.Head;</span><br><span class="line">        rep_msg.NDR = exc.NDR;</span><br><span class="line">        rep_msg.RetCode = KERN_FAILURE;</span><br><span class="line">        </span><br><span class="line">        <span class="type">kern_return_t</span> result;</span><br><span class="line">        <span class="keyword">if</span> (rc == MACH_MSG_SUCCESS) &#123;</span><br><span class="line">            result = <span class="built_in">mach_msg</span>(&amp;rep_msg.Head,</span><br><span class="line">                              MACH_SEND_MSG,</span><br><span class="line">                              <span class="built_in">sizeof</span> (rep_msg),</span><br><span class="line">                              <span class="number">0</span>,</span><br><span class="line">                              MACH_PORT_NULL,</span><br><span class="line">                              MACH_MSG_TIMEOUT_NONE,</span><br><span class="line">                              MACH_PORT_NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="comment">// end exc_handler</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来，我们测试一下。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">    [self test]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">Exc handler listening</span><br><span class="line">Got message <span class="number">2401</span>. <span class="keyword">Exception</span> : 1 <span class="type">Flavor</span>: <span class="number">0</span>. Code <span class="number">2</span>/<span class="number">1486065656</span>. State count <span class="keyword">is</span> <span class="number">8</span></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>

<p>我们可以查看<code>mach/exception_types.h</code> 对exception type的定义</p>
<p>Exception:  1,  即为EXC_BAD_ACCESS<br>code:       2,  即KERN_PROTECTION_FAILURE</p>
<p>而ux_exception() 函数告诉我们Code与signal是怎么转换的。<br>也就是 Exception = EXC_BAD_ACCESS， code = 2 对应的是SIGBUS信号，又因为为是stack overflow，信号应该是SIGSEGV。<br>那么结这个exception就是:</p>
<blockquote>
<p>Exception Type: EXC_BAD_ACCESS (SIGSEGV)<br>Exception Subtype: KERN_PROTECTION_FAILURE</p>
</blockquote>
<p>再试试其他的：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">int *pi <span class="operator">=</span> (int*)<span class="number">0</span>x00001111<span class="comment">;</span></span><br><span class="line">*pi <span class="operator">=</span> <span class="number">17</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Exc handler listening<br>Got message 2401. Exception : 1 Flavor: 0. Code 1/4369. State count is 8(lldb) </p>
</blockquote>
<blockquote>
<p>Exception Type: EXC_BAD_ACCESS (SIGSEGV)<br>Exception Subtype: KERN_INVALID_ADDRESS</p>
</blockquote>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>除了上面硬件产生的信号，另外还有软件产生的信号。软件产生的信号来自kill()、pthread_kill()两个函数的调用，大概过程是这样的：kill()/pthread_kill() –&gt; … –&gt; psignal_internal() –&gt; act_set_astbsd()。最终也会调用act_set_astbsd()发送信号到目标线程。这意味着Mach exception流程是不会走的。<br>另外，在abort()源码注释着：<code>&lt;rdar://problem/7397932&gt; abort() should call pthread_kill to deliver a signal to the aborting thread</code> , 它是这样调用的(void)pthread_kill(pthread_self(), SIGABRT);。Apple’s Crash Reporter 把<code>SIGABRT</code>的Mach exception type记为<code>EXC_CRASH</code>，不同与上面转变表。</p>
<blockquote>
<p>Exception Type: EXC_CRASH (SIGABRT)<br>Exception Codes: 0x0000000000000000, 0x0000000000000000</p>
</blockquote>
<p>所以尽管Mach exception handle 比 UNIX signal handle 更有优势，但我们还是须要注册signal handle用于处理EXC_SOFTWARE/EXC_CRASH。</p>
<span id="more"></span>

<h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>崩溃日志的字段认识</p>
<ul>
<li>Incident Identifier： 事件标识符，每个crash文件对应一个唯一的标识符。</li>
<li>CrashReporter Key： 匿名设备标识符。</li>
<li>Hardware Model：设备型号；</li>
<li>Process： 进程名；</li>
<li>Identifier：app Identifier；</li>
<li>Exception Type： 异常类型；</li>
<li>Exception Codes： 异常代码；</li>
<li>Termination Reason：进程被结束的原因</li>
</ul>
<p>Crash Reports  (<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvY29udGVudC90ZWNobm90ZXMvdG4yMTUxL19pbmRleC5odG1s">https://developer.apple.com/library/content/technotes/tn2151/_index.html<i class="fa fa-external-link-alt"></i></span>)</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS Crash Grab</category>
      </categories>
      <tags>
        <tag>iOS崩溃</tag>
        <tag>iOS Crash Grab</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS设计模式</title>
    <url>/iOS/designpatten/index.html</url>
    <content><![CDATA[<h2 id="一、编程中的六大设计原则？"><a href="#一、编程中的六大设计原则？" class="headerlink" title="一、编程中的六大设计原则？"></a>一、编程中的六大设计原则？</h2><h3 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h3><p>通俗地讲就是一个类只做一件事</p>
<ul>
<li><code>CALayer</code>：动画和视图的显示。</li>
<li><code>UIView</code>：只负责事件传递、事件响应。</li>
</ul>
<h3 id="2-开闭原则"><a href="#2-开闭原则" class="headerlink" title="2.开闭原则"></a>2.开闭原则</h3><p>对修改关闭，对扩展开放。<br>要考虑到后续的扩展性，而不是在原有的基础上来回修改</p>
<h3 id="3-接口隔离原则"><a href="#3-接口隔离原则" class="headerlink" title="3.接口隔离原则"></a>3.接口隔离原则</h3><p>使用多个专门的协议、而不是一个庞大臃肿的协议</p>
<ul>
<li><code>UITableviewDelegate</code></li>
<li><code>UITableViewDataSource</code></li>
</ul>
<h3 id="4-依赖倒置原则"><a href="#4-依赖倒置原则" class="headerlink" title="4.依赖倒置原则"></a>4.依赖倒置原则</h3><p>抽象不应该依赖于具体实现、具体实现可以依赖于抽象。<br>调用接口感觉不到内部是如何操作的</p>
<h3 id="5-里氏替换原则"><a href="#5-里氏替换原则" class="headerlink" title="5.里氏替换原则"></a>5.里氏替换原则</h3><p>父类可以被子类无缝替换，且原有的功能不受任何影响</p>
<p>例如 KVO</p>
<h3 id="6-迪米特法则"><a href="#6-迪米特法则" class="headerlink" title="6.迪米特法则"></a>6.迪米特法则</h3><p>一个对象应当对其他对象尽可能少的了解，实现高聚合、低耦合</p>
<h1 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h1><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81Yjk1MjZjMWU1MWQ0NTBlNjk3MzFkYzI=">面向对象设计的六大设计原则（附 Demo 及 UML 类图）- J_Knight_<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS设计模式</category>
      </categories>
      <tags>
        <tag>iOS设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Hybrid</title>
    <url>/iOS/hybrid/hybrid.html</url>
    <content><![CDATA[<h1 id="Hybrid"><a href="#Hybrid" class="headerlink" title="Hybrid"></a>Hybrid</h1><p>为什么需要这种设计，或者技术方案，我们就不多说了,但是我还是要强调几点个人的见解</p>
<ul>
<li>最好不要大面积使用此方案，以免影响用户体验，最好别超过项目的30%。</li>
<li>在某些页面变化比较大，而又不太需要性能的页面，采取此设计非常合适</li>
<li>还有一个非常重要的，一定要注意，此交互方案在app内是异步线程，注意要回到主线程处理UI。安卓和iOS都是如此！！！</li>
</ul>
<h2 id="在安卓上面"><a href="#在安卓上面" class="headerlink" title="在安卓上面"></a>在安卓上面</h2><p>我们有三种方案，分别是 </p>
<ol>
<li>Native提供方法，js调用Native方法</li>
<li>Native在本地注入js方法并且调用</li>
<li>Webview拦截Ajax请求，并做业务处理</li>
</ol>
<h2 id="Native提供方法，js调用Native方法"><a href="#Native提供方法，js调用Native方法" class="headerlink" title="Native提供方法，js调用Native方法"></a>Native提供方法，js调用Native方法</h2><ul>
<li>native注入对象（有一系列供js使用的方法）以及提供给js调用的名称。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webView.addJavascriptInterface(<span class="keyword">new</span> <span class="title class_">HybridJsInterface</span>(),<span class="string">&quot;HybridJSInterface&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>native提供可以供js调用的方法。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HybridJsInterface</span> &#123;</span><br><span class="line">    <span class="meta">@JavascriptInterface</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String text)</span></span><br><span class="line">    Log.i(<span class="string">&quot;method hello&quot;</span>,<span class="string">&quot;text=&quot;</span>+text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>js调用native的方法。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hybrid</span>(<span class="params"></span>)&#123;    </span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">HybridJSInterface</span>.<span class="title function_">hello</span>(<span class="string">&quot;hello hybrid&quot;</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Native在本地注入js方法并且调用"><a href="#Native在本地注入js方法并且调用" class="headerlink" title="Native在本地注入js方法并且调用"></a>Native在本地注入js方法并且调用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    function helloJs()&#123;</span> </span><br><span class="line"><span class="comment">//        alert(&quot;hello js&quot;);</span> </span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;function helloJs()&#123; alert(&#x27;hello js&#x27;);&#125;&quot;</span>;</span><br><span class="line"><span class="comment">//script是js方法对应的字符串</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    mWebContent.evaluateJavascript(script, <span class="literal">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mWebContent.loadUrl(<span class="string">&quot;javascript:&quot;</span> + script);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">handle</span> <span class="operator">=</span> <span class="string">&quot;helloJs()&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">      mWebContent.evaluateJavascript(handle, <span class="literal">null</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mWebContent.loadUrl(<span class="string">&quot;javascript:&quot;</span> + handle);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h2 id="Webview拦截Ajax请求，并做业务处理"><a href="#Webview拦截Ajax请求，并做业务处理" class="headerlink" title="Webview拦截Ajax请求，并做业务处理"></a>Webview拦截Ajax请求，并做业务处理</h2><ol>
<li><p>native拦截h5发过来的请求协议（自定义协议）。<br>webview位置拦截的WebViewClient对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">webView.setWebViewClient(<span class="keyword">new</span> <span class="title class_">HybridWebViewClient</span>());</span><br></pre></td></tr></table></figure>
<p>HybridWebViewClient重写shouldOverrideUrlLoading方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> &#123;<span class="type">Uri</span> <span class="variable">parse</span> <span class="operator">=</span> Uri.parse(url);</span><br><span class="line">       <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> parse.getPath();witch (path) &#123;</span><br><span class="line">           <span class="comment">//TODO</span> </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>js那边发起请求协议。</p>
</li>
</ol>
<h2 id="方案分析"><a href="#方案分析" class="headerlink" title="方案分析"></a>方案分析</h2><p>这三种方案单独使用都比较有局限性。</p>
<ul>
<li><p>方案一的思路是native提前给h5实现好h5需要使用的方法，方法调用完全由h5控制，缺陷是h5调用的功能实现都由native实现，当h5页面中需要新功能的时候需要修改native才能支持。</p>
</li>
<li><p>方案二的思路是js提前给native提供方法，方法调用完全由native控制，缺陷是当js提供了新的方法那么需要修改native主动调用才能使用新功能。</p>
</li>
<li><p>方案三的思路是native拦截h5发过了的请求进行分发控制，js需要使用的功能是native已经提前准备好的，使用不同的url进行分发来使用，缺陷是h5使用新的功能那么需要修改native提供新功能。</p>
</li>
</ul>
<p>单独使用这三种方案的共同缺点就是js和native都是一个单向的调用，相互太过依赖。要是三种方案都用上是不是可以解决问题呢，其实根本问题不在这里，而在于这些方案都没有办法动态扩展，也就是说native一旦完成之后那么单纯靠js是很难完成功能扩展的。我们需要一种可以适应一定程度动态扩展的方案，那就让h5作为项目主导，native提供服务。 </p>
<h3 id="hybrid设计"><a href="#hybrid设计" class="headerlink" title="hybrid设计"></a>hybrid设计</h3><p>总体设计思路是h5控制整个业务流程以及交互流程。h5那边负责发命令并且回调，native负责响应命令。我是采用方案三来实现，客户端需要做的就是预先处理好这些命令（url）。既然是响应命令那么首先就需要把和业务无关的命令给整理出来，比较通用的包括下面内容（不一定全）：</p>
<ul>
<li>header控制。</li>
</ul>
<p>heade的样式可以参考新闻类app的详情页（这里不截图），包括内容：左边按钮（多个），右边按钮（多个），主标题，副标题。</p>
<p>需要做的控制是左、右按钮是否显示、显示的文本及图标以及点击按钮的回调，主、副标题是否显示及显示内容。</p>
<ul>
<li>页面刷新。</li>
</ul>
<p>页面刷新用于内容改变之后h5主动通知native进行刷新。</p>
<ul>
<li>页面跳转。</li>
</ul>
<p>页面跳转分成两种一种是页面跳转到一个新的native页面，另一种是在webview内部做跳转。native的跳转包括内容：跳转动画、跳转目标页、目标页需要的参数。</p>
<ul>
<li>loadingview/progressbar。</li>
</ul>
<p>通常情况建议直接使用h5的进度显示。loadingview的控制包括：loadingview是否显示，loadingview的显示样式（通常只有一种样式）。</p>
<ul>
<li>传感器数据。</li>
</ul>
<p>传感器这部分不一定每个应用都需要。比如某些h5页面需要做活动，那么里面可能会用的摇一摇这样的功能。传感器的控制包括：地理位置、方向、震动、运动量。</p>
<ul>
<li>h5离线包更新。</li>
</ul>
<p>离线包的更新对于h5来说是一条更新命令。不过在native实现上面需要包括：离线包更新检查（版本比较）、离线包下载、离线包解压保存。</p>
<ul>
<li>离线包开关。</li>
</ul>
<p>是否使用离线数据。native需要做的是开启离线包命令之后需要把请求的url映射到本地文件缓存。</p>
<ul>
<li>数据请求。</li>
</ul>
<p>数据请求是指h5需要请求数据不通过直接网络访问，而是通过native自己的网络服务获取数据，尤其是在跨域的情况下很方便。</p>
<h1 id="iOS上面"><a href="#iOS上面" class="headerlink" title="iOS上面"></a>iOS上面</h1><p>同样的，iOS也具备上述三个方案，分别是</p>
<ul>
<li>JavaScriptCore</li>
<li>WebviewLoad</li>
<li>Url Schema</li>
</ul>
<h2 id="JavaScriptCore"><a href="#JavaScriptCore" class="headerlink" title="JavaScriptCore"></a>JavaScriptCore</h2><p>在ios7后，Apple新增了一个JavaScriptCore让Native可以与H5更好的交互（Android早就有了），我们这里主要讨论js如何与Native通信，这里举一个简单的例子：<br>① 首先定义一个js方法，这里注意其中调用了一个没有声明的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//未声明方法</span></span><br><span class="line">    <span class="title function_">print</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，上述未声明方法事实上是Native注入给window对象的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString * scriptPath = [[NSBundle mainBundle] pathForResource:@&quot;hello&quot; ofType:@&quot;js&quot;];</span><br><span class="line">NSString * scriptString = [NSString stringWithContentsOfFile:scriptPath encoding:NSUTF8StringEncoding error:nil];</span><br><span class="line"></span><br><span class="line">JSContext *context = [[JSContext alloc] init];</span><br><span class="line">[context evaluateScript:scriptString];</span><br><span class="line"></span><br><span class="line">self.context[@&quot;print&quot;] = ^(NSString *text) &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;, text&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">JSValue *function = self.context[@&quot;printHello&quot;];</span><br><span class="line">[function callWithArguments:@[]];</span><br></pre></td></tr></table></figure>
<p>这个样子，JavaScript就可以调用Native的方法了，这里Native需要注意方法注入的时机，一般是一旦载入页面便需要载入变量</p>
<ul>
<li>此方案需要特别注意的就是注入时机，要保证JS能调用到注入的方法</li>
</ul>
<h2 id="WebviewLoad"><a href="#WebviewLoad" class="headerlink" title="WebviewLoad"></a>WebviewLoad</h2><p>此方案和安卓一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[self.wkWebView loadHTMLString:@&quot;javascriptStr&quot; baseURL:@&quot;urlstr&quot;];</span><br></pre></td></tr></table></figure>

<h2 id="Url-Schema"><a href="#Url-Schema" class="headerlink" title="Url Schema"></a>Url Schema</h2><p>H5与Native交互的桥梁为Webview，而“联系”的方式是以url schema的方式做的，在用户安装app后，app可以自定义url schema，并且把自定义的url注册在调度中心， 例如</p>
<ul>
<li>dongfangdi://open 打开懂房帝App</li>
<li>weixin:// 打开微信</li>
</ul>
<p>事实上Native能捕捉webview发出的一切请求，所以就算这里不是这种协议，Native也能捕捉，这个协议的意义在于可以在浏览器中直接打开APP，<br>我们在H5获取Native方法时一般是会构造一个这样的请求，使用iframe发出（设置location会有多次请求覆盖的问题）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">requestHybrid</span>(&#123;</span><br><span class="line">  <span class="comment">//创建一个新的webview对话框窗口</span></span><br><span class="line">  <span class="attr">tagname</span>: <span class="string">&#x27;dongfangdiApi&#x27;</span>,</span><br><span class="line">  <span class="comment">//请求参数，会被Native使用</span></span><br><span class="line">  <span class="attr">param</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">//Native处理成功后回调前端的方法</span></span><br><span class="line">  <span class="attr">callback</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//=====&gt;</span></span><br><span class="line"><span class="attr">dongfangdi</span>:<span class="comment">//dongfangdi?callback=dongfangdiAction&amp;param=%7B%22data1%22%3A1%2C%22data2%22%3A2%7D</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于一开始我就强调过，不要完全依赖Hybrid来做app主要框架，它只是为我们提供更多的页面热更新，页面获取Native信息的一种技术。</p>
<ul>
<li>在iOS8.0以后，WebKit框架又给我们提供了一套方案</li>
<li>在WKUserContentController类中,我们可以看到这个方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*! @abstract Adds a script message handler.</span><br><span class="line"> @param scriptMessageHandler The message handler to add.</span><br><span class="line"> @param name The name of the message handler.</span><br><span class="line"> @discussion Adding a scriptMessageHandler adds a function</span><br><span class="line"> window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) for all</span><br><span class="line"> frames.</span><br><span class="line"> */</span><br><span class="line">- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;</span><br></pre></td></tr></table></figure>
然后我们可以在下面这个方法中处理对应的name<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123;&#125;</span><br></pre></td></tr></table></figure>
强烈推荐此方法！！！</li>
</ul>
<p>相关demo代码已放在github上</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phY2stVmluZy9IeWJyaWRfSW50ZXJhY3Rpb24=">https://github.com/Jack-Ving/Hybrid_Interaction<i class="fa fa-external-link-alt"></i></span>  这个是用Vue写的对应的js代码</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phY2stVmluZy9IeWJyaWQ=">https://github.com/Jack-Ving/Hybrid<i class="fa fa-external-link-alt"></i></span>  这个是采用拦截的方式写的OC代码</li>
</ul>
<p>由于仓促，如果遇到什么问题，尽管联系我.</p>
<blockquote>
<p>QQ:727881945  微信:Q727881945</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS</category>
        <category>Hybrid</category>
      </categories>
      <tags>
        <tag>Hybrid</tag>
      </tags>
  </entry>
  <entry>
    <title>app启动优化</title>
    <url>/iOS/interview/applaunchspeed.html</url>
    <content><![CDATA[<h1 id="main-调用之前的加载过程"><a href="#main-调用之前的加载过程" class="headerlink" title="main()调用之前的加载过程"></a>main()调用之前的加载过程</h1><p>App开始启动后，系统首先加载可执行文件（自身App的所有.o文件的集合），然后加载动态链接库dyld，dyld是一个专门用来加载动态链接库的库。 执行从dyld开始，dyld从可执行文件的依赖开始, 递归加载所有的依赖动态链接库。<br>动态链接库包括：iOS 中用到的所有系统 framework，加载OC runtime方法的libobjc，系统级别的libSystem，例如libdispatch(GCD)和libsystem_blocks (Block)。<br>其实无论对于系统的动态链接库还是对于App本身的可执行文件而言，他们都算是image（镜像），而每个App都是以image(镜像)为单位进行加载的，那么image究竟包括哪些呢？</p>
<h2 id="系统使用动态链接有几点好处："><a href="#系统使用动态链接有几点好处：" class="headerlink" title="系统使用动态链接有几点好处："></a>系统使用动态链接有几点好处：</h2><p>代码共用：很多程序都动态链接了这些 lib，但它们在内存和磁盘中中只有一份。 易于维护：由于被依赖的 lib 是程序执行时才链接的，所以这些 lib 很容易做更新，比如libSystem.dylib 是 libSystem.B.dylib 的替身，哪天想升级直接换成libSystem.C.dylib 然后再替换替身就行了。 减少可执行文件体积：相比静态链接，动态链接在编译时不需要打进去，所以可执行文件的体积要小很多。</p>
<img src="/images/iOS/applaunch_macho.jpeg" class="" title="applaunch_macho">

<p>如上图所示，不同进程之间共用系统dylib的_TEXT区，但是各自维护对应的_DATA区。<br>所有动态链接库和我们App中的静态库.a和所有类文件编译后的.o文件最终都是由dyld(the dynamic link editor)，Apple的动态链接器来加载到内存中。每个image都是由一个叫做ImageLoader的类来负责加载（一一对应），那么ImageLoader又是什么呢？</p>
<h2 id="什么是ImageLoader"><a href="#什么是ImageLoader" class="headerlink" title="什么是ImageLoader"></a>什么是ImageLoader</h2><p>image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等，所以 ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。<br>两步走： 在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。 再从可执行文件 image 递归加载所有符号。<br>当然所有这些都发生在我们真正的main函数执行前。</p>
<h2 id="动态链接库加载的具体流程"><a href="#动态链接库加载的具体流程" class="headerlink" title="动态链接库加载的具体流程"></a>动态链接库加载的具体流程</h2><p>动态链接库的加载步骤具体分为5步：</p>
<ul>
<li><p>load dylibs image 读取库镜像文件</p>
</li>
<li><p>Rebase image</p>
</li>
<li><p>Bind image</p>
</li>
<li><p>Objc setup</p>
</li>
<li><p>initializers</p>
</li>
</ul>
<h3 id="load-dylibs-image"><a href="#load-dylibs-image" class="headerlink" title="load dylibs image"></a>load dylibs image</h3><p>在每个动态库的加载过程中， dyld需要：</p>
<ul>
<li>分析所依赖的动态库</li>
<li>找到动态库的mach-o文件</li>
<li>打开文件</li>
<li>验证文件</li>
<li>在系统核心注册文件签名</li>
<li>对动态库的每一个segment调用mmap()</li>
</ul>
<p>通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。 针对这一步骤的优化有：</p>
<ul>
<li>减少非系统库的依赖</li>
<li>合并非系统库</li>
<li>使用静态资源，比如把代码加入主程序</li>
</ul>
<h3 id="rebase-bind"><a href="#rebase-bind" class="headerlink" title="rebase/bind"></a>rebase/bind</h3><p>由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。<br>rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。<br>通过命令行可以查看相关的资源指针:</p>
<blockquote>
<p>xcrun dyldinfo -rebase -bind -lazy_bind myApp.App/myApp</p>
</blockquote>
<p>优化该阶段的关键在于减少__DATA segment中的指针数量。我们可以优化的点有：</p>
<ul>
<li><p>减少Objc类数量， 减少selector数量</p>
</li>
<li><p>减少C++虚函数数量</p>
</li>
<li><p>转而使用swift stuct（其实本质上就是为了减少符号的数量）</p>
</li>
</ul>
<h3 id="Objc-setup"><a href="#Objc-setup" class="headerlink" title="Objc setup"></a>Objc setup</h3><p>这一步主要工作是:</p>
<ul>
<li>注册Objc类 (class registration)</li>
<li>把category的定义插入方法列表 (category registration)</li>
<li>保证每一个selector唯一 (selctor uniquing)</li>
</ul>
<p>由于之前2步骤的优化，这一步实际上没有什么可做的。</p>
<h3 id="initializers"><a href="#initializers" class="headerlink" title="initializers"></a>initializers</h3><p>以上三步属于静态调整(fix-up)，都是在修改__DATA segment中的内容，而这里则开始动态调整，开始在堆和堆栈中写入内容。 在这里的工作有：</p>
<ul>
<li>Objc的+load()函数</li>
<li>C++的构造函数属性函数 形如attribute((constructor)) void DoSomeInitializationWork()</li>
<li>非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度</li>
</ul>
<p>Objc的load函数和C++的静态构造函数采用由底向上的方式执行，来保证每个执行的方法，都可以找到所依赖的动态库。</p>
<img src="/images/iOS/applaunch_dyld.jpeg" class="" title="applaunch_dyld">

<p>上图是在自定义的类XXViewController的+load方法断点的调用堆栈，清楚的看到整个调用栈和顺序：</p>
<ul>
<li>dyld 开始将程序二进制文件初始化</li>
<li>交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号</li>
<li>由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理</li>
<li>runtime 接手后调用 mapimages 做解析和处理，接下来 loadimages 中调用 callloadmethods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</li>
</ul>
<p>至此，可执行文件中和动态库所有的符号(Class，Protocol，Selector，IMP，…)都已经按格式成功加载到内存中，被 runtime 所管理，再这之后，runtime 的那些方法(动态添加 Class、swizzle 等等才能生效)。<br>整个事件由 dyld 主导，完成运行环境的初始化后，配合 ImageLoader 将二进制文件按格式加载到内存， 动态链接依赖库，并由 runtime 负责加载成 objc 定义的结构，所有初始化工作结束后，dyld 调用真正的 main 函数。<br>如果程序刚刚被运行过，那么程序的代码会被dyld缓存，因此即使杀掉进程再次重启加载时间也会相对快一点，如果长时间没有启动或者当前dyld的缓存已经被其他应用占据，那么这次启动所花费的时间就要长一点</p>
<h2 id="main-之前的加载时间如何衡量"><a href="#main-之前的加载时间如何衡量" class="headerlink" title="main()之前的加载时间如何衡量"></a>main()之前的加载时间如何衡量</h2><p>那么问题就来了，那怎么衡量main()之前也就是time1的耗时呢，苹果官方提供了一种方法，那就是在真机调试的时候勾选DYLD_PRINT_STATISTICS选项。</p>
<p>会得到如下形式的输出：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Total</span> pre-main time:  <span class="number">42</span>.<span class="number">89</span> milliseconds (<span class="number">100</span>.<span class="number">0</span>%)</span><br><span class="line">         <span class="attribute">dylib</span> loading time:  <span class="number">38</span>.<span class="number">75</span> milliseconds (<span class="number">90</span>.<span class="number">3</span>%)</span><br><span class="line">        <span class="attribute">rebase</span>/binding time: <span class="number">411015771</span>.<span class="number">6</span> seconds (<span class="number">80806899</span>.<span class="number">0</span>%)</span><br><span class="line">            <span class="attribute">ObjC</span> setup time:   <span class="number">3</span>.<span class="number">69</span> milliseconds (<span class="number">8</span>.<span class="number">6</span>%)</span><br><span class="line">           <span class="attribute">initializer</span> time:  <span class="number">17</span>.<span class="number">68</span> milliseconds (<span class="number">41</span>.<span class="number">2</span>%)</span><br><span class="line">           <span class="attribute">slowest</span> intializers :</span><br><span class="line">             <span class="attribute">libSystem</span>.B.dylib :   <span class="number">3</span>.<span class="number">07</span> milliseconds (<span class="number">7</span>.<span class="number">1</span>%)</span><br><span class="line">   <span class="attribute">libBacktraceRecording</span>.dylib :   <span class="number">2</span>.<span class="number">43</span> milliseconds (<span class="number">5</span>.<span class="number">6</span>%)</span><br><span class="line">    <span class="attribute">libMainThreadChecker</span>.dylib :   <span class="number">9</span>.<span class="number">07</span> milliseconds (<span class="number">21</span>.<span class="number">1</span>%)</span><br><span class="line">                    <span class="attribute">AppProject</span> :   <span class="number">1</span>.<span class="number">56</span> milliseconds (<span class="number">3</span>.<span class="number">6</span>%)</span><br></pre></td></tr></table></figure>

<p>由此可见，最多的用时还是在image加载和OC类的初始化，共占用总时长的79.3%，精简framework的引入和OC类有优化的空间。<br>总结一下：对于main()调用之前的耗时我们可以优化的点有：</p>
<ul>
<li><p>减少不必要的framework，因为动态链接比较耗时</p>
</li>
<li><p>check framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查</p>
</li>
<li><p>合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能，查到当前项目中没有用到的类如下：</p>
</li>
<li><p>删减一些无用的静态变量</p>
</li>
<li><p>删减没有被调用到或者已经废弃的方法</p>
  <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">    方法见：http:<span class="regexp">//</span>stackoverflow.com<span class="regexp">/questions/</span><span class="number">35233564</span>/how-to-find-unused-code-<span class="keyword">in</span>-xcode-<span class="number">7</span></span><br><span class="line">https:<span class="regexp">//</span>developer.Apple.com<span class="regexp">/library/i</span>os<span class="regexp">/documentation/</span>ToolsLanguages<span class="regexp">/Conceptual/</span>Xcode_Overview/CheckingCodeCoverage.html</span><br></pre></td></tr></table></figure></li>
<li><p>将不必须在+load方法中做的事情延迟到+initialize中</p>
</li>
<li><p>尽量不要用C++虚函数(创建虚函数表有开销)</p>
</li>
</ul>
<h1 id="main-调用之后的加载时间"><a href="#main-调用之后的加载时间" class="headerlink" title="main()调用之后的加载时间"></a>main()调用之后的加载时间</h1><p>在main()被调用之后，App的主要工作就是初始化必要的服务，显示首页内容等。而我们的优化也是围绕如何能够快速展现首页来开展。 App通常在AppDelegate类中的- (BOOL)Application:(UIApplication *)Application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions方法中创建首页需要展示的view，然后在当前runloop的末尾，主动调用CA::Transaction::commit完成视图的渲染。<br>而视图的渲染主要涉及三个阶段：</p>
<ul>
<li>准备阶段 这里主要是图片的解码</li>
<li>布局阶段 首页所有UIView的- (void)layoutSubViews()运行</li>
<li>绘制阶段 首页所有UIView的- (void)drawRect:(CGRect)rect运行<br>再加上启动之后必要服务的启动、必要数据的创建和读取，这些就是我们可以尝试优化的地方</li>
</ul>
<p>因此，对于main()函数调用之前我们可以优化的点有：</p>
<ul>
<li>不使用xib，直接视用代码加载首页视图</li>
<li>NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题)</li>
<li>每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log</li>
<li>梳理应用启动时发送的所有网络请求，是否可以统一在异步线程请求</li>
</ul>
<h1 id="如何找到拖慢启动应用时长的瓶颈"><a href="#如何找到拖慢启动应用时长的瓶颈" class="headerlink" title="如何找到拖慢启动应用时长的瓶颈"></a>如何找到拖慢启动应用时长的瓶颈</h1><p>为了找到瓶颈，我们在启动之后的didFinishLauhcning方法开始执行到首页列表页的NewsListViewController的viewDidAppear方法，几乎每个可能比较耗时的流程进行拆分和统计，得到统计数据之后发现： 主要耗时在首页UI构造和渲染(storyboard加载，tabBar/topBar渲染，开屏广告加载/cell注册/日志模块初始化这几个步骤)。</p>
<h1 id="具体优化点"><a href="#具体优化点" class="headerlink" title="具体优化点"></a>具体优化点</h1><p>因此，可以优化的点如下：</p>
<ul>
<li>纯代码方式而不是storyboard加载首页UI。</li>
<li>对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。<br>对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载</li>
<li>对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。</li>
<li>上面统计数据显示展示feed的导航控制器页面(NewsListViewController)比较耗时，对于viewDidLoad以及viewWillAppear方法中尽量去尝试少做，晚做，不做。</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
        <category>面试总结</category>
        <category>app启动优化</category>
      </categories>
      <tags>
        <tag>app启动优化</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS_App_包优化</title>
    <url>/iOS/interview/apppackage.html</url>
    <content><![CDATA[<p>App安装包（ipa文件）是由资源（图片+文档）和可执行文件（二进制文件）两部分组成，安装包瘦身也是从这两部分进行。</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片基本来说在打包完成后，被压缩很少的，听从苹果的建议，使用 png，并且放到<code>Assets.xcassets</code>目录里面<br>删除无用的图片.  LSUnusedResource软件   </p>
<ul>
<li><p>On Demand Resource<br>苹果从iOS 9开始引入了On Demand Resource功能，即一部分图片可以被放置在苹果的服务器上，不随着app的下载而下载，直到用户真正进入到某个页面时才下载这些资源文件。<br>我们考虑可以让某些业务仅在iOS 9及以后版本中可用，然后应用On Demand Resource来优化这些业务的资源。<br>经过了一段时间的开发实验，一切都如同预期，当我们以为On Demand Resource是一个可行的思路时，我们却发现了一个Xcode巨坑的问题：当工程需要支持iOS9以下系统时，Xcode会在打包完成上传app store时失败。On Demand Resource的想法只能搁置。</p>
</li>
<li><p>修复cocoapods带来的图片重复合并问题, 参考今日头条团队的文章（下文提到）</p>
</li>
<li><p>使用tint color</p>
</li>
</ul>
<h2 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h2><p>一定要注意，资源文件是否需要编译进入工程，特别是 readme 这种的，不要编译进项目</p>
<h2 id="Xcode编译选项优化："><a href="#Xcode编译选项优化：" class="headerlink" title="Xcode编译选项优化："></a>Xcode编译选项优化：</h2><ul>
<li>build setting 里 DEAD_CODE_STRIPPING = YES（好像默认就是YES）。 确定 dead code（代码被定义但从未被调用）被剥离，去掉冗余的代码，即使一点冗余代码，编译后体积也是很可观的。</li>
<li>Build Settings-&gt;Optimization Level有几个编译优化选项，release版应该选择Fastest, Smalllest[-Os]，这个选项会开启那些不增加代码大小的全部优化，并让可执行文件尽可能小。</li>
<li>Strip Debug Symbols During Copy 和 Symbols Hidden by Default 在release版本应该设为yes，可以去除不必要的调试符号。Symbols Hidden by Default会把所有符号都定义成”private extern”，设了后会减小体积。</li>
<li>Strip Linked Product：DEBUG下设为NO，RELEASE下设为YES，用于RELEASE模式下缩减app的大小；</li>
</ul>
<blockquote>
<p>另外注意Xcode里面的Deployment选项,Deployment Postprocessing这个配置项如果使用xcode打包，xcode会默认把这个变量置为YES， 如果使用脚本打包，记得设置。Symbols Hidden by Default设置为YES Make Strings Read-Only 设置为YES</p>
</blockquote>
<ul>
<li>编译选项：LTO，即Link Time Optimization。</li>
</ul>
<p>苹果在2016年的WWDC What’s new in LLVM中详细介绍了这一功能。LTO能带来的优化有：<br>（1）将一些函数內联化<br>（2）去除了一些无用代码<br>（3）对程序有全局的优化作用<br>在build setting中开启Link-Time Optimization为Incremental，经测试可缩减安装包大小500KB左右。苹果还声称LTO对app的运行速度也有正向帮助。<br>但LTO也会带来一点副作用。LTO会降低编译链接的速度，因此只建议在打正式包时开启；开启了LTO之后，link map的可读性明显降低，多出了很多数字开头的“类”（LTO的全局优化导致的），导致我们还经常需要手动关闭LTO打包来阅读link map。</p>
<h2 id="启动速度优化"><a href="#启动速度优化" class="headerlink" title="启动速度优化"></a>启动速度优化</h2><h3 id="main-调用之前的耗时我们可以优化的点有："><a href="#main-调用之前的耗时我们可以优化的点有：" class="headerlink" title="main()调用之前的耗时我们可以优化的点有："></a>main()调用之前的耗时我们可以优化的点有：</h3><ul>
<li>减少不必要的framework，因为动态链接比较耗时</li>
<li>check framework应当设为 optional 和 required ，如果该framework在当前App支持的所有- iOS系统版本都存在，那么就设为required，否则就设为 optional，因为 optional 会有些额外的检查</li>
<li>合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能</li>
<li>删减一些无用的静态变量</li>
<li>删减没有被调用到或者已经废弃的方法 <code>-Wall -Wextra -Weverything</code> Other Warning Flags</li>
<li>将不必须在 +load 方法中做的事情延迟到 +initialize 中</li>
<li>尽量不要用 C++ 虚函数(创建虚函数表有开销)</li>
</ul>
<h3 id="main-调用之后的加载时间"><a href="#main-调用之后的加载时间" class="headerlink" title="main()调用之后的加载时间"></a>main()调用之后的加载时间</h3><ul>
<li><p>分析<br>在main()被调用之后，App的主要工作就是初始化必要的服务，显示首页内容等。而我们的优化也是围绕如何能够快速展现首页来开展。<br>App通常在 AppDelegate 类中的didFinishLaunchingWithOptions: 方法中创建首页需要展示的view，然后在当前runloop的末尾，主动调用CA::Transaction::commit完成视图的渲染。</p>
</li>
<li><p>而视图的渲染主要涉及三个阶段：</p>
<ol>
<li>准备阶段 这里主要是图片的解码</li>
<li>布局阶段 首页所有UIView的 layoutSubViews 运行</li>
<li>绘制阶段 首页所有UIView的 drawRect: 运行</li>
<li>再加上启动之后必要服务的启动、必要数据的创建和读取，这些就是我们可以尝试优化的地方</li>
</ol>
</li>
<li><p>main()函数调用之后可以优化的点：</p>
<ul>
<li>不使用是storyboard、xib，直接视用代码加载首页视图</li>
<li>NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题)</li>
<li>每次用NSLog方式打印会隐式的创建一个Calendar，因此需要删减启动时各业务方打的log，或者仅仅针对内测版输出log</li>
<li>梳理应用启动时发送的所有网络请求，是否可以统一在异步线程请求</li>
</ul>
</li>
</ul>
<h2 id="下面引用-今日头条团队优化"><a href="#下面引用-今日头条团队优化" class="headerlink" title="下面引用 今日头条团队优化"></a>下面引用 今日头条团队优化</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hMzE1MWRmZWJjOWM=">干货|今日头条iOS端安装包大小优化—思路与实践<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="分析link-map"><a href="#分析link-map" class="headerlink" title="分析link map"></a>分析link map</h3><p>link map是编译链接时可以生成的一个txt文件，它生成目的就是帮助程序员分析包大小。link map记录了每个方法在当前的二进制架构下占据的空间。通过分析link map，我们可以了解每个类甚至每个方法占据了多少安装包空间。<br>在编译时开启Xcode build setting中的Write Link Map File开关，Xcode就会生成一份link map文件。<br>目前已经有不少开源的分析link map的工具，可以输出每个类、每个静态库占用的空间，并进行排序。通过查看link map，我们可以对二进制代码占据的包大小空间有个直观了解，同时在引入第三方库时也可以使用link map作出评估。</p>
<h3 id="如何进行二进制文件优化"><a href="#如何进行二进制文件优化" class="headerlink" title="如何进行二进制文件优化"></a>如何进行二进制文件优化</h3><h4 id="技术手段排查冗余代码"><a href="#技术手段排查冗余代码" class="headerlink" title="技术手段排查冗余代码"></a>技术手段排查冗余代码</h4><p>没有被引用的类和方法是可以通过技术手段被筛选出来的。<br>MachO文件中有__DATA.__objc_classrefs和__DATA.__objc_selrefs段，分别近似于“被使用的类的集合”和“被使用的方法的集合”。通过取差集的方式可以筛选出未被使用的类和方法。</p>
<h4 id="排查无用类"><a href="#排查无用类" class="headerlink" title="排查无用类"></a>排查无用类</h4><p>使用otool命令可查看__DATA.__objc_classrefs段和__DATA.__objc_classlist段，两者的差集可以认为是定义了但未使用的类。<br>不过__DATA.__objc_classrefs段和__DATA.__objc_classlist段中都只提供了类在二进制文件中的位置地址，而没有提供类名等可读信息。所以在获取到差集后，还需要结合</p>
<blockquote>
<p>otool -o BinaryName</p>
</blockquote>
<p>命令的输出，将地址转换成可读的类名。</p>
<p>使用脚本筛选出差集对应的类后，还需要进行一遍人工选择。因为动态使用的类、从nib或storyboard初始化的类以及在同一个文件中定义的多个类会被误判为未使用的类。这需要结合业务进行一次梳理。</p>
<h4 id="排查无用方法"><a href="#排查无用方法" class="headerlink" title="排查无用方法"></a>排查无用方法</h4><p>所有已经被实现的方法可以通过linkmap来获取，对linkmap做grep操作即可获得结果：</p>
<blockquote>
<p><code>grep &#39;[+|-]\[.*\s.*\]&#39;</code></p>
</blockquote>
<p>而所有已经被使用的方法可以通过对二进制文件逆向获得。使用otool工具逆向二进制文件的__DATA.__objc_selrefs 段，提取可执行文件里引用到的方法名：</p>
<blockquote>
<p>otool -v -s __DATA __objc_selrefs</p>
</blockquote>
<p>使用这种方法取到的差集，还需要排除掉系统API中的protocol，accessor方法等。</p>
<p>使用这个方法，头条排查出了无用方法2000余个，总共累积约2MB，其中最长的方法约7KB。考虑到删除方法的工作量和风险都相对较大，目前我们仅对其中很小一部分进行了删除。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>面试总结</category>
        <category>app 包优化</category>
      </categories>
      <tags>
        <tag>app 包优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Crash Report</title>
    <url>/iOS/interview/crash.html</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS90ZWNobm90ZXMvdG4yMTUxL19pbmRleC5odG1s">官方文档,Understanding and Analyzing Application Crash Reports<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当app发生crash时，系统会生成crash report并存储在设备上.</p>
<ul>
<li><code>Crash Report</code>,  尤其是堆栈信息，在被符号化之前是不可读的。所谓符号化就是把内存地址用可读的函数名和行数来替换。 注意使用 .crash文件</li>
<li><code>Low Memory Report</code> 它没有堆栈信息</li>
</ul>
<img src="/images/iOS/crash_guocheng.jpeg" class="" title="crash_guocheng">


<h1 id="符号化"><a href="#符号化" class="headerlink" title="符号化"></a>符号化</h1><p>编译代码的时候，通过build setting里的<code>Debug Information Format(DEBUG_INFORMATION_FORMAT)</code><br>临时介绍一下：</p>
<ul>
<li>关于DWARF与dSYM<ul>
<li>DWARF与dSYM的关系是，DWARF是文件格式，而dSYM往往指一个单独的文件。在Xcode中如果不做特殊制定，debug information是被保存在executable文件中，可以使用dsymutil从executable中提取dSYM文件。</li>
</ul>
</li>
<li>dsymutil<ul>
<li>dsymutil is a tool to manipulate archived DWARF debug symbol files. 使用dsymutil可以对dSYM文件进行如下操作：从exe_path中提取成dSYM文件、将executable或者object文件中的symbol table dump出来、更新dSYM文件以让dSYM文件包含最新的accelerator tables and other DWARF optimizations。</li>
</ul>
</li>
<li>Debug Info Format<ul>
<li>在Xcode中可以选择DWARF和DWARF with dSYM file，推荐的设置是Debug用DWARF；Release使用DWARF with dSYM file。</li>
</ul>
</li>
<li>使用dSYM file<ul>
<li>如果我们有若干的build，有若干dSYM文件，而名字又有点乱，想知道哪个dSYM跟哪个build匹配，从而可以使用它们呢？办法就是查看UUID。</li>
</ul>
</li>
</ul>
<ol>
<li>一般来说，debug模式构建的app会把Debug符号表存储在编译好的binary信息中，而release模式构建的app会把debug符号表存储在dSYM文件中以节省体积。</li>
</ol>
<blockquote>
<p>同一次构建，app+dSYM+UUID是一套的。如果这几个文件不属于同一次构建，即便是相同的源代码，互相之间在符号化这个事情上也无法互相工作。</p>
</blockquote>
<ol start="2">
<li>你为了分发app而选择Archive（存档）时，Xcode会把app的二进制信息和.dYSM文件存储在你的home文件夹下的某个地方。你可以在Xcode的Organizer里面通过”Archived”选项找到所有你存档过的app。</li>
</ol>
<blockquote>
<p>注意：想要解析来自于测试、app review或者客户的crash report，你需要保留分发出去的那些构建过的archive文件。</p>
</blockquote>
<ol start="3">
<li><p>如果你是通过App Store分发app或者是Test Flight分发的beta版本的app，你将在上传archive到ITC（iTunes Connect）时看见一个“是否将dSYM一起上传”的选项。在上传对话框中，请勾选”在app中包含app符号表”。上传你的dYSM文件对于从TestFlight用户和客户以及愿意分享诊断信息的客户那边接收crash report是很有必要的。</p>
<blockquote>
<p>注意：接收自App Review的crash report是不会被符号化的，及时你再上传你的app到ITC时勾选了包含dSYM文件。任何来自于App Review的crash report都需要在Xcode里做符号化。</p>
</blockquote>
</li>
<li><p>当你的app 发生crash时，一个没有被符号化的crash report会被创建并存储在设备上。</p>
</li>
<li><p>用户可以<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9xYS9xYTE3NDcvX2luZGV4Lmh0bWw=">通过调试已部署的iOS APP<i class="fa fa-external-link-alt"></i></span>里提到的方法来直接从他们的设备里获得crash report。如果你通过AdHoc或者企业证书分发app，这是你唯一能从用户获取crash report的方法。</p>
</li>
<li><p>从设备上直接获取的crash report是没有被符号化的，你需要通过Xcode来符号化。Xcode会结合dSYM文件和你app的二进制信息把堆栈里的每一个地址对应到源代码中。处理后的结果就是一个符号化过的crash report。</p>
</li>
<li><p>如果用户愿意和Apple共享诊断信息，或者用户通过TestFlight下载了你的beta版本app，那crash report会被上传到App Store。</p>
</li>
<li><p>App Store在符号化crash report后会把内部所有的crash reports做汇总并分组，这种聚合（相似crash report）的方法叫做crash聚类。</p>
</li>
<li><p>这些符号化后的crash report可以在你的Xcode的Crash Organizer中进行查看。</p>
</li>
</ol>
<h1 id="Bitcode"><a href="#Bitcode" class="headerlink" title="Bitcode"></a>Bitcode</h1><p>Bitcode（位编码）是一个编译好的项目的中间表现形式。当你在允许bitcode的前提下Archive一个app时，编译器会在二进制中包含bitcode而不是机器码。一旦binary信息被上传到App Store中，bitcode会被再次编译成机器码。也许App Store会在将来二次编译bitcode</p>
<p>虽然当你Archive你的app时会创建dSYM文件，但它们只能用在bitcode binary信息中，并不能用于符号化crash report。 App Store允许你从Xcode或者ITC网站中下载这些随着bitcode编译而产生的dSYM文件。 为了解析从App Review或者给你发送crash report的用户的crash  report，你必须要下载这些dSYM文件，这样才能符号化crash report。 如果是从crash reporting service那里接收crash  report，符号化会自动完成。</p>
<blockquote>
<p>意思就是说，选择了Bitcode，你得从AppStore下载dSYM, 才是真正和binary信息匹配的，而不是你的中间码(提交的原始文件)</p>
</blockquote>
<h1 id="把”隐藏的”符号名还原成原始名"><a href="#把”隐藏的”符号名还原成原始名" class="headerlink" title="把”隐藏的”符号名还原成原始名"></a>把”隐藏的”符号名还原成原始名</h1><p>你把一个带有bitcode的app上传到App Store时，你也许在提交对话框中并没有勾选“上传你的app的符号表信息以便从Apple那边接收符号化过的 report”的选项。 当你选择不发送符号表信息给Apple时，Xcode会在你发送app到ITC之前用晦涩难懂的符号例如”_hidden#109”等来替换你的app里的dSYM文件。Xcode会创建一个原始符号和”隐藏”符号的对照表，并且将其存储在Archive的app文件中的一个bcsymbolmap文件里。每一个dSYM文件都会有一个对应的bcsymbolmap文件。</p>
<img src="/images/iOS/bitcodeapp.png" class="" title="bitcodeapp">

<p>在符号化crash report之前，你需要把那些从ITC中下载下来的dSYM文件中的晦涩信息给解析一下。 如果你使用Xcode中的下载dSYM按钮，这步解析会自动完成。但是，如果你通过ITC网站来下载dSYM的话，你需要打开Terminal并且手动输入下面的命令来做解析（把example的path信息和sSYM信息替换一下）</p>
<blockquote>
<p>xcrun dsymutil -symbol-map ~/Library/Developer/Xcode/Archives/2017-11-23/MyGreatApp\ 11-23-17,\ 12.00\ PM.xcarchive/BCSymbolMaps ~/Downloads/dSYMs/3B15C133-88AA-35B0-B8BA-84AF76826CE0.dSYM</p>
</blockquote>
<p>针对每一个dSYMs文件夹下的dSYM文件都运行一次这条命令。</p>
<h1 id="用Xcode符号化iOS的Crash-report"><a href="#用Xcode符号化iOS的Crash-report" class="headerlink" title="用Xcode符号化iOS的Crash report"></a>用Xcode符号化iOS的Crash report</h1><p>一般来说，Xcode会自动尝试符号化它所有的Crash report。所以你只需要把crash report加到Xcode Organizer就可以了。<br><code>Note</code>：Xcode只认.crash后缀的crash report。如果你收到的crash report没有后缀名或者后缀是txt，在执行下列步骤之前先把它改成.crash。</p>
<ul>
<li>把iOS设备连接到你的Mac</li>
<li>从Window菜单栏选择Devices</li>
<li>在Devices左侧，选择一个设备</li>
<li>点击右边在“Device Information“ 下面的 ”View Device Logs” 按钮</li>
<li>把你的Crash report拖拽到左侧panel中</li>
<li>Xcode会自动符号化Crash report并且显示结果</li>
</ul>
<p>为了符号化一个Crash report，Xcode需要去定位如下信息：</p>
<ul>
<li>崩溃的app的binary信息以及dSYM文件</li>
<li>所有app关联的自定义framework的binary信息以及dSYM文件。如果是从app构建出来的framework，它们的dYSM会随着app的dSYM文件一起拷贝到archive中。如果是第三方的framework，你需要去找作者要dYSM文件。</li>
<li>发生crash时app所依赖的OS的符号表信息。这些符号表包含了特定OS版本（例如iOS9.3.3）上的framework所需调试信息。 OS 符号表的架构具有独特性——一个64位的iOS设备不会包含armv7的符号表。Xcode将要自动拷贝你连接到的特定版本的Mac的符号表。</li>
</ul>
<p>在上述任何一处，如果没有Xcode，你将无法符号化一个crash report，或者只能部分符号化一个crash report。</p>
<h1 id="用atos符号化Crash-report"><a href="#用atos符号化Crash-report" class="headerlink" title="用atos符号化Crash report"></a>用atos符号化Crash report</h1><p><code>atos</code>命令可以把地址里的数字替换成等价的符号。如果调试符号信息是完备的，则atos的输出信息将会包含文件名和对应的资源行数。atos命令可以被用来单独符号化那些未符号化或者部分符号化过的crash report（中的堆栈信息里的地址）。<br>想要使用atos符号化crash report可以按如下方式操作：</p>
<ol>
<li>找到你想要符号化的那一行，记下第二列的binary信息名，以及第三列的地址。</li>
<li>从crash report底部的binary信息名列表中找到那个名字，记下来架构名和加载的地址。</li>
</ol>
<p><code>atos -arch &lt;Binary Architecture&gt; -o &lt;Path to dSYM file&gt;/Contents/Resources/DWARF/&lt;binary image name&gt; -l &lt;load address&gt; &lt;address to symbolicate&gt;</code></p>
<p>使用atos命令的样例，以及结果输出</p>
<blockquote>
<p>$ atos -arch arm64 -o TheElements.app.dSYM/Contents/Resources/DWARF/TheElements -l 0x1000e4000 0x00000001000effdc</p>
</blockquote>
<blockquote>
<p>-[AtomicElementViewController myTransitionDidStop:finished:context:]</p>
</blockquote>
<h1 id="利用符号化排查问题"><a href="#利用符号化排查问题" class="headerlink" title="利用符号化排查问题"></a>利用符号化排查问题</h1><p>xcrun dwarfdump –uuid <Path to dSYM file><br>注意：你必须保存你最开始上传到App Store的发生crash的app的归档文件。dSYM文件和app二进制文件是一一对应，且每次构建都不相同。即便通过相同的源码和配置，再执行一次构建，生成的dSYM文件也无法和之前的crash report做符号化匹配。<br>如果你不在存有这个归档文件，你应该重新提交一次有归档的新版本，以确保再发生crash的时候你可以符号化crash report。</p>
<h1 id="关于异常信息分析，可以查看我写的另外一片怎么抓取崩溃信息那篇文章"><a href="#关于异常信息分析，可以查看我写的另外一片怎么抓取崩溃信息那篇文章" class="headerlink" title="关于异常信息分析，可以查看我写的另外一片怎么抓取崩溃信息那篇文章"></a>关于异常信息分析，可以查看我写的另外一片怎么抓取崩溃信息那篇文章</h1><p><a href="./iOS/crashreport/crashanalysis.html">去看</a></p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>面试总结</category>
        <category>Crash Report</category>
      </categories>
      <tags>
        <tag>Crash Report</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 代理原理</title>
    <url>/iOS/interview/delegate.html</url>
    <content><![CDATA[<p>HTTP 代理存在两种形式:<br>第一种是 RFC 7230 - HTTP/1.1: Message Syntax and Routing（即修订后的 RFC 2616，HTTP/1.1 协议的第一部分）描述的普通代理。这种代理扮演的是「中间人」角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。</p>
<p>第二种是 Tunneling TCP based protocols through Web proxy servers（通过 Web 代理服务器用隧道方式传输基于 TCP 的协议）描述的隧道代理。它通过 HTTP 协议正文部分（Body）完成通讯，以 HTTP 的方式实现任意基于 TCP 的应用层协议代理。这种代理使用 HTTP 的 CONNECT 方法建立连接，但 CONNECT 最开始并不是 RFC 2616 - HTTP/1.1 的一部分，直到 2014 年发布的 HTTP/1.1 修订版中，才增加了对 CONNECT 及隧道代理的描述，详见 RFC 7231 - HTTP/1.1: Semantics and Content。实际上这种代理早就被广泛实现。</p>
<p>本文描述的第一种代理，对应《HTTP 权威指南》一书中第六章「代理」；第二种代理，对应第八章「集成点：网关、隧道及中继」中的 8.5 小节「隧道」。</p>
<h2 id="第一种-Web-代理原理特别简单："><a href="#第一种-Web-代理原理特别简单：" class="headerlink" title="第一种 Web 代理原理特别简单："></a>第一种 Web 代理原理特别简单：</h2><blockquote>
<p>HTTP 客户端向代理发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection: keep-alive），同时向服务器发送请求，并将收到的响应转发给客户端。</p>
</blockquote>
<img src="/images/iOS/web_proxy.jpeg" class="" title="web_proxy">

<p>假如我通过代理访问 A 网站，对于 A 来说，它会把代理当做客户端，完全察觉不到真正客户端的存在，这实现了隐藏客户端 IP 的目的。当然代理也可以修改 HTTP 请求头部，通过 X-Forwarded-IP 这样的自定义头部告诉服务端真正的客户端 IP。但服务器无法验证这个自定义头部真的是由代理添加，还是客户端修改了请求头，所以从 HTTP 头部字段获取 IP 时，需要格外小心。</p>
<p>给浏览器显式的指定代理，需要手动修改浏览器或操作系统相关设置，或者指定 PAC（Proxy Auto-Configuration，自动配置代理）文件自动设置，还有些浏览器支持 WPAD（Web Proxy Autodiscovery Protocol，Web 代理自动发现协议）。显式指定浏览器代理这种方式一般称之为正向代理，浏览器启用正向代理后，会对 HTTP 请求报文做一些修改，来规避老旧代理服务器的一些问题.</p>
<p>还有一种情况是访问 A 网站时，实际上访问的是代理，代理收到请求报文后，再向真正提供服务的服务器发起请求，并将响应转发给浏览器。这种情况一般被称之为反向代理，它可以用来隐藏服务器 IP 及端口。一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。反向代理是 Web 系统最为常见的一种部署方式.</p>
<p>但是，使用我们这个代理服务后，HTTPS 网站完全无法访问，这是为什么呢？答案很简单，这个代理提供的是 HTTP 服务，根本没办法承载 HTTPS 服务。那么是否把这个代理改为 HTTPS 就可以了呢？显然也不可以，因为这种代理的本质是中间人，而 HTTPS 网站的证书认证机制是中间人劫持的克星。普通的 HTTPS 服务中，服务端不验证客户端的证书，中间人可以作为客户端与服务端成功完成 TLS 握手；但是中间人没有证书私钥，无论如何也无法伪造成服务端跟客户端建立 TLS 连接。当然如果你拥有证书私钥，代理证书对应的 HTTPS 网站当然就没问题了。</p>
<h2 id="隧道代理"><a href="#隧道代理" class="headerlink" title="隧道代理"></a>隧道代理</h2><p>第二种 Web 代理的原理也很简单：</p>
<blockquote>
<p>HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。</p>
</blockquote>
<img src="/images/iOS/web_proxy_2.jpeg" class="" title="web_proxy_2">

<p>假如我通过代理访问 A 网站，浏览器首先通过 CONNECT 请求，让代理创建一条到 A 网站的 TCP 连接；一旦 TCP 连接建好，代理无脑转发后续流量即可。所以这种代理，理论上适用于任意基于 TCP 的应用层协议，HTTPS 网站使用的 TLS 协议当然也可以。这也是这种代理为什么被称为隧道的原因。对于 HTTPS 来说，客户端透过代理直接跟服务端进行 TLS 握手协商密钥，所以依然是安全的</p>
<p>浏览器与代理进行 TCP 握手之后，发起了 CONNECT 请求，报文起始行如下：</p>
<blockquote>
<p>CONNECT wangkejie.com:443 HTTP/1.1</p>
</blockquote>
<p>对于 CONNECT 请求来说，只是用来让代理创建 TCP 连接，所以只需要提供服务器域名及端口即可，并不需要具体的资源路径。代理收到这样的请求后，需要与服务端建立 TCP 连接，并响应给浏览器这样一个 HTTP 报文：</p>
<blockquote>
<p>HTTP/1.1 200 Connection Established</p>
</blockquote>
<p>浏览器收到了这个响应报文，就可以认为到服务端的 TCP 连接已经打通，后续直接往这个 TCP 连接写协议数据即可。通过 Wireshark 的 Follow TCP Steam 功能.</p>
<p>而 CONNECT 暴露的域名和端口，对于普通的 HTTPS 请求来说，中间人一样可以拿到（IP 和端口很容易拿到，请求的域名可以通过 DNS Query 或者 TLS Client Hello 中的 Server Name Indication 拿到），所以这种方式并没有增加不安全性。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>面试总结</category>
        <category>HTTP 代理原理</category>
      </categories>
      <tags>
        <tag>HTTP代理原理</tag>
      </tags>
  </entry>
  <entry>
    <title>GCD_BARRIER</title>
    <url>/iOS/interview/gcd-barrier.html</url>
    <content><![CDATA[<h1 id="先注意！！！"><a href="#先注意！！！" class="headerlink" title="先注意！！！"></a>先注意！！！</h1><p>dispatch_barrier_async要在<code>自定义</code>的<code>并发队列</code>里！！！！<br>全局和串形达不到我们要的效果。<br>苹果文档中指出，如果使用的是全局队列或者创建的不是并发队列，则dispatch_barrier_async实际上就相当于dispatch_async。</p>
<p>另外dispatch_barrier_sync会阻塞当前线程，无意义。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>需求： 有n个任务， 需要开启多条线程去执行。 有一个特殊任务m， 需要在n1，n2任务执行完后， 再执行n3， n4任务。</p>
<h1 id="没了，还能有啥，怎么写吗？"><a href="#没了，还能有啥，怎么写吗？" class="headerlink" title="没了，还能有啥，怎么写吗？"></a>没了，还能有啥，怎么写吗？</h1>]]></content>
      <categories>
        <category>iOS</category>
        <category>面试总结</category>
        <category>dispatch_barrier_async</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>barrier</tag>
      </tags>
  </entry>
  <entry>
    <title>面试可能会问的</title>
    <url>/iOS/interview/index.html</url>
    <content><![CDATA[<h1 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h1><ul>
<li><p><a href="./nsurlsession-connection.html">NSURLSession与NSURLConnection区别</a></p>
</li>
<li><p><a href="./iosappsigning.html">苹果签名的原理</a></p>
</li>
<li><p><a href="./protocol.html">面向协议编程</a></p>
</li>
<li><p><a href="./delegate.html">HTTP代理的原理，抓包原理</a></p>
</li>
<li><p><a href="./apppackage.html">app包体积的优化</a></p>
</li>
<li><p><a href="./ipaanalysis.html">ipa的分析</a></p>
</li>
<li><p><a href="./applaunchspeed.html">app启动速度优化</a></p>
</li>
<li><p><a href="./pod.html">pod实现原理</a></p>
</li>
<li><p><a href="./gcd-barrier.html">栅栏函数的用法</a></p>
</li>
<li><p>线程什么时候创建，RunLoop呢</p>
</li>
<li><p><a href="./runloop.html">怎么主动休眠一个RunLoop, 我才应该是退出</a></p>
</li>
<li><p>一个线程代码里面只启动了一个RunLoop，没有其他任务，发生什么 </p>
</li>
<li><p>推流视频(暂时不写，以后工作中需要再补充)</p>
</li>
<li><p>锁： atomic、OSSpinLock、dispatch_semaphore_t / </p>
</li>
<li><p>互斥所： NSLock、NSConditionLock 、NSCondition、NSRecursiveLock、pthread_mutex、@ synchronized、 </p>
</li>
</ul>
<span id="more"></span>

<!-- [测试github demo](https://github.com/bestswifter/MySampleCode) -->


<!-- https://github.com/wenghengcong/LearnCollection -->
<!-- http://wenghengcong.com -->]]></content>
      <categories>
        <category>iOS</category>
        <category>面试可能会问的</category>
      </categories>
      <tags>
        <tag>面试可能会问的</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS App 签名机制</title>
    <url>/iOS/interview/iosappsigning.html</url>
    <content><![CDATA[<p>iOS App 签名机制</p>
<h1 id="先说一下名词"><a href="#先说一下名词" class="headerlink" title="先说一下名词"></a>先说一下名词</h1><h2 id="Certificates"><a href="#Certificates" class="headerlink" title="Certificates"></a>Certificates</h2><p>证书是用来给应用程序签名的，只有经过签名的应用程序才能保证他的来源是可信任的，并且代码是完整的， 未经修改的。<br>众所周知，我们申请一个Certificate之前，需要先申请一个Certificate Signing Request (CSR) 文件，而这个过程中实际上是生成了一对公钥和私钥，保存在你Mac的Keychain中。代码签名正是使用这种基于非对称秘钥的加密方式，用私钥进行签名，用公钥进行验证。如下图所示，在你Mac的keychain的login中存储着相关的公钥和私钥，而证书中包含了公钥。你只能用私钥来进行签名，所以如果没有了私钥，就意味着你不能进行签名了，所以就无法使用这个证书了，此时你只能revoke之前的证书再申请一个。因此在申请完证书时，最好导出并保存好你的私钥。当你想与其他人或其他设备共享证书时，把私钥传给它就可以了。私钥保存在你的Mac中，而苹果生成的Certificate中包含了公钥。当你用自己的私钥对代码签名后，苹果就可以用证书中的公钥来进行验证，确保是你对代码进行了签名，而不是别人冒充你，同时也确保代码的完整性等。</p>
<img src="/images/iOS/cer.jpg" class="">
<p>证书主要分为两类：Development和Production，Development证书用来开发和调试应用程序，Production主要用来分发应用程序（根据证书种类有不同作用），下面是证书的分类信息：（括号内为证书有效期）</p>
<p>（注：不同类型的开发者账户所能创建的证书种类不同）</p>
<ul>
<li><p>Development</p>
<ul>
<li>App Development (1年)：用来开发和真机调试应用程序。</li>
<li>Push Development (1年)：用来调试Apple Push Notification</li>
</ul>
</li>
<li><p>Production</p>
<ul>
<li>In-House and Ad Hoc (3年)：用来发布In-House和AdHoc的应用程序。</li>
<li>App Store ：用来发布提交App Store的应用程序。</li>
<li>MDM CSR</li>
<li>Push Production (1年)：用来在发布版本中使用Apple Push Notification。</li>
<li>Pass Type ID Certificate</li>
<li>Website Push ID Certificate</li>
</ul>
</li>
</ul>
<h2 id="App-ID"><a href="#App-ID" class="headerlink" title="App ID"></a>App ID</h2><p>App ID用于标识一个或者一组App，App ID应该是和Xcode中的Bundle ID是一致的或者匹配的。App ID主要有以下两种：</p>
<p>Explicit App ID：唯一的App ID，这种App ID用于唯一标识一个应用程序，例如com.ABC.demo1，标识Bundle ID为com.ABC.demo1的程序。<br>Wildcard App ID：通配符App ID，用于标识一组应用程序。例如*可以表示所有应用程序，而com.ABC.*可以表示以com.ABC开头的所有应用程序。</p>
<img src="/images/iOS/appidservice.jpg" class="" title="appidservice">

<p>如果你的App使用上述的任何一种service，就要按照要求去配置。</p>
<h2 id="Device"><a href="#Device" class="headerlink" title="Device"></a>Device</h2><p>Device最简单了，就是iOS设备。Devices中包含了该账户中所有可用于开发和测试的设备。 每台设备使用UDID来唯一标识。</p>
<p>每个账户中的设备数量限制是100个。Disable 一台设备也不会增加名额，只能在membership year 开始的时候才能通过删除设备来增加名额。</p>
<h2 id="Provisioning-Profile"><a href="#Provisioning-Profile" class="headerlink" title="Provisioning Profile"></a>Provisioning Profile</h2><p>一个Provisioning Profile文件包含了上述的所有内容：证书、App ID、设备。而且这个Provisioning Profile文件会在打包时嵌入.ipa的包里。</p>
<img src="/images/iOS/ProvisioningProfile.jpg" class="" title="ProvisioningProfile">

<h1 id="言归正传说说签名原理"><a href="#言归正传说说签名原理" class="headerlink" title="言归正传说说签名原理"></a>言归正传说说签名原理</h1><p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY25iYW5nLm5ldC90ZWNoLzMzODYv">参考大神博客<i class="fa fa-external-link-alt"></i></span><br>直接呈现大神总结的：</p>
<img src="/images/iOS/sign3.png" class="">

<h2 id="再列一遍整个流程："><a href="#再列一遍整个流程：" class="headerlink" title="再列一遍整个流程："></a>再列一遍整个流程：</h2><ol>
<li>在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local</li>
<li>苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple</li>
<li>把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。</li>
<li>在苹果后台申请 AppID，配置好设备 ID 列表和 APP 可使用的权限，再加上第③步的证书，组成的数据用私钥 A 签名，把数据和签名一起组成一个 Provisioning Profile 文件，下载到本地 Mac 开发机。</li>
<li>在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第④步得到的 Provisioning Profile 文件打包进 APP 里，文件名为 embedded.mobileprovision，把 APP 安装到手机上。</li>
<li>在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证 embedded.mobileprovision 的数字签名是否正确，里面的证书签名也会再验一遍。</li>
<li>确保了 embedded.mobileprovision 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。</li>
</ol>
<p>开发者证书从签名到认证最终苹果采用的流程大致是这样，还有一些细节像证书有效期/证书类型等就不细说了。</p>
<h2 id="概念和操作"><a href="#概念和操作" class="headerlink" title="概念和操作"></a>概念和操作</h2><p>上面的步骤对应到我们平常具体的操作和概念是这样的：</p>
<ul>
<li>第 1 步对应的是 keychain 里的 “从证书颁发机构请求证书”，这里就本地生成了一对公私钥，保存的 CertificateSigningRequest 就是公钥，私钥保存在本地电脑里。</li>
<li>第 2 步苹果处理，不用管。</li>
<li>第 3 步对应把 CertificateSigningRequest 传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第 1 步生成的，一个是这里下载回来的，keychain 会把这两个证书关联起来，因为他们公私钥是对应的，在XCode选择下载回来的证书时，实际上会找到 keychain 里对应的私钥去签名。这里私钥只有生成它的这台 Mac 有，如果别的 Mac 也要编译签名这个 App 怎么办？答案是把私钥导出给其他 Mac 用，在 keychain 里导出私钥，就会存成 .p12 文件，其他 Mac 打开后就导入了这个私钥。</li>
<li>第 4 步都是在苹果网站上操作，配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件。</li>
<li>第 5 步 XCode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。</li>
<li>第 6 – 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。</li>
</ul>
<h2 id="这里再总结一下这些概念："><a href="#这里再总结一下这些概念：" class="headerlink" title="这里再总结一下这些概念："></a>这里再总结一下这些概念：</h2><ul>
<li>证书：内容是公钥或私钥，由其他机构对其签名组成的数据包。</li>
<li>Entitlements：包含了 App 权限开关列表。</li>
<li>CertificateSigningRequest：本地公钥。</li>
<li>p12：本地私钥，可以导入到其他电脑。</li>
<li>Provisioning Profile：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
        <category>面试总结</category>
        <category>iOS App 签名机制</category>
      </categories>
      <tags>
        <tag>iOS App 签名机制</tag>
      </tags>
  </entry>
  <entry>
    <title>ipa包分析</title>
    <url>/iOS/interview/ipaanalysis.html</url>
    <content><![CDATA[<p>ipa解包后结构:</p>
<ul>
<li>可执行文件<ul>
<li>Mach-O 64-bit executable arm64</li>
<li>Mach-O executable arm_v7</li>
</ul>
</li>
<li>.car，资源打包文件 .nib、.bundle、Localizable.strings</li>
<li>_CodeSignature签名文件<ul>
<li>文件hash列表：存放每个文件的hash值； </li>
<li>XML结构</li>
</ul>
</li>
<li>.mobileprovision </li>
</ul>
<p>可执行文件Mach-O通常有三部分组成</p>
<ul>
<li>头部 (Header): Mach-O文件的架构 比如Mac的 PPC, PPC64, IA-32, x86-64，ios的arm系列。</li>
<li>加载命令(Load commands): 在虚拟内存中指定文件的逻辑结构和布局。</li>
<li>原始段数据（Raw segment data）:可以拥有多个段（segment），每个段可以拥有零个或多个区域（section）。每一个段（segment）都拥有一段虚拟地址映射到进程的地址空间。</li>
</ul>
<img src="/images/iOS/macho_construction.png" class="" title="Mach-O_Construction">

<ol>
<li><p>XCode开启编译选项Write Link Map File<br>XCode -&gt; Project -&gt; Build Settings -&gt; 搜map -&gt; 把Write Link Map File选项设为YES，并指定好linkMap的存储位置<br>特别提醒：打包发布前记得还原为NO</p>
</li>
<li><p>编译后，到编译目录里找到该txt文件，文件名和路径就是上述的Path to Link Map File位于</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">~<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/XXX-XXXXXXXXXXXX/</span>Build<span class="regexp">/Intermediates/</span>XXX.build<span class="regexp">/Debug-iphoneos/</span>XXX.build/</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>example</span><br><span class="line"><span class="regexp">/Users/m</span>xr<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/huashida_home.xcodeproj-fvbzvmahuzlfgqbzehannctanrbl/</span>Build<span class="regexp">/Intermediates.noindex/</span>huashida_home.build<span class="regexp">/Debug-iphoneos/</span><span class="number">4</span>dBookCity.build/<span class="number">4</span>dBookCity-LinkMap-normal-arm64.txt</span><br></pre></td></tr></table></figure>
<p>这个LinkMap里展示了整个可执行文件的全貌，列出了编译后的每一个.o目标文件的信息（包括静态链接库.a里的），以及每一个目标文件的代码段，数据段存储详情。</p>
</li>
</ol>
<h2 id="LinkMap结构"><a href="#LinkMap结构" class="headerlink" title="LinkMap结构"></a>LinkMap结构</h2><ol>
<li><p>首先列出来的是目标文件列表(中括号内为文件编号)：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"># Path: <span class="regexp">/Users/m</span>xr<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/huashida_home.xcodeproj-fvbzvmahuzlfgqbzehannctanrbl/</span>Build<span class="regexp">/Products/</span>Debug-iphoneos<span class="regexp">/4dBookCity.app/</span><span class="number">4</span>dBookCity</span><br><span class="line"># Arch: arm64</span><br><span class="line"># Object files:</span><br><span class="line">[  <span class="number">0</span>] linker synthesized</span><br><span class="line">[  <span class="number">1</span>] <span class="regexp">/Users/m</span>xr<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/huashida_home.xcodeproj-fvbzvmahuzlfgqbzehannctanrbl/</span>Build<span class="regexp">/Intermediates.noindex/</span>huashida_home.build<span class="regexp">/Debug-iphoneos/</span><span class="number">4</span>dBookCity.build<span class="regexp">/Objects-normal/</span>arm64/Bulk_Arrays_12.o</span><br><span class="line">[  <span class="number">2</span>] <span class="regexp">/Users/m</span>xr<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/huashida_home.xcodeproj-fvbzvmahuzlfgqbzehannctanrbl/</span>Build<span class="regexp">/Intermediates.noindex/</span>huashida_home.build<span class="regexp">/Debug-iphoneos/</span><span class="number">4</span>dBookCity.build<span class="regexp">/Objects-normal/</span>arm64/MXRSnapLearnInviteView.o</span><br><span class="line">[  <span class="number">3</span>] <span class="regexp">/Users/m</span>xr<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/huashida_home.xcodeproj-fvbzvmahuzlfgqbzehannctanrbl/</span>Build<span class="regexp">/Intermediates.noindex/</span>huashida_home.build<span class="regexp">/Debug-iphoneos/</span><span class="number">4</span>dBookCity.build<span class="regexp">/Objects-normal/</span>arm64/MXRPKHomeCellViewModel.o</span><br><span class="line">[  <span class="number">4</span>] <span class="regexp">/Users/m</span>xr<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/huashida_home.xcodeproj-fvbzvmahuzlfgqbzehannctanrbl/</span>Build<span class="regexp">/Intermediates.noindex/</span>huashida_home.build<span class="regexp">/Debug-iphoneos/</span><span class="number">4</span>dBookCity.build<span class="regexp">/Objects-normal/</span>arm64/Bulk_Arrays_5.o</span><br><span class="line">[  <span class="number">5</span>] <span class="regexp">/Users/m</span>xr<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/huashida_home.xcodeproj-fvbzvmahuzlfgqbzehannctanrbl/</span>Build<span class="regexp">/Intermediates.noindex/</span>huashida_home.build<span class="regexp">/Debug-iphoneos/</span><span class="number">4</span>dBookCity.build<span class="regexp">/Objects-normal/</span>arm64/MXRBookStoreItemScrollTemplateCell.o</span><br><span class="line">[  <span class="number">6</span>] <span class="regexp">/Users/m</span>xr<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/huashida_home.xcodeproj-fvbzvmahuzlfgqbzehannctanrbl/</span>Build<span class="regexp">/Intermediates.noindex/</span>huashida_home.build<span class="regexp">/Debug-iphoneos/</span><span class="number">4</span>dBookCity.build<span class="regexp">/Objects-normal/</span>arm64/MXRAutoReadViewController.o</span><br><span class="line">[  <span class="number">7</span>] <span class="regexp">/Users/m</span>xr<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/huashida_home.xcodeproj-fvbzvmahuzlfgqbzehannctanrbl/</span>Build<span class="regexp">/Intermediates.noindex/</span>huashida_home.build<span class="regexp">/Debug-iphoneos/</span><span class="number">4</span>dBookCity.build<span class="regexp">/Objects-normal/</span>arm64/MXRQAExerciseQestionTitleView.o</span><br><span class="line">[  <span class="number">8</span>] <span class="regexp">/Users/m</span>xr<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/huashida_home.xcodeproj-fvbzvmahuzlfgqbzehannctanrbl/</span>Build<span class="regexp">/Intermediates.noindex/</span>huashida_home.build<span class="regexp">/Debug-iphoneos/</span><span class="number">4</span>dBookCity.build<span class="regexp">/Objects-normal/</span>arm64/MXRMyTaskController.o</span><br><span class="line">[  <span class="number">9</span>] <span class="regexp">/Users/m</span>xr<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/huashida_home.xcodeproj-fvbzvmahuzlfgqbzehannctanrbl/</span>Build<span class="regexp">/Intermediates.noindex/</span>huashida_home.build<span class="regexp">/Debug-iphoneos/</span><span class="number">4</span>dBookCity.build<span class="regexp">/Objects-normal/</span>arm64/UnityView.o</span><br><span class="line">[ <span class="number">10</span>] <span class="regexp">/Users/m</span>xr<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/huashida_home.xcodeproj-fvbzvmahuzlfgqbzehannctanrbl/</span>Build<span class="regexp">/Intermediates.noindex/</span>huashida_home.build<span class="regexp">/Debug-iphoneos/</span><span class="number">4</span>dBookCity.build<span class="regexp">/Objects-normal/</span>arm64/main.o</span><br><span class="line">...</span><br><span class="line">[<span class="number">5229</span>] <span class="regexp">/Users/m</span>xr<span class="regexp">/Library/</span>Developer<span class="regexp">/Xcode/</span>DerivedData<span class="regexp">/huashida_home.xcodeproj-fvbzvmahuzlfgqbzehannctanrbl/</span>Build<span class="regexp">/Products/</span>Debug-iphoneos/libPods-<span class="number">4</span>dBookCity.a(Pods-<span class="number">4</span>dBookCity-dummy.o)</span><br><span class="line">[<span class="number">5230</span>] <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Toolchains/</span>XcodeDefault.xctoolchain<span class="regexp">/usr/</span>lib<span class="regexp">/arc/</span>libarclite_iphoneos.a(arclite.o)</span><br><span class="line">[<span class="number">5231</span>] <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS11.2.sdk/u</span>sr<span class="regexp">/lib/</span>libobjc.tbd</span><br><span class="line">[<span class="number">5232</span>] <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Toolchains/</span>XcodeDefault.xctoolchain<span class="regexp">/usr/</span>lib<span class="regexp">/clang/</span><span class="number">9.0</span>.<span class="number">0</span><span class="regexp">/lib/</span>darwin/libclang_rt.ios.a(os_version_check.c.o)</span><br><span class="line">[<span class="number">5233</span>] <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS11.2.sdk/</span>System<span class="regexp">/Library/</span>Frameworks<span class="comment">//AudioToolbox.framework/AudioToolbox.tbd</span></span><br><span class="line">[<span class="number">5234</span>] <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS11.2.sdk/</span>System<span class="regexp">/Library/</span>Frameworks<span class="comment">//CoreVideo.framework/CoreVideo.tbd</span></span><br></pre></td></tr></table></figure></li>
<li><p>接着是一个段表，描述各个段在最后编译成的可执行文件中的偏移位置及大小，包括了代码段（__TEXT，保存程序代码段编译后的机器码）和数据段（__DATA，保存变量值）</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Sections:</span></span><br><span class="line"><span class="meta"># Address   Size        Segment Section</span></span><br><span class="line"><span class="number">0</span>x100005B00 <span class="number">0</span>x0304A29C  <span class="variable">__TEXT</span>  <span class="variable">__text</span></span><br><span class="line"><span class="number">0</span>x10304FD9C <span class="number">0</span>x00004BC0  <span class="variable">__TEXT</span>  <span class="variable">__stubs</span></span><br><span class="line"><span class="number">0</span>x10305495C <span class="number">0</span>x000044E8  <span class="variable">__TEXT</span>  <span class="variable">__stub_helper</span></span><br><span class="line"><span class="number">0</span>x103058E50 <span class="number">0</span>x0021563C  <span class="variable">__TEXT</span>  <span class="variable">__cstring</span></span><br><span class="line"><span class="number">0</span>x10326E48C <span class="number">0</span>x000AD400  <span class="variable">__TEXT</span>  <span class="variable">__objc_methname</span></span><br><span class="line"><span class="number">0</span>x10331B88C <span class="number">0</span>x0000E6BA  <span class="variable">__TEXT</span>  <span class="variable">__objc_classname</span></span><br><span class="line"><span class="number">0</span>x103329F46 <span class="number">0</span>x000166E3  <span class="variable">__TEXT</span>  <span class="variable">__objc_methtype</span></span><br><span class="line"><span class="number">0</span>x103340640 <span class="number">0</span>x002A0B60  <span class="variable">__TEXT</span>  <span class="variable">__const</span></span><br><span class="line"><span class="number">0</span>x1035E11A0 <span class="number">0</span>x001346D4  <span class="variable">__TEXT</span>  <span class="variable">__gcc_except_tab</span></span><br><span class="line"><span class="number">0</span>x103715874 <span class="number">0</span>x00008C78  <span class="variable">__TEXT</span>  <span class="variable">__ustring</span></span><br><span class="line"><span class="number">0</span>x10371E4EC <span class="number">0</span>x0004D80C  <span class="variable">__TEXT</span>  <span class="variable">__unwind_info</span></span><br><span class="line"><span class="number">0</span>x10376BCF8 <span class="number">0</span>x00000300  <span class="variable">__TEXT</span>  <span class="variable">__eh_frame</span></span><br><span class="line"><span class="number">0</span>x10376C000 <span class="number">0</span>x000015D8  <span class="variable">__DATA</span>  <span class="variable">__got</span></span><br><span class="line"><span class="number">0</span>x10376D5D8 <span class="number">0</span>x00003280  <span class="variable">__DATA</span>  <span class="variable">__la_symbol_ptr</span></span><br><span class="line"><span class="number">0</span>x103770858 <span class="number">0</span>x00001838  <span class="variable">__DATA</span>  <span class="variable">__mod_init_func</span></span><br><span class="line"><span class="number">0</span>x103772090 <span class="number">0</span>x000FF7F8  <span class="variable">__DATA</span>  <span class="variable">__const</span></span><br><span class="line"><span class="number">0</span>x103871888 <span class="number">0</span>x0006F9C0  <span class="variable">__DATA</span>  <span class="variable">__cfstring</span></span><br><span class="line"><span class="number">0</span>x1038E1248 <span class="number">0</span>x00004778  <span class="variable">__DATA</span>  <span class="variable">__objc_classlist</span></span><br><span class="line"><span class="number">0</span>x1038E59C0 <span class="number">0</span>x00000290  <span class="variable">__DATA</span>  <span class="variable">__objc_nlclslist</span></span><br><span class="line"><span class="number">0</span>x1038E5C50 <span class="number">0</span>x00000708  <span class="variable">__DATA</span>  <span class="variable">__objc_catlist</span></span><br><span class="line"><span class="number">0</span>x1038E6358 <span class="number">0</span>x00000038  <span class="variable">__DATA</span>  <span class="variable">__objc_nlcatlist</span></span><br><span class="line"><span class="number">0</span>x1038E6390 <span class="number">0</span>x00000910  <span class="variable">__DATA</span>  <span class="variable">__objc_protolist</span></span><br><span class="line"><span class="number">0</span>x1038E6CA0 <span class="number">0</span>x00000008  <span class="variable">__DATA</span>  <span class="variable">__objc_imageinfo</span></span><br><span class="line"><span class="number">0</span>x1038E6CA8 <span class="number">0</span>x00206C58  <span class="variable">__DATA</span>  <span class="variable">__objc_const</span></span><br><span class="line"><span class="number">0</span>x103AED900 <span class="number">0</span>x00027F28  <span class="variable">__DATA</span>  <span class="variable">__objc_selrefs</span></span><br><span class="line"><span class="number">0</span>x103B15828 <span class="number">0</span>x000000C0  <span class="variable">__DATA</span>  <span class="variable">__objc_protorefs</span></span><br><span class="line"><span class="number">0</span>x103B158E8 <span class="number">0</span>x000041B8  <span class="variable">__DATA</span>  <span class="variable">__objc_classrefs</span></span><br><span class="line"><span class="number">0</span>x103B19AA0 <span class="number">0</span>x000030C0  <span class="variable">__DATA</span>  <span class="variable">__objc_superrefs</span></span><br><span class="line"><span class="number">0</span>x103B1CB60 <span class="number">0</span>x0000BB54  <span class="variable">__DATA</span>  <span class="variable">__objc_ivar</span></span><br><span class="line"><span class="number">0</span>x103B286B8 <span class="number">0</span>x0002CB00  <span class="variable">__DATA</span>  <span class="variable">__objc_data</span></span><br><span class="line"><span class="number">0</span>x103B551C0 <span class="number">0</span>x01D52748  <span class="variable">__DATA</span>  <span class="variable">__data</span></span><br><span class="line"><span class="number">0</span>x1058A7920 <span class="number">0</span>x00714878  <span class="variable">__DATA</span>  <span class="variable">__bss</span></span><br><span class="line"><span class="number">0</span>x105FBD000 <span class="number">0</span>x0012B978  <span class="variable">__DATA</span>  <span class="variable">__common</span></span><br></pre></td></tr></table></figure>
<p>首列是数据在文件的偏移位置，第二列是这一段占用大小，第三列是段类型，代码段和数据段，第四列是段名称。<br>每一行的数据都紧跟在上一行后面，如第二行__stubs的地址0x10304FD9C就是第一行__text的地址0x100005B00加上大小0x0304A29C，整个可执行文件大致数据分布就是这样。<br>这里可以清楚看到各种类型的数据在最终可执行文件里占的比例，例如__text表示编译后的程序执行语句，__data表示已初始化的全局变量和局部静态变量，__bss表示未初始化的全局变量和局部静态变量，__cstring表示代码里的字符串常量，等等。</p>
</li>
<li><p>接着就是按上表顺序，列出具体的按每个文件列出每个对应字段的位置和占用空间</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"># <span class="selector-tag">Symbols</span>:</span><br><span class="line"># <span class="selector-tag">Address</span>   <span class="selector-tag">Size</span>        <span class="selector-tag">File</span>  <span class="selector-tag">Name</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x100005B00</span> <span class="number">0</span><span class="selector-tag">x000000EC</span>  <span class="selector-attr">[  2]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRSnapLearnInviteView drawRect:]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x100005BEC</span> <span class="number">0</span><span class="selector-tag">x0000024C</span>  <span class="selector-attr">[  2]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRSnapLearnInviteView generatorlogoImageQRCode]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x100005E38</span> <span class="number">0</span><span class="selector-tag">x0000005C</span>  <span class="selector-attr">[  2]</span> <span class="selector-tag">_CGRectMake</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x100005E94</span> <span class="number">0</span><span class="selector-tag">x00000034</span>  <span class="selector-attr">[  2]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRSnapLearnInviteView inviteCode]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x100005EC8</span> <span class="number">0</span><span class="selector-tag">x00000050</span>  <span class="selector-attr">[  2]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRSnapLearnInviteView setInviteCode:]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x100005F18</span> <span class="number">0</span><span class="selector-tag">x0000003C</span>  <span class="selector-attr">[  2]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRSnapLearnInviteView .cxx_destruct]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x100005F54</span> <span class="number">0</span><span class="selector-tag">x000001D8</span>  <span class="selector-attr">[  3]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRPKHomeCellViewModel initWithModel:]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x10000612C</span> <span class="number">0</span><span class="selector-tag">x0000016C</span>  <span class="selector-attr">[  3]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRPKHomeCellViewModel encodeWithCoder:]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x100006298</span> <span class="number">0</span><span class="selector-tag">x00000268</span>  <span class="selector-attr">[  3]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRPKHomeCellViewModel initWithCoder:]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x100006500</span> <span class="number">0</span><span class="selector-tag">x00000040</span>  <span class="selector-attr">[  3]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRPKHomeCellViewModel desc]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x100006540</span> <span class="number">0</span><span class="selector-tag">x00000044</span>  <span class="selector-attr">[  3]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRPKHomeCellViewModel setDesc:]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x100006584</span> <span class="number">0</span><span class="selector-tag">x00000040</span>  <span class="selector-attr">[  3]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRPKHomeCellViewModel name]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x1000065C4</span> <span class="number">0</span><span class="selector-tag">x00000044</span>  <span class="selector-attr">[  3]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRPKHomeCellViewModel setName:]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x100006608</span> <span class="number">0</span><span class="selector-tag">x00000040</span>  <span class="selector-attr">[  3]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRPKHomeCellViewModel pic]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x100006648</span> <span class="number">0</span><span class="selector-tag">x00000044</span>  <span class="selector-attr">[  3]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRPKHomeCellViewModel setPic:]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x10000668C</span> <span class="number">0</span><span class="selector-tag">x00000040</span>  <span class="selector-attr">[  3]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRPKHomeCellViewModel classifyId]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x1000066CC</span> <span class="number">0</span><span class="selector-tag">x00000044</span>  <span class="selector-attr">[  3]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRPKHomeCellViewModel setClassifyId:]</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x100006710</span> <span class="number">0</span><span class="selector-tag">x000000B8</span>  <span class="selector-attr">[  3]</span> <span class="selector-tag">-</span><span class="selector-attr">[MXRPKHomeCellViewModel .cxx_destruct]</span></span><br><span class="line">...</span><br><span class="line"><span class="number">0</span><span class="selector-tag">x1060C82D0</span> <span class="number">0</span><span class="selector-tag">x000000C0</span>  <span class="selector-attr">[3391]</span> <span class="selector-tag">_jerrenv</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x1060C8390</span> <span class="number">0</span><span class="selector-tag">x000204E0</span>  <span class="selector-attr">[4793]</span> <span class="selector-tag">_GC_arrays</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x1060E8870</span> <span class="number">0</span><span class="selector-tag">x00000100</span>  <span class="selector-attr">[4793]</span> <span class="selector-tag">_GC_bm_table</span></span><br><span class="line"><span class="number">0</span><span class="selector-tag">x1060E8970</span> <span class="number">0</span><span class="selector-tag">x00000008</span>  <span class="selector-attr">[4793]</span> <span class="selector-tag">_GC_noop_sink</span></span><br></pre></td></tr></table></figure>
<p>同样首列是数据在文件的偏移地址，第二列是占用大小，第三列是所属文件序号，对应上述Object files列表，最后是名字。</p>
</li>
<li><p>已废弃&amp;多余重复的字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dead Stripped Symbols:</span></span><br><span class="line"><span class="comment">#           Size        File  Name</span></span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000001  [  1] literal string: </span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000005  [  3] literal string: desc</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000005  [  3] literal string: name</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000004  [  3] literal string: pic</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x0000000B  [  3] literal string: classifyId</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x0000000E  [  3] literal string: .cxx_destruct</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x0000000B  [  3] literal string: v24@0:8@16</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000008  [  3] literal string: v16@0:8</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000008  [  3] literal string: @16@0:8</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000001  [  4] literal string: </span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000007  [  4] literal string: System</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x0000000C  [  4] literal string: UnityEngine</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x0000000A  [  4] literal string: System.IO</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000008  [  5] 8-byte-literal</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x0000000C  [  5] literal string: PRIMARY KEY</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x0000000C  [  5] literal string: FOREIGN KEY</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000001  [  5] literal string: </span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000020  [  5] CFString</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000020  [  5] CFString</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000008  [  5] _LKSQL_Type_Text</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000008  [  5] _LKSQL_Type_Int</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000008  [  5] _LKSQL_Type_Double</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000008  [  5] _LKSQL_Type_Blob</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000008  [  5] _LKSQL_Attribute_NotNull</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000008  [  5] _LKSQL_Attribute_PrimaryKey</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000008  [  5] _LKSQL_Attribute_Default</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000008  [  5] _LKSQL_Attribute_Unique</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000008  [  5] _LKSQL_Attribute_Check</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000008  [  5] _LKSQL_Attribute_ForeignKey</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000008  [  5] _LKSQL_Convert_FloatType</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000008  [  5] _LKSQL_Convert_IntType</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000008  [  5] _LKSQL_Convert_BlobType</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000008  [  5] _LKSQL_Mapping_Inherit</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000008  [  5] _LKSQL_Mapping_Binding</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000008  [  5] _LKSQL_Mapping_UserCalculate</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000008  [  5] _LKDB_TypeKey</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000008  [  5] _LKDB_TypeKey_Model</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000008  [  5] _LKDB_TypeKey_JSON</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000008  [  5] _LKDB_TypeKey_Combo</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000004  [4311] 4-byte-literal</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000004  [4311] 4-byte-literal</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000004  [4311] 4-byte-literal</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000004  [4311] 4-byte-literal</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000008  [4311] 8-byte-literal</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000008  [4312] 8-byte-literal</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000014  [4320] __ZN15PxcConvexMeshHLC2EP17PxConvexMeshData_</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000004  [4320] 4-byte-literal</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000004  [4320] 4-byte-literal</span><br><span class="line">&lt;&lt;<span class="string">dead&gt;&gt;    0x00000004  [4319] 4-byte-literal</span></span><br><span class="line"><span class="string">&lt;&lt;dead</span>&gt;&gt;    0x00000076  [4319] literal string: /Applications/buildAgent/work/3d1e9e6e6eefaa7f/SDKs/compiler/iphone/../../../LowLevel/common/include/utils/PxcArray.h</span><br></pre></td></tr></table></figure>
<p>这个文件可以让你了解整个APP编译后的情况，也许从中可以发现一些异常，还可以用这个文件计算静态链接库在项目里占的大小，有时候我们在项目里链了很多第三方库，导致APP体积变大很多，我们想确切知道每个库占用了多大空间，可以给我们优化提供方向。LinkMap里有了每个目标文件每个方法每个数据的占用大小数据，所以只要写个脚本，就可以统计出每个.o最后的大小，属于一个.a静态链接库的.o加起来，就是这个库在APP里占用的空间大小。</p>
</li>
</ol>
<h2 id="关于Xcode的Other-Linker-Flags"><a href="#关于Xcode的Other-Linker-Flags" class="headerlink" title="关于Xcode的Other Linker Flags"></a>关于Xcode的Other Linker Flags</h2><ul>
<li>背景</li>
</ul>
<p>在ios开发过程中，有时候会用到第三方的静态库(.a文件)，然后导入后发现编译正常但运行时会出现selector not recognized的错误，从而导致app闪退。接着仔细阅读库文件的说明文档，你可能会在文档中发现诸如在Other Linker Flags中加入-ObjC或者-all_load这样的解决方法。<br>那么，Other Linker Flags到底是用来干什么的呢？还有-ObjC和-all_load到底发挥了什么作用呢？</p>
<ul>
<li>链接器</li>
</ul>
<p>首先，要说明一下Other Linker Flags到底是用来干嘛的。说白了，就是ld命令除了默认参数外的其他参数。ld命令实现的是链接器的工作，详细说明可以在终端man ld查看。<br>如果有人不清楚链接器是什么东西的话，我可以作个简单的说明。<br>一个程序从简单易读的代码到可执行文件往往要经历以下步骤：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">源代码 &gt; 预处理器 &gt; 编译器 &gt; 汇编器 &gt; 机器码 &gt; 链接器 &gt; 可执行文件</span><br></pre></td></tr></table></figure>
<p>源文件经过一系列处理以后，会生成对应的.obj文件，然后一个项目必然会有许多.obj文件，并且这些文件之间会有各种各样的联系，例如函数调用。链接器做的事就是把这些目标文件和所用的一些库链接在一起形成一个完整的可执行文件。</p>
<ul>
<li>为什么会闪退</li>
</ul>
<p>Objective-C的链接器并不会为每个方法建立符号表，而是仅仅为类建立了符号表。这样的话，如果静态库中定义了已存在的一个类的分类，链接器就会以为这个类已经存在，不会把分类和核心类的代码合起来。这样的话，在最后的可执行文件中，就会缺少分类里的代码，这样函数调用就失败了。</p>
<ul>
<li>解决方法</li>
</ul>
<p>解决方法在背景那块我就提到了，就是在Other Linker Flags里加上所需的参数，用到的参数一般有以下3个：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">`-ObjC`       : 链接器会把静态库中所有的类和分类都加载到最后的可执行文件中</span><br><span class="line">`-force_load` : 需要指定要进行全部加载的库文件的路径,避免引用多个第三方库时会出现类名重叠的冲突</span><br><span class="line">`-all_load`   : 让链接器把所有找到的目标文件都加载到可执行文件中，不建议使用</span><br><span class="line">`-dead_strip` : 删除多余的库符号，不建议使用</span><br></pre></td></tr></table></figure>
<p>在编译Objective-C源文件到目标文件时，编译器并不知道方法的对应实现，只能在运行时才知道，所以编译器只会为类生成链接符号，对类中的方法不会生成链接符号。由于Category方法并不对应一个新类，所以不会生成链接符号，链接器也不会将Category方法合并到原始的类中，最终导致链接器忽略了Category方法，不会将其链接到可执行文件中。</p>
<p>当静态库中只有分类而没有类的时候，-ObjC参数就会失效了。这时候，就需要使用-all_load或者-force_load了。<br>-all_load会让链接器把所有找到的目标文件都加载到可执行文件中，但是千万不要随便使用这个参数！假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到ld: duplicate symbol错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到-ObjC失效的情况下使用-force_load参数。<br>-force_load所做的事情跟-all_load其实是一样的，但是-force_load需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载。<br>在能拿到静态库源码情况下，建议对.a库重新打包，删除部分重复的symbol。<br>在拿不到静态库源码情况下 ,只能采用-force_load+库文件路径方法设置Other Linker Flags,逐个加静态库,最终完美解决两个静态库存在同名文件冲突,发现那个静态库无法调用,就采用以下语句添加进去。<br>-force_load EightPartyCall/standaloneclass/BaiduSocialShare/WX/libWeChatSDK<br>(-force_load后面为静态库文件路径,根据自己项目对应路径)</p>
<p>也可以拆分静态库</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ cd /LibSDK </span><br><span class="line">$ ls</span><br><span class="line">libiot<span class="selector-class">.sdk</span><span class="selector-class">.a</span></span><br><span class="line">$ lipo -info libiot<span class="selector-class">.sdk</span><span class="selector-class">.a</span></span><br><span class="line">Architectures <span class="keyword">in</span> the fat file: libiot<span class="selector-class">.sdk</span><span class="selector-class">.a</span> are: armv7 arm64 </span><br><span class="line">$  lipo libiot<span class="selector-class">.sdk</span><span class="selector-class">.a</span> -thin armv7 -output tbv7<span class="selector-class">.a</span></span><br><span class="line">$  lipo libiot<span class="selector-class">.sdk</span><span class="selector-class">.a</span> -thin arm64 -output tb64<span class="selector-class">.a</span></span><br><span class="line">$ ls</span><br><span class="line">libiot<span class="selector-class">.sdk</span><span class="selector-class">.a</span>        tb64<span class="selector-class">.a</span>      tbv7<span class="selector-class">.a</span></span><br><span class="line">$ ar -d tbv7<span class="selector-class">.a</span> AsyncSocket<span class="selector-class">.o</span></span><br><span class="line">$ ar -d tb64<span class="selector-class">.a</span> AsyncSocket<span class="selector-class">.o</span></span><br><span class="line">$ lipo -create tbv7<span class="selector-class">.a</span> tbv64<span class="selector-class">.a</span> -output libSun.a</span><br></pre></td></tr></table></figure>

<p>lipo源于mac系统要制作兼容powerpc平台和intel平台的程序。<br>lipo 是一个在 Mac OS X 中处理通用程序（Universal Binaries）的工具。现在发售或者提供下载的许多（几乎所有）程序都打上了“Universal”标志，意味着它们同时具有 PowerPC 和 Intel 芯片能够处理的代码。不过既然你可能不在意其中的一个，你就能够使用 lipo 来给你的程序“瘦身”。</p>
<h2 id="写了一堆乱七八糟的"><a href="#写了一堆乱七八糟的" class="headerlink" title="写了一堆乱七八糟的"></a>写了一堆乱七八糟的</h2><p>参考app包优化<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hMzE1MWRmZWJjOWM=">干货|今日头条iOS端安装包大小优化—思路与实践<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>面试总结</category>
        <category>ipa包分析</category>
      </categories>
      <tags>
        <tag>ipa包分析</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/iOS/interview/memory.html</url>
    <content><![CDATA[<h3 id="在-Obj-C-中，如何检测内存泄漏-你知道哪些方式"><a href="#在-Obj-C-中，如何检测内存泄漏-你知道哪些方式" class="headerlink" title="在 Obj-C 中，如何检测内存泄漏?你知道哪些方式?"></a>在 Obj-C 中，如何检测内存泄漏?你知道哪些方式?</h3><ul>
<li>Memory Leaks</li>
<li>Alloctions</li>
<li>Analyse</li>
<li>Debug Memory Graph</li>
<li>MLeaksFinder</li>
</ul>
<p>泄露的内存主要有以下两种:</p>
<ul>
<li>Laek Memory 这种是忘记 Release 操作所泄露的内存。</li>
<li>Abandon Memory 这种是循环引用，无法释放掉的内存。</li>
</ul>
<h3 id="什么是-悬垂指针-什么是-野指针"><a href="#什么是-悬垂指针-什么是-野指针" class="headerlink" title="什么是 悬垂指针?什么是 野指针?"></a>什么是 悬垂指针?什么是 野指针?</h3><ul>
<li>悬垂指针<br>指针指向的内存已经被释放了，但是指针还存在，这就是一个 悬垂指针 或者说 迷途指针</li>
<li>野指针<br>没有进行初始化的指针，其实都是 野指针</li>
</ul>
<h3 id="retain-copy-assign-weak-Unsafe-Unretain-关键字的理解"><a href="#retain-copy-assign-weak-Unsafe-Unretain-关键字的理解" class="headerlink" title="retain,copy,assign,weak,_Unsafe_Unretain 关键字的理解"></a>retain,copy,assign,weak,_Unsafe_Unretain 关键字的理解</h3><h3 id="深拷贝-和-浅拷贝-的概念，集合类深拷贝如何实现"><a href="#深拷贝-和-浅拷贝-的概念，集合类深拷贝如何实现" class="headerlink" title="深拷贝 和 浅拷贝 的概念，集合类深拷贝如何实现"></a>深拷贝 和 浅拷贝 的概念，集合类深拷贝如何实现</h3><h3 id="自动引用计数应遵循的原则"><a href="#自动引用计数应遵循的原则" class="headerlink" title="自动引用计数应遵循的原则"></a>自动引用计数应遵循的原则</h3><h3 id="Dealloc"><a href="#Dealloc" class="headerlink" title="Dealloc"></a>Dealloc</h3><ol>
<li><p>Dealloc调用流程</p>
<ol>
<li>首先调用 _objc_rootDealloc()</li>
<li>接下来调用 rootDealloc() </li>
<li>这时候会判断是否可以被释放，判断的依据主要有 5 个，判断是否有以上五种情况<ul>
<li>NONPointer_ISA</li>
<li>weakly_reference </li>
<li>has_assoc</li>
<li>has_cxx_dtor</li>
<li>has_sidetable_rc</li>
</ul>
</li>
<li>如果有以上五中任意一种，将会调用 object_dispose()方法，做下一步的处理。 </li>
<li>如果没有之前五种情况的任意一种，则可以执行释放操作，C 函数的 free()。 5.执行完毕。</li>
</ol>
</li>
<li><p>object_dispose() 调用流程。</p>
<ol>
<li>直接调用 objc_destructInstance()。</li>
<li>之后调用 C 函数的 free()。</li>
</ol>
</li>
<li><p>objc_destructInstance() 调用流程</p>
<ol>
<li>先判断 hasCxxDtor，如果有 C++ 的相关内容，要调用 object_cxxDestruct() ，销毁 C++ 相关的内容。</li>
<li>再判断hasAssocitatedObjects，如果有的话，要调用object_remove_associations()， 销毁关联对象的一系列操作。</li>
<li>然后调用 clearDeallocating()。 </li>
<li>执行完毕。</li>
</ol>
</li>
<li><p>clearDeallocating() 调用流程。</p>
<ol>
<li>先执行 sideTable_clearDellocating()。</li>
<li>再执行 weak_clear_no_lock,在这一步骤中，会将指向该对象的弱引用指针置为 nil。</li>
<li>接下来执行 table.refcnts.eraser()，从引用计数表中擦除该对象的引用计数。</li>
<li>至此为止，Dealloc 的执行流程结束。   </li>
</ol>
</li>
</ol>
<h3 id="内存管理方案"><a href="#内存管理方案" class="headerlink" title="内存管理方案"></a>内存管理方案</h3><ul>
<li>taggedPointer :存储小对象如 NSNumber。深入理解 Tagged Pointer</li>
<li>NONPOINTER_ISA(非指针型的 isa):在 64 位架构下，isa 指针是占 64 比特位的，实际上只有 30 多位就<br>已经够用了，为了提高利用率，剩余的比特位存储了内存管理的相关数据内容。</li>
<li>散列表:复杂的数据结构，包括了引用计数表和弱引用表<br>通过 SideTables()结构来实现的，SideTables()结构下，有很多 SideTable 的数据结构。<br>而 sideTable 当中包含了自旋锁，引用计数表，弱引用表。 SideTables()实际上是一个哈希表，通过对象的地址来计算该对象的引用计数在哪个 sideTable 中。</li>
</ul>
<h3 id="autoreleasePool-的数据结构"><a href="#autoreleasePool-的数据结构" class="headerlink" title="@autoreleasePool 的数据结构?"></a>@autoreleasePool 的数据结构?</h3><p>简单说是双向链表，每张链表头尾相接，有 parent、child 指针 每创建一个池子，会在首部创建一个 哨兵 对象,作为标记<br>最外层池子的顶端会有一个 next 指针。当链表容量满了，就会在链表的顶端，并指向下一张表。</p>
<h3 id="BAD-ACCESS-在什么情况下出现"><a href="#BAD-ACCESS-在什么情况下出现" class="headerlink" title="BAD_ACCESS 在什么情况下出现?"></a>BAD_ACCESS 在什么情况下出现?</h3><p>访问了已经被销毁的内存空间，就会报出这个错误。<br>根本原因是有 <code>悬垂指针</code> 没有被释放。</p>
<h3 id="autoReleasePool-什么时候释放"><a href="#autoReleasePool-什么时候释放" class="headerlink" title="autoReleasePool 什么时候释放?"></a>autoReleasePool 什么时候释放?</h3><p>App 启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是<br>_wrapRunLoopWithAutoreleasePoolHandler()。</p>
<ul>
<li><p>第一个 Observer 监视的事件是 Entry(即将进入 Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是 -2147483647，优先级最高，保证创 建释放池发生在其他所有回调之前。</p>
</li>
<li><p>第二个 Observer 监视了两个事件: BeforeWaiting(准备进入休眠) 时调用 _objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池;Exit(即 将退出 Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
</li>
<li><p>线程结束 Tls_dealloc 释放</p>
</li>
<li><p>runloop进入任务，结束任务时 释放</p>
</li>
</ul>
]]></content>
      <categories>
        <category>内存管理</category>
      </categories>
      <tags>
        <tag>Autoreleasepool</tag>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>NSURLSession与NSURLConnection区别</title>
    <url>/iOS/interview/nsurlsession-connection.html</url>
    <content><![CDATA[<h2 id="NSURLSession与NSURLConnection区别"><a href="#NSURLSession与NSURLConnection区别" class="headerlink" title="NSURLSession与NSURLConnection区别"></a>NSURLSession与NSURLConnection区别</h2><p>2013 年的 WWDC 大会上，iOS 7.0 推出了 NSURLSession，对 Foundation URL 加载系统进行了彻底的重构，提供了更丰富的 API 来处理网络请求，如：支持 http2.0 协议、直接把数据下载到磁盘、同一 session 发送多个请求、下载是多线程异步处理和提供全局的 session 并可以统一配置等等，提高了 NSURLSession 的易用性、灵活性，更加地适合移动开发的需求。</p>
<p>在iOS9以后，NSURLConnection过期废弃.</p>
<p>NSURLSession 有三种网络操作方案：</p>
<ul>
<li>普通网络请求   <code>NSURLSessionDataTask</code></li>
<li>上传          <code>NSURLSessionUploadTask</code></li>
<li>下载          <code>NSURLSessionDownloadTask</code></li>
</ul>
<p>创建的 task 都是挂起状态，需要 resume 才能启动.</p>
<h2 id="普通网络请求-和-上传网络请求"><a href="#普通网络请求-和-上传网络请求" class="headerlink" title="普通网络请求 和 上传网络请求"></a>普通网络请求 和 上传网络请求</h2><ul>
<li>普通:  当服务器返回的数据较小时，NSURLSession 与 NSURLConnection 执行普通任务的操作步骤没有区别。</li>
<li>上传:  执行上传任务时，NSURLSession 与 NSURLConnection 一样需要设置 POST 请求的请求体进行上传。</li>
</ul>
<h2 id="下载任务方式"><a href="#下载任务方式" class="headerlink" title="下载任务方式"></a>下载任务方式</h2><ul>
<li>NSURLConnection下载文件时，先是将整个文件下载到内存，然后再写入到沙盒，如果文件比较大，就会出现内存暴涨的情况。</li>
<li>而使用 NSURLSessionDownloadTask 下载文件，会默认下载到沙盒中的 tmp 文件中，不会出现内存暴涨的情况，但是在下载完成后会把 tmp 中的临时文件删除，需要在初始化任务方法时，在 completionHandler 回调中增加保存文件的代码。</li>
</ul>
<h2 id="请求方法的控制"><a href="#请求方法的控制" class="headerlink" title="请求方法的控制"></a>请求方法的控制</h2><ul>
<li>NSURLConnection 实例化对象，实例化开始，默认请求就发送(同步发送)，不需要调用 start 方法。而 cancel 可以停止请求的发送，停止后不能继续访问，需要创建新的请求。</li>
<li>NSURLSession 有三个控制方法，取消(cancel)、暂停(suspend)、继续(resume)，暂停以后可以通过继续恢复当前的请求任务。</li>
</ul>
<h2 id="断点续传的方式"><a href="#断点续传的方式" class="headerlink" title="断点续传的方式"></a>断点续传的方式</h2><ul>
<li><p>NSURLConnection 进行断点下载，通过设置访问请求的 HTTPHeaderField 的 Range 属性，开启运行循环，NSURLConnection 的代理方法作为运行循环的事件源，接收到下载数据时代理方法就会持续调用，并使用 NSOutputStream 管道流进行数据保存。</p>
</li>
<li><p>NSURLSession 进行断点下载，当暂停下载任务后，如果 downloadTask（下载任务）为非空，调用 cancelByProducingResumeData:(void (^)(NSData *resumeData))completionHandler 这个方法，这个方法接收一个参数，完成处理代码块，这个代码块有一个 NSData 参数 resumeData，如果 resumeData 非空，我们就保存这个对象到视图控制器的 resumeData 属性中，在点击再次下载时，通过调用[ [self.session downloadTaskWithResumeData:self.resumeData] resume]方法进行继续下载操作。</p>
</li>
</ul>
<p>经过以上比较可以发现，使用 NSURLSession 进行断点下载更加便捷。</p>
<h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><blockquote>
<p><code>NSURLSessionConfiguration</code> 类的参数可以设置配置信息，其决定了 <code>cookie</code>，<code>安全</code>和<code>高速缓存策略</code>，<code>最大主机连接数</code>，<code>资源管理</code>，<code>网络超时</code>等配置。NSURLConnection 不能进行这个配置，相比较与 NSURLConnection 依赖与一个<code>全局的配置</code>对象，缺乏灵活性而言，NSURLSession 有很大的改进了。</p>
</blockquote>
<p>有三个方法来创建NSURLSessionConfiguration:</p>
<ul>
<li><p>defaultSessionConfiguration 使用全局的cache，cookie,使用硬盘来缓存数据。</p>
</li>
<li><p>ephemeralSessionConfiguration 临时session配置，与默认配置相比，这个配置不会将缓存、cookie等存在本地，只会存在内存里，所以当程序退出时，所有的数据都会消失</p>
</li>
<li><p>backgroundSessionConfiguration 后台session配置，与默认配置类似，不同的是会在后台开启另一个线程来处理网络数据。</p>
</li>
</ul>
<p>一旦创建了NSURLSessionConfiguration就可以给它设置各种属性</p>
<p><code>看NSURLSessionConfiguration的头文件:</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSURLSessionConfiguration</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 三种创建方式 */</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)defaultSessionConfiguration;</span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)ephemeralSessionConfiguration;</span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)backgroundSessionConfigurationWithIdentifier:(<span class="built_in">NSString</span> *)identifier <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 当使用上述第三种方式创建后台sessionConfiguration时可以读到初始化时传入的唯一标识，其他创建方式都为空 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *identifier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">缓存策略，默认值是NSURLRequestUseProtocolCachePolicy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSURLRequestCachePolicy</span> requestCachePolicy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给request指定每次接收数据超时间隔，如果下一次接受新数据用时超过该值，则发送一个请求超时给该request。默认为60s */</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> timeoutIntervalForRequest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 给指定resource设定一个超时时间，resource需要在时间到达之前完成。默认是7天。 */</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> timeoutIntervalForResource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定网络传输类型。精切指出传输类型，可以让系统快速响应，提高传输质量，延长电池寿命等。</span></span><br><span class="line"><span class="comment">typedef NS_ENUM(NSUInteger, NSURLRequestNetworkServiceType)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    NSURLNetworkServiceTypeDefault = 0, // 普通网络传输，默认使用这个</span></span><br><span class="line"><span class="comment">    NSURLNetworkServiceTypeVoIP = 1,    // 网络语音通信传输，只能在VoIP使用</span></span><br><span class="line"><span class="comment">    NSURLNetworkServiceTypeVideo = 2,   // 影像传输</span></span><br><span class="line"><span class="comment">    NSURLNetworkServiceTypeBackground = 3, // 网络后台传输，优先级不高时可使用。对用户不需要的网络操作可使用</span></span><br><span class="line"><span class="comment">    NSURLNetworkServiceTypeVoice = 4       // 语音传输</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSURLRequestNetworkServiceType</span> networkServiceType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 是否使用蜂窝网络，默认是yes. */</span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> allowsCellularAccess;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 是否由系统根据性能自动裁量后台任务。默认值是NO。同sessionSendsLaunchEvent一样，只对后台configuration有效。 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">getter</span>=isDiscretionary) <span class="type">BOOL</span> discretionary <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">7</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">如果要为app的插件提供session，需要给这个值赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *sharedContainerIdentifier <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 表示当后台传输结束时，是否启动app.这个属性只对 后台sessionConfiguration 生效，其他configuration类型会自动忽略该值。默认值是YES。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> sessionSendsLaunchEvents <span class="built_in">NS_AVAILABLE</span>(NA, <span class="number">7</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">指定了会话连接中的代理服务器。同样地，大多数面向消费者的应用程序都不需要代理，所以基本上不需要配置这个属性,默认为NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *connectionProxyDictionary;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 确定是否支持SSLProtocol版本的会话</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> SSLProtocol TLSMinimumSupportedProtocol;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">确定是否支持SSLProtocol版本的会话</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> SSLProtocol TLSMaximumSupportedProtocol;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">它可以被用于开启HTTP管道，这可以显着降低请求的加载时间，但是由于没有被服务器广泛支持，默认是禁用的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> HTTPShouldUsePipelining;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">默认为yes,是否提供来自shareCookieStorge的cookie，如果想要自己提供cookie，可以使用HTTPAdditionalHeaders来提供。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> HTTPShouldSetCookies;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Policy for accepting cookies.  This overrides the policy otherwise specified by the cookie storage. */</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSHTTPCookieAcceptPolicy</span> HTTPCookieAcceptPolicy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">指定了一组默认的可以设置出站请求的数据头。这对于跨会话共享信息，如内容类型，语言，用户代理，身份认证，是很有用的。</span></span><br><span class="line"><span class="comment">例如：</span></span><br><span class="line"><span class="comment">    @&#123;@&quot;Accept&quot;: @&quot;application/json&quot;,</span></span><br><span class="line"><span class="comment">     @&quot;Accept-Language&quot;: @&quot;en&quot;,</span></span><br><span class="line"><span class="comment">     @&quot;Authorization&quot;: authString,</span></span><br><span class="line"><span class="comment">     @&quot;User-Agent&quot;: userAgentString</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span> *HTTPAdditionalHeaders;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">同时连接一个host的最大数。iOS默认是4.APP是作为一个整体来看的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> HTTPMaximumConnectionsPerHost;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">存储cookie，清除存储，直接set为nil即可。</span></span><br><span class="line"><span class="comment">对于默认和后台的session，使用sharedHTTPCookieStorage。</span></span><br><span class="line"><span class="comment">对于短暂的session，cookie仅仅储存到内存，session失效时会自动清除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">retain</span>) <span class="built_in">NSHTTPCookieStorage</span> *HTTPCookieStorage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">证书存储，如果不使用，可set为nil.</span></span><br><span class="line"><span class="comment">默认和后台session，默认使用的sharedCredentialStorage.</span></span><br><span class="line"><span class="comment">短暂的session使用一个私有存储在内存中。session失效会自动清除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">retain</span>) <span class="built_in">NSURLCredentialStorage</span> *URLCredentialStorage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">缓存NSURLRequest的response。</span></span><br><span class="line"><span class="comment">默认的configuration，默认值的是sharedURLCache。</span></span><br><span class="line"><span class="comment">后台的configuration，默认值是nil</span></span><br><span class="line"><span class="comment">短暂的configuration，默认一个私有的cache于内存，session失效，cache自动清除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">retain</span>) <span class="built_in">NSURLCache</span> *URLCache;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable extended background idle mode for any tcp sockets created.    Enabling this mode asks the system to keep the socket open</span></span><br><span class="line"><span class="comment"> *  and delay reclaiming it when the process moves to the background (see https://developer.apple.com/library/ios/technotes/tn2277/_index.html) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> <span class="type">BOOL</span> shouldUseExtendedBackgroundIdleMode <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">处理NSURLRequest的NSURLProtocol的子类。</span></span><br><span class="line"><span class="comment">重要:对后台Session失效。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;Class&gt; *protocolClasses;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h2 id="URLSessionTask"><a href="#URLSessionTask" class="headerlink" title="URLSessionTask"></a>URLSessionTask</h2><p>NSURLSessionTask是一个抽象类，其下有4个实体子类可以直接使用：NSURLSessionDataTask、NSURLSessionUploadTask、NSURLSessionDownloadTask、NSURLSessionStreamTask。这四个子类封装了现代程序四个最基本的网络任务：获取数据，比如JSON或者XML，上传文件和下载文件还有数据流的获取。</p>
<img src="/images/iOS/NSURLSessionTask.png" class="">

<p>NSURLSession比NSURLConnection最方便的地方就是任务可以暂停，继续。在网络请求中，真正去执行下载或者上传任务的就是URLSessionTask，我们来看一下它常用的方法：<br><code>- (void)resume;</code> 当使用NSURLSession创建一个NSURLSessionTask任务时，要手动调用此方法，任务才会开启，而NSURLConnection默认开启。<br><code>- (void)suspend;</code> 暂停任务方法，手动调用会暂停当前任务，再次开启此任务时，会从紧接上次任务开始，会面会说到如何暂停任务再开启任务。<br><code>- (void)cancel;</code> 取消任务。</p>
<p>NSURLSessionTask还有个属性，@property (readonly) NSURLSessionTaskState state; 此属性标识当前任务的状态，枚举类型</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSURLSessionTaskState</span>) &#123;</span><br><span class="line">    <span class="built_in">NSURLSessionTaskStateRunning</span> = <span class="number">0</span>,                     <span class="comment">/* 正在执行 */</span></span><br><span class="line">    <span class="built_in">NSURLSessionTaskStateSuspended</span> = <span class="number">1</span>,                   <span class="comment">/* 暂停状态 */</span></span><br><span class="line">    <span class="built_in">NSURLSessionTaskStateCanceling</span> = <span class="number">2</span>,                   <span class="comment">/* 取消状态*/</span></span><br><span class="line">    <span class="built_in">NSURLSessionTaskStateCompleted</span> = <span class="number">3</span>,                   <span class="comment">/* 任务完成状态 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面说到的四个类，都直接或间接继承NSURLSessionTask，所有NSURLSessionTask的方法或者属性这四个类都有，那么，简单说一下这四个类都是干什么的。</p>
<h3 id="NSURLSessionDataTask"><a href="#NSURLSessionDataTask" class="headerlink" title="NSURLSessionDataTask"></a>NSURLSessionDataTask</h3><p>NSURLSessionDataTask是开发中使用频率最高的，我们平常使用的GET和POST请求都是通过它来实现的，如果请求的数据简单并且不需要对获取的数据进行复杂操作，我们使用 Block 解析返回的数据即可。</p>
<p>另外我们也可以设置session的代理来实时的监听数据，我们可以使用NSURLSession的<code>+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;</code>和<code>+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue;</code>这两个方法来设置代理，具体的协议为<code>NSURLSessionDelegate</code>，它有四个直接或间接子协议<code>NSURLSessionTaskDelegate</code>，<code>NSURLSessionDownloadDelegate</code>和 <code>NSURLSessionStreamDelegate</code>、<code>NSURLSessionDataDelegate</code></p>
<h3 id="NSURLSessionDownloadTask"><a href="#NSURLSessionDownloadTask" class="headerlink" title="NSURLSessionDownloadTask"></a>NSURLSessionDownloadTask</h3><p>NSURLSessionDownloadTask在下载文件的时候，是将数据一点点地写入本地的临时文件。所以在 completionHandler 这个 block 里，我们需要把文件从一个临时地址移动到一个永久的地址保存起来：</p>
<h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>说一下开发中经常用到的断点续传。在开发中，我们经常由于某种原因，在下载或上传的时候往往不能一次性下载或上传完，有可能下载或上传了一半就终止了，这时候当条件满足继续下载或上传时，我们不希望从头开始，这时候就可以使用断点续传。它的大概思路是：</p>
<ul>
<li>某种限制，续传暂停</li>
<li>将暂停后数据（当前数据）保存起来–_resumeData = resumeData;</li>
<li>条件允许续传时，使用resumeData创建新的NSURLSessionTask</li>
</ul>
<h3 id="NSURLSessionUploadTask"><a href="#NSURLSessionUploadTask" class="headerlink" title="NSURLSessionUploadTask"></a>NSURLSessionUploadTask</h3><p>在 NSURLSession 中，文件上传主要使用两种方式：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromFile:(<span class="built_in">NSURL</span> *)fileURL;</span><br><span class="line">- (<span class="built_in">NSURLSessionUploadTask</span> *)uploadTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request fromData:(<span class="built_in">NSData</span> *)bodyData;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>NSURLSession 是iOS7后出来的替代 NSURLConnection 的API;</li>
<li>NSURLSession 通过绑定一个 delegate 在一个网络会话的生命周期里调用某些事件；</li>
<li>NSURLSession 对象是线程安全的；</li>
<li>NSURLSession 默认使用系统提供的delegate，并适当的使用现有的代码使用；</li>
<li>NSURLSession 通过创建 NSURLSessionTask 代表资源被加载的任务，类似 NSURLConnection对象，但相比有更多可控制和定制的 delegate 模型；</li>
<li>NSURLSessionTask 对象创建后是处于挂起状态，只有发-resume消息才会执行；</li>
<li>NSURLSessionTask 的子类 在加载 Data 和 文件下载的使用上有所不同；</li>
<li>NSURLSessionDataTask 接收到资源时会回调 RLSession:dataTask:didReceiveData: 代理method；</li>
<li>NSURLSessionUploadTask 与 NSURLSessionDataTask 的构造方法不同，他需求显示的引用file或data object；</li>
<li>NSURLSessionDownloadTask 会直接把response data写入到临时文件，网络会话结束后，delegate 会发送一个 URLSession:downloadTask:didFinishDownloadingToURL: 消息来处理下载文件，如果中途取消则会生成一个Blob Data以便下次恢复下载；</li>
<li>从iOS9开始，使用NSURLSessionStream可以通过一个给定的主机和端口直接建立TCP/IP连接；</li>
</ol>
<h3 id="NSURLSession的优点"><a href="#NSURLSession的优点" class="headerlink" title="NSURLSession的优点"></a>NSURLSession的优点</h3><ul>
<li><code>后台上传和下载：</code> 只需在创建NSURLSession的时候配置一个选项，就能得到后台网络的所有好处;</li>
<li><code>能够暂停和恢复网络操作：</code> 使用NSURLSession API能够暂停，停止，恢复所有的网络任务，再也完全不需要子类化NSOperation;</li>
<li><code>可配置的容器：</code> 对于NSURLSession里面的requests来说，每个NSURLSession都是可配置的容器。举个例来说，假如你需要设置HTTP header选项，你只用做一次，session里面的每个request就会有同样的配置。</li>
<li><code>提高认证处理：</code>认证是在一个指定的连接基础上完成的。在使用NSURLConnection时，如果发出一个访问，会返回一个任意的request。此时，你就不能确切的知道哪个request收到了访问。而在NSURLSession中，就能用代理处理认证。</li>
<li><code>丰富的代理模式：</code> 在处理认证的时候，NSURLConnection有一些基于异步的block方法，但是它的代理方法就不能处理认证，不管请求是成功或是失败。在NSURLSession中，可以混合使用代理和block方法处理认证。</li>
</ul>
<h1 id="多看下-AFNetworking-的实现"><a href="#多看下-AFNetworking-的实现" class="headerlink" title="多看下 AFNetworking 的实现"></a>多看下 AFNetworking 的实现</h1>]]></content>
      <categories>
        <category>iOS</category>
        <category>面试总结</category>
        <category>NSURLSession与NSURLConnection区别</category>
      </categories>
      <tags>
        <tag>面试总结</tag>
        <tag>NSURLSession</tag>
        <tag>NSURLConnection</tag>
      </tags>
  </entry>
  <entry>
    <title>Cocoapods原理</title>
    <url>/iOS/interview/pod.html</url>
    <content><![CDATA[<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>CocoaPods是用 Ruby 写的，并由若干个 Ruby 包 (gems) 构成的。在解析整合过程中，最重要的几个 gems 分别是： CocoaPods/CocoaPods, CocoaPods/Core, 和 CocoaPods/Xcodeproj (是的，CocoaPods 是一个依赖管理工具 – 利用依赖管理进行构建的！)。</p>
<h2 id="CocoaPods-CocoaPod"><a href="#CocoaPods-CocoaPod" class="headerlink" title="CocoaPods/CocoaPod"></a>CocoaPods/CocoaPod</h2><p>这是是一个面向用户的组件，每当执行一个 pod 命令时，这个组件都将被激活。该组件包括了所有使用 CocoaPods 涉及到的功能，并且还能通过调用所有其它的 gems 来执行任务。</p>
<h2 id="CocoaPods-Core"><a href="#CocoaPods-Core" class="headerlink" title="CocoaPods/Core"></a>CocoaPods/Core</h2><p>Core 组件提供支持与 CocoaPods 相关文件的处理，文件主要是 Podfile 和 podspecs。</p>
<h2 id="Podfile"><a href="#Podfile" class="headerlink" title="Podfile"></a>Podfile</h2><p>Podfile 是一个文件，用于定义项目所需要使用的第三方库。该文件支持高度定制，你可以根据个人喜好对其做出定制。更多相关信息，请查阅 Podfile 指南。</p>
<h2 id="Podspec"><a href="#Podspec" class="headerlink" title="Podspec"></a>Podspec</h2><p>.podspec 也是一个文件，该文件描述了一个库是怎样被添加到工程中的。它支持的功能有：列出源文件、framework、编译选项和某个库所需要的依赖等。</p>
<h2 id="CocoaPods-Xcodeproj"><a href="#CocoaPods-Xcodeproj" class="headerlink" title="CocoaPods/Xcodeproj"></a>CocoaPods/Xcodeproj</h2><p>这个 gem 组件负责所有工程文件的整合。它能够对创建并修改 .xcodeproj 和 .xcworkspace 文件。它也可以作为单独的一个 gem 包使用。如果你想要写一个脚本来方便的修改工程文件，那么可以使用这个 gem。</p>
<h1 id="加载源文件"><a href="#加载源文件" class="headerlink" title="加载源文件"></a>加载源文件</h1><p>CocoaPods 执行的下一步是加载源码。每个 .podspec 文件都包含一个源代码的索引，这些索引一般包裹一个 git 地址和 git tag。它们以 commit SHAs 的方式存储在 ~/Library/Caches/CocoaPods 中。这个路径中文件的创建是由 Core gem 负责的。</p>
<p>CocoaPods 将依照 Podfile、.podspec 和缓存文件的信息将源文件下载到 Pods 目录中。</p>
<h1 id="生成-Pods-xcodeproj"><a href="#生成-Pods-xcodeproj" class="headerlink" title="生成 Pods.xcodeproj"></a>生成 Pods.xcodeproj</h1><p>每次 pod install 执行，如果检测到改动时，CocoaPods 会利用 Xcodeproj gem 组件对 Pods.xcodeproj 进行更新。如果该文件不存在，则用默认配置生成。否则，会将已有的配置项加载至内存中。</p>
<h1 id="安装第三方库"><a href="#安装第三方库" class="headerlink" title="安装第三方库"></a>安装第三方库</h1><p>当 CocoaPods 往工程中添加一个第三方库时，不仅仅是添加代码这么简单，还会添加很多内容。由于每个第三方库有不同的 target，因此对于每个库，都会有几个文件需要添加，每个 target 都需要：</p>
<ul>
<li>一个包含编译选项的 .xcconfig 文件</li>
<li>一个同时包含编译设置和 CocoaPods 默认配置的私有 .xcconfig 文件</li>
<li>一个编译所必须的 prefix.pch 文件</li>
<li>另一个编译必须的文件 dummy.m</li>
</ul>
<p>一旦每个 pod 的 target 完成了上面的内容，整个 Pods target 就会被创建。这增加了相同文件的同时，还增加了另外几个文件。如果源码中包含有资源 bundle，将这个 bundle 添加至程序 target 的指令将被添加到 Pods-Resources.sh 文件中。还有一个名为 Pods-environment.h 的文件，文件中包含了一些宏，这些宏可以用来检查某个组件是否来自 pod。最后，将生成两个认可文件，一个是 plist，另一个是 markdown，这两个文件用于给最终用户查阅相关许可信息。</p>
<h1 id="写入至磁盘"><a href="#写入至磁盘" class="headerlink" title="写入至磁盘"></a>写入至磁盘</h1><p>直到现在，许多工作都是在内存中进行的。为了让这些成果能被重复利用，我们需要将所有的结果保存到一个文件中。所以 Pods.xcodeproj 文件被写入磁盘，另外两个非常重要的文件：Podfile.lock 和 Manifest.lock 都将被写入磁盘。</p>
<ul>
<li><p>Podfile.lock<br>这是 CocoaPods 创建的最重要的文件之一。它记录了需要被安装的 pod 的每个已安装的版本。如果你想知道已安装的 pod 是哪个版本，可以查看这个文件。推荐将 Podfile.lock 文件加入到版本控制中，这有助于整个团队的一致性。</p>
</li>
<li><p>Manifest.lock<br>这是每次运行 pod install 命令时创建的 Podfile.lock 文件的副本。如果你遇见过这样的错误 沙盒文件与 Podfile.lock 文件不同步 (The sandbox is not in sync with the Podfile.lock)，这是因为 Manifest.lock 文件和 Podfile.lock 文件不一致所引起。由于 Pods 所在的目录并不总在版本控制之下，这样可以保证开发者运行 app 之前都能更新他们的 pods，否则 app 可能会 crash，或者在一些不太明显的地方编译失败。</p>
</li>
<li><p>xcproj<br>如果你已经依照我们的建议在系统上安装了 xcproj，它会对 Pods.xcodeproj 文件执行一下 touch 以将其转换成为旧的 ASCII plist 格式的文件。为什么要这么做呢？虽然在很久以前就不被其它软件支持了，但是 Xcode 仍然依赖于这种格式。如果没有 xcproj，你的 Pods.xcodeproj 文件将会以 XML 格式的 plist 文件存储，当你用 Xcode 打开它时，它会被改写，并造成大量的文件改动。</p>
</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>依赖库有Pod工程管理，最终编译为.a文件或者framework文件，为主项目使用</p>
<p>libPods.a<br>Pods-resources.sh<br>Pods.xcconfig</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>面试总结</category>
        <category>Cocoapods原理</category>
      </categories>
      <tags>
        <tag>Cocoapods原理</tag>
      </tags>
  </entry>
  <entry>
    <title>面向协议开发</title>
    <url>/iOS/interview/protocol.html</url>
    <content><![CDATA[<p>当时，项目中有个需求让画柱状图折线图表格，无意间看到了一个非常好的 Swift 库，是安卓的 iOS 是实现版，思路清晰，建议学习。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhbmllbGdpbmRpL0NoYXJ0cw==">Charts<i class="fa fa-external-link-alt"></i></span></p>
<p>为什么我要先说这个库呢，因为我觉得它用到了面相协议的思想，比如绘制，数据, 表格等 Provider。</p>
<ul>
<li>说的好听点，就是组件化了，每个组件负责自己的事情，通过 Protocol 向外传输职责的能力.</li>
<li>还可以这么说，就是抽象类，类似于接口, 也类似于多继承。</li>
<li>面向协议其实是建立在面向对象的基础上，这些对象具有共同的行为，称之为遵守某种协议，也就是抽象出来的面相协议。</li>
<li>我不关心内部实现，我只关心行为。你可以吃饭，他也可以吃饭，但我只关心吃饭这件事儿，并不关心你们怎么吃的，吃的啥。。。 也就是组件化，你吃你的，他吃他的，你们自己实现怎么吃，我只下命令该吃饭了！</li>
</ul>
<p>引用网上说的：<br>简单来说，面向协议编程是在面向对象编程基础上演变而来，将程序设计过程中遇到的数据类型的抽取（抽象）由使用基类进行抽取改为使用协议（Java语言中的接口）进行抽取。更简单点举个栗子来说，一个猫类、一个狗类，我们很容易想到抽取一个描述动物的基类，也会有人想到抽取一个动物通用的协议，那后者就可以被叫做面向协议编程了。什么？就是这样而已？苹果官方那么正式的称Swift是一门支持面向协议编程的语言，难道就是这么简单的内容？当然不会，有过面向对象编程经验的人都会清楚，协议的使用限制很多，并不能适用于大多数情况下数据类型的抽象。而在Swift语言中，协议被赋予了更多的功能和更广阔的使用空间，在Swift 2.0中，更为协议增加了扩展功能，使其能够胜任绝大多数情况下数据类型的抽象，所以苹果开始声称Swift是一门支持面向协议编程的语言。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>面试总结</category>
        <category>面向协议开发</category>
      </categories>
      <tags>
        <tag>面向协议</tag>
      </tags>
  </entry>
  <entry>
    <title>RunLoop</title>
    <url>/iOS/interview/runloop.html</url>
    <content><![CDATA[<h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><p>惯例先上文档和源码：<br><span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS9zb3VyY2UvQ0YvQ0YtMTE1My4xOC8=">CFRunloopRef 源码<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0NvY29hL0NvbmNlcHR1YWwvTXVsdGl0aHJlYWRpbmcvUnVuTG9vcE1hbmFnZW1lbnQvUnVuTG9vcE1hbmFnZW1lbnQuaHRtbA==">RunLoop文档<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwcGxlL3N3aWZ0LWNvcmVsaWJzLWZvdW5kYXRpb24v">Swift-Corelibs-foundation<i class="fa fa-external-link-alt"></i></span></p>
<p><a href="./iOS/RunLoop/runloopfanyi.html">官方文档翻译</a></p>
<p>参看我之前Runloop章节，RunLoop线程是一一对应的；以及若干个Mode、若干个commonModeItem，还有一个当前运行的CurrentMode。如果在RunLoop中需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<h2 id="CFRunLoopSource"><a href="#CFRunLoopSource" class="headerlink" title="CFRunLoopSource"></a>CFRunLoopSource</h2><p>对应CFRunLoopModeRef，其结构如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoopSource</span> &#123;</span><br><span class="line">    <span class="type">CFRuntimeBase</span> _base;</span><br><span class="line">    uint32_t _bits; <span class="comment">//用于标记Signaled状态，source0只有在被标记为Signaled状态，才会被处理</span></span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    <span class="type">CFIndex</span> _order;         <span class="comment">/* immutable */</span></span><br><span class="line">    <span class="type">CFMutableBagRef</span> _runLoops;</span><br><span class="line">    union &#123;</span><br><span class="line">        <span class="type">CFRunLoopSourceContext</span> version0;     <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">        <span class="type">CFRunLoopSourceContext1</span> version1;    <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">    &#125; _context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Source分为Source、Observer、Timer三种，他们统称为modeItem。</p>
<p>__CFRunLoopSource是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>
<ul>
<li>source0 只包含了一个回调（函数指针），source0是需要手动触发的Source，它并不能主动触发事件，必须要先把它标记为signal状态。使用时，你需要先调用 <code>CFRunLoopSourceSignal(source)</code>，将这个 Source 标记为待处理，也就是通过uint32_t _bits来实现的，只有_bits标记Signaled状态才会被处理。然后手动调用 <code>CFRunLoopWakeUp(runloop)</code> 来唤醒 RunLoop，让其处理这个事件。</li>
<li>source1 包含了一个 mach_port 和一个回调（函数指针），被用于<code>通过内核和其他线程相互发送消息</code>。这种 Source 能主动唤醒 RunLoop 的线程。简单来说就是更加偏向于底层。</li>
</ul>
<blockquote>
<p>ource1除了多个了getPort。其余的字段含义和source0相同。作用就是当source被添加到mode中的时候，从这个函数中获得具体mach_port_t。</p>
</blockquote>
<h2 id="CFRunLoopTimer"><a href="#CFRunLoopTimer" class="headerlink" title="CFRunLoopTimer"></a>CFRunLoopTimer</h2><p>对应RunLoopTimerRef，结构如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoopTimer</span> &#123;</span><br><span class="line">    <span class="type">CFRuntimeBase</span> _base;</span><br><span class="line">    uint16_t _bits;  <span class="comment">//标记fire状态</span></span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    <span class="type">CFRunLoopRef</span> _runLoop;        <span class="comment">//添加该timer的runloop</span></span><br><span class="line">    <span class="type">CFMutableSetRef</span> _rlModes;     <span class="comment">//存放所有包含该timer的 mode的 modeName，意味着一个timer可能会在多个mode中存在</span></span><br><span class="line">    <span class="type">CFAbsoluteTime</span> _nextFireDate;</span><br><span class="line">    <span class="type">CFTimeInterval</span> _interval;     <span class="comment">//理想时间间隔  /* immutable */</span></span><br><span class="line">    <span class="type">CFTimeInterval</span> _tolerance;    <span class="comment">//时间偏差      /* mutable */</span></span><br><span class="line">    uint64_t _fireTSR;          <span class="comment">/* TSR units */</span></span><br><span class="line">    <span class="type">CFIndex</span> _order;         <span class="comment">/* immutable */</span></span><br><span class="line">    <span class="type">CFRunLoopTimerCallBack</span> _callout;    <span class="comment">/* immutable */</span></span><br><span class="line">    <span class="type">CFRunLoopTimerContext</span> _context; <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它和 NSTimer 是toll-free bridged 的 , <code>根据上面的分析t一个timer可能会在多个mode中存在。</code></p>
<h2 id="CFRunLoopObserver"><a href="#CFRunLoopObserver" class="headerlink" title="CFRunLoopObserver"></a>CFRunLoopObserver</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">__CFRunLoopObserver</span> &#123;</span><br><span class="line">    <span class="type">CFRuntimeBase</span> _base;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    <span class="type">CFRunLoopRef</span> _runLoop;</span><br><span class="line">    <span class="type">CFIndex</span> _rlCount;</span><br><span class="line">    <span class="type">CFOptionFlags</span> _activities;      <span class="comment">/* immutable */</span></span><br><span class="line">    <span class="type">CFIndex</span> _order;         <span class="comment">/* immutable */</span></span><br><span class="line">    <span class="type">CFRunLoopObserverCallBack</span> _callout; <span class="comment">/* immutable  设置回调函数*/</span></span><br><span class="line">    <span class="type">CFRunLoopObserverContext</span> _context;  <span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>CFRunLoopObserver是观察者，可以观察RunLoop的各种状态，每个 Observer 都包含了一个回调（也就是上面的CFRunLoopObserverCallBack函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。状态定义在_CF_OPTIONS：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line">typedef <span class="type">CF_OPTIONS</span>(<span class="type">CFOptionFlags</span>, <span class="type">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    kCFRunLoopEntry <span class="operator">=</span> (1UL <span class="operator">&lt;&lt;</span> <span class="number">0</span>), <span class="comment">//即将进入run loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers <span class="operator">=</span> (1UL <span class="operator">&lt;&lt;</span> <span class="number">1</span>), <span class="comment">//即将处理timer</span></span><br><span class="line">    kCFRunLoopBeforeSources <span class="operator">=</span> (1UL <span class="operator">&lt;&lt;</span> <span class="number">2</span>),<span class="comment">//即将处理source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting <span class="operator">=</span> (1UL <span class="operator">&lt;&lt;</span> <span class="number">5</span>),<span class="comment">//即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting <span class="operator">=</span> (1UL <span class="operator">&lt;&lt;</span> <span class="number">6</span>),<span class="comment">//被唤醒但是还没开始处理事件</span></span><br><span class="line">    kCFRunLoopExit <span class="operator">=</span> (1UL <span class="operator">&lt;&lt;</span> <span class="number">7</span>),<span class="comment">//run loop已经退出</span></span><br><span class="line">    kCFRunLoopAllActivities <span class="operator">=</span> 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是回调函数的原型:</p>
<blockquote>
<p>typedef void (*CFRunLoopObserverCallBack)(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info);</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>根据上面的数据结构，总结出如下内容。</p>
<p>一个model中有多个item，这些item由source、observe、timer组成。对于我们来讲用的最多的应该是observe和timer，常常通过回调来得知当前runloop的状态，进行来优化应用程序（比如监控在waiting状态下，这个时候做一些优化的事情）。其次设置定时器执行定时任务也是很常见的。</p>
<h1 id="CFRunloopRun（核心！！）"><a href="#CFRunloopRun（核心！！）" class="headerlink" title="__CFRunloopRun（核心！！）"></a>__CFRunloopRun（核心！！）</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  运行run loop</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param rl              运行的RunLoop对象</span></span><br><span class="line"><span class="comment"> *  @param rlm             运行的mode</span></span><br><span class="line"><span class="comment"> *  @param seconds         run loop超时时间</span></span><br><span class="line"><span class="comment"> *  @param stopAfterHandle true:run loop处理完事件就退出  false:一直运行直到超时或者被手动终止</span></span><br><span class="line"><span class="comment"> *  @param previousMode    上一次运行的mode</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @return 返回4种状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> int32_t __CFRunLoopRun(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopModeRef</span> rlm, <span class="type">CFTimeInterval</span> seconds, <span class="type">Boolean</span> stopAfterHandle, <span class="type">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class="line">    <span class="comment">//获取系统启动后的CPU运行时间，用于控制超时时间</span></span><br><span class="line">    uint64_t startTSR <span class="operator">=</span> mach_absolute_time();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果RunLoop或者mode是stop状态，则直接return，不进入循环</span></span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">        __CFRunLoopUnsetStopped(rl);</span><br><span class="line">        <span class="keyword">return</span> kCFRunLoopRunStopped;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">        rlm-&gt;_stopped <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> kCFRunLoopRunStopped;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//mach端口，在内核中，消息在端口之间传递。 初始为0</span></span><br><span class="line">    mach_port_name_t dispatchPort <span class="operator">=</span> <span class="type">MACH_PORT_NULL</span>;</span><br><span class="line">    <span class="comment">//判断是否为主线程</span></span><br><span class="line">    <span class="type">Boolean</span> libdispatchQSafe <span class="operator">=</span> pthread_main_np() <span class="operator">&amp;&amp;</span> ((<span class="type">HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY</span> <span class="operator">&amp;&amp;</span> <span class="type">NULL</span> <span class="operator">==</span> previousMode) <span class="operator">||</span> (<span class="operator">!</span><span class="type">HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY</span> <span class="operator">&amp;&amp;</span> <span class="number">0</span> <span class="operator">==</span> _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</span><br><span class="line">    <span class="comment">//如果在主线程 &amp;&amp; runloop是主线程的runloop &amp;&amp; 该mode是commonMode，则给mach端口赋值为主线程收发消息的端口</span></span><br><span class="line">    <span class="keyword">if</span> (libdispatchQSafe <span class="operator">&amp;&amp;</span> (<span class="type">CFRunLoopGetMain</span>() <span class="operator">==</span> rl) <span class="operator">&amp;&amp;</span> <span class="type">CFSetContainsValue</span>(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort <span class="operator">=</span> _dispatch_get_main_queue_port_4CF();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">#if</span> <span class="type">USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">    mach_port_name_t modeQueuePort <span class="operator">=</span> <span class="type">MACH_PORT_NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (rlm-&gt;_queue) &#123;</span><br><span class="line">        <span class="comment">//mode赋值为dispatch端口_dispatch_runloop_root_queue_perform_4CF</span></span><br><span class="line">        modeQueuePort <span class="operator">=</span> _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>modeQueuePort) &#123;</span><br><span class="line">            <span class="type">CRASH</span>(<span class="string">&quot;Unable to get port for run loop mode queue (%d)&quot;</span>, <span class="operator">-</span><span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//GCD管理的定时器，用于实现runloop超时机制</span></span><br><span class="line">    dispatch_source_t timeout_timer <span class="operator">=</span> <span class="type">NULL</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__timeout_context</span> *<span class="title class_">timeout_context</span> = (<span class="title class_">struct</span> <span class="title class_">__timeout_context</span> *)<span class="title class_">malloc</span>(<span class="title class_">sizeof</span>(*<span class="title class_">timeout_context</span>));</span><br><span class="line">    </span><br><span class="line">    //立即超时</span><br><span class="line">    <span class="title class_">if</span> (<span class="title class_">seconds</span> &lt;= 0.0) &#123; <span class="comment">// instant timeout</span></span><br><span class="line">        seconds <span class="operator">=</span> <span class="number">0.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR <span class="operator">=</span> 0ULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//seconds为超时时间，超时时执行__CFRunLoopTimeout函数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (seconds <span class="operator">&lt;=</span> <span class="type">TIMER_INTERVAL_LIMIT</span>) &#123;</span><br><span class="line">        dispatch_queue_t queue <span class="operator">=</span> dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_HIGH</span>, <span class="type">DISPATCH_QUEUE_OVERCOMMIT</span>);</span><br><span class="line">        timeout_timer <span class="operator">=</span> dispatch_source_create(<span class="type">DISPATCH_SOURCE_TYPE_TIMER</span>, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">        dispatch_retain(timeout_timer);</span><br><span class="line">        timeout_context-&gt;ds <span class="operator">=</span> timeout_timer;</span><br><span class="line">        timeout_context-&gt;rl <span class="operator">=</span> (<span class="type">CFRunLoopRef</span>)<span class="type">CFRetain</span>(rl);</span><br><span class="line">        timeout_context-&gt;termTSR <span class="operator">=</span> startTSR <span class="operator">+</span> __CFTimeIntervalToTSR(seconds);</span><br><span class="line">        dispatch_set_context(timeout_timer, timeout_context); <span class="comment">// source gets ownership of context</span></span><br><span class="line">        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</span><br><span class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</span><br><span class="line">        uint64_t ns_at <span class="operator">=</span> (uint64_t)((__CFTSRToTimeInterval(startTSR) <span class="operator">+</span> seconds) <span class="operator">*</span> 1000000000ULL);</span><br><span class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(<span class="number">1</span>, ns_at), <span class="type">DISPATCH_TIME_FOREVER</span>, 1000ULL);</span><br><span class="line">        dispatch_resume(timeout_timer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//永不超时</span></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// infinite timeout</span></span><br><span class="line">        seconds <span class="operator">=</span> <span class="number">9999999999.0</span>;</span><br><span class="line">        timeout_context-&gt;termTSR <span class="operator">=</span> <span class="type">UINT64_MAX</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//标志位默认为true</span></span><br><span class="line">    <span class="type">Boolean</span> didDispatchPortLastTime <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//记录最后runloop状态，用于return</span></span><br><span class="line">    int32_t retVal <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//初始化一个存放内核消息的缓冲池</span></span><br><span class="line">        uint8_t msg_buffer[<span class="number">3</span> <span class="operator">*</span> <span class="number">1024</span>];</span><br><span class="line"><span class="keyword">#if</span> <span class="type">DEPLOYMENT_TARGET_MACOSX</span> <span class="operator">||</span> <span class="type">DEPLOYMENT_TARGET_EMBEDDED</span> <span class="operator">||</span> <span class="type">DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        mach_msg_header_t <span class="operator">*</span>msg <span class="operator">=</span> <span class="type">NULL</span>;</span><br><span class="line">        mach_port_t livePort <span class="operator">=</span> <span class="type">MACH_PORT_NULL</span>;</span><br><span class="line">#elif <span class="type">DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">        <span class="type">HANDLE</span> livePort <span class="operator">=</span> <span class="type">NULL</span>;</span><br><span class="line">        <span class="type">Boolean</span> windowsMessageReceived <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">        <span class="comment">//取所有需要监听的port</span></span><br><span class="line">        __CFPortSet waitSet <span class="operator">=</span> rlm-&gt;_portSet;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置RunLoop为可以被唤醒状态</span></span><br><span class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.通知observer，即将触发timer回调，处理timer事件</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask <span class="operator">&amp;</span> kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="comment">//3.通知observer，即将触发Source0回调</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask <span class="operator">&amp;</span> kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行加入当前runloop的block</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.处理source0事件</span></span><br><span class="line">        <span class="comment">//有事件处理返回true，没有事件返回false</span></span><br><span class="line">        <span class="type">Boolean</span> sourceHandledThisLoop <span class="operator">=</span> __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">//执行加入当前runloop的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果没有Sources0事件处理 并且 没有超时，poll为false</span></span><br><span class="line">        <span class="comment">//如果有Sources0事件处理 或者 超时，poll都为true</span></span><br><span class="line">        <span class="type">Boolean</span> poll <span class="operator">=</span> sourceHandledThisLoop <span class="operator">||</span> (0ULL <span class="operator">==</span> timeout_context-&gt;termTSR);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一次do..whil循环不会走该分支，因为didDispatchPortLastTime初始化是true</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">MACH_PORT_NULL</span> <span class="operator">!=</span> dispatchPort <span class="operator">&amp;&amp;</span> <span class="operator">!</span>didDispatchPortLastTime) &#123;</span><br><span class="line"><span class="keyword">#if</span> <span class="type">DEPLOYMENT_TARGET_MACOSX</span> <span class="operator">||</span> <span class="type">DEPLOYMENT_TARGET_EMBEDDED</span> <span class="operator">||</span> <span class="type">DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">            <span class="comment">//从缓冲区读取消息</span></span><br><span class="line">            msg <span class="operator">=</span> (mach_msg_header_t <span class="operator">*</span>)msg_buffer;</span><br><span class="line">            <span class="comment">//5.接收dispatchPort端口的消息，（接收source1事件）</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, <span class="operator">&amp;</span>msg, sizeof(msg_buffer), <span class="operator">&amp;</span>livePort, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="comment">//如果接收到了消息的话，前往第9步开始处理msg</span></span><br><span class="line">                goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">#elif <span class="type">DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">            <span class="keyword">if</span> (__CFRunLoopWaitForMultipleObjects(<span class="type">NULL</span>, <span class="operator">&amp;</span>dispatchPort, <span class="number">0</span>, <span class="number">0</span>, <span class="operator">&amp;</span>livePort, <span class="type">NULL</span>)) &#123;</span><br><span class="line">                goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        didDispatchPortLastTime <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.通知观察者RunLoop即将进入休眠</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>poll <span class="operator">&amp;&amp;</span> (rlm-&gt;_observerMask <span class="operator">&amp;</span> kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        <span class="comment">//设置RunLoop为休眠状态</span></span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        <span class="comment">// do not do any user callouts after this point (after notifying of sleeping)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Must push the local-to-this-activation ports in on every loop</span></span><br><span class="line">        <span class="comment">// iteration, as this mode could be run re-entrantly and we don&#x27;t</span></span><br><span class="line">        <span class="comment">// want these ports to get serviced.</span></span><br><span class="line">        </span><br><span class="line">        __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line">        __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        __CFRunLoopUnlock(rl);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">#if</span> <span class="type">DEPLOYMENT_TARGET_MACOSX</span> <span class="operator">||</span> <span class="type">DEPLOYMENT_TARGET_EMBEDDED</span> <span class="operator">||</span> <span class="type">DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line"><span class="keyword">#if</span> <span class="type">USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">        <span class="comment">//这里有个内循环，用于接收等待端口的消息</span></span><br><span class="line">        <span class="comment">//进入此循环后，线程进入休眠，直到收到新消息才跳出该循环，继续执行run loop</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (kCFUseCollectableAllocator) &#123;</span><br><span class="line">                objc_clear_stack(<span class="number">0</span>);</span><br><span class="line">                memset(msg_buffer, <span class="number">0</span>, sizeof(msg_buffer));</span><br><span class="line">            &#125;</span><br><span class="line">            msg <span class="operator">=</span> (mach_msg_header_t <span class="operator">*</span>)msg_buffer;</span><br><span class="line">            <span class="comment">//7.接收waitSet端口的消息</span></span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, <span class="operator">&amp;</span>msg, sizeof(msg_buffer), <span class="operator">&amp;</span>livePort, poll <span class="operator">?</span> <span class="number">0</span> : <span class="type">TIMEOUT_INFINITY</span>);</span><br><span class="line">            <span class="comment">//收到消息之后，livePort的值为msg-&gt;msgh_local_port，</span></span><br><span class="line">            <span class="keyword">if</span> (modeQueuePort <span class="operator">!=</span> <span class="type">MACH_PORT_NULL</span> <span class="operator">&amp;&amp;</span> livePort <span class="operator">==</span> modeQueuePort) &#123;</span><br><span class="line">                <span class="comment">// Drain the internal queue. If one of the callout blocks sets the timerFired flag, break out and service the timer.</span></span><br><span class="line">                <span class="keyword">while</span> (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</span><br><span class="line">                <span class="keyword">if</span> (rlm-&gt;_timerFired) &#123;</span><br><span class="line">                    <span class="comment">// Leave livePort as the queue port, and service timers below</span></span><br><span class="line">                    rlm-&gt;_timerFired <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (msg <span class="operator">&amp;&amp;</span> msg <span class="operator">!=</span> (mach_msg_header_t <span class="operator">*</span>)msg_buffer) free(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Go ahead and leave the inner loop.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"><span class="keyword">#else</span></span><br><span class="line">        <span class="keyword">if</span> (kCFUseCollectableAllocator) &#123;</span><br><span class="line">            objc_clear_stack(<span class="number">0</span>);</span><br><span class="line">            memset(msg_buffer, <span class="number">0</span>, sizeof(msg_buffer));</span><br><span class="line">        &#125;</span><br><span class="line">        msg <span class="operator">=</span> (mach_msg_header_t <span class="operator">*</span>)msg_buffer;</span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, <span class="operator">&amp;</span>msg, sizeof(msg_buffer), <span class="operator">&amp;</span>livePort, poll <span class="operator">?</span> <span class="number">0</span> : <span class="type">TIMEOUT_INFINITY</span>);</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">#elif <span class="type">DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">        <span class="comment">// Here, use the app-supplied message queue mask. They will set this if they are interested in having this run loop receive windows messages.</span></span><br><span class="line">        __CFRunLoopWaitForMultipleObjects(waitSet, <span class="type">NULL</span>, poll <span class="operator">?</span> <span class="number">0</span> : <span class="type">TIMEOUT_INFINITY</span>, rlm-&gt;_msgQMask, <span class="operator">&amp;</span>livePort, <span class="operator">&amp;</span>windowsMessageReceived);</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">        </span><br><span class="line">        __CFRunLoopLock(rl);</span><br><span class="line">        __CFRunLoopModeLock(rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Must remove the local-to-this-activation ports in on every loop</span></span><br><span class="line">        <span class="comment">// iteration, as this mode could be run re-entrantly and we don&#x27;t</span></span><br><span class="line">        <span class="comment">// want these ports to get serviced. Also, we don&#x27;t want them left</span></span><br><span class="line">        <span class="comment">// in there if this function returns.</span></span><br><span class="line">        </span><br><span class="line">        __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// user callouts now OK again</span></span><br><span class="line">        <span class="comment">//取消runloop的休眠状态</span></span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        <span class="comment">//8.通知观察者runloop被唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>poll <span class="operator">&amp;&amp;</span> (rlm-&gt;_observerMask <span class="operator">&amp;</span> kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//9.处理收到的消息</span></span><br><span class="line">    handle_msg:;</span><br><span class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">#if</span> <span class="type">DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">        <span class="keyword">if</span> (windowsMessageReceived) &#123;</span><br><span class="line">            <span class="comment">// These Win32 APIs cause a callout, so make sure we&#x27;re unlocked first and relocked after</span></span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (rlm-&gt;_msgPump) &#123;</span><br><span class="line">                rlm-&gt;_msgPump();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">MSG</span> msg;</span><br><span class="line">                <span class="keyword">if</span> (<span class="type">PeekMessage</span>(<span class="operator">&amp;</span>msg, <span class="type">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="type">PM_REMOVE</span> <span class="operator">|</span> <span class="type">PM_NOYIELD</span>)) &#123;</span><br><span class="line">                    <span class="type">TranslateMessage</span>(<span class="operator">&amp;</span>msg);</span><br><span class="line">                    <span class="type">DispatchMessage</span>(<span class="operator">&amp;</span>msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            sourceHandledThisLoop <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// To prevent starvation of sources other than the message queue, we check again to see if any other sources need to be serviced</span></span><br><span class="line">            <span class="comment">// Use 0 for the mask so windows messages are ignored this time. Also use 0 for the timeout, because we&#x27;re just checking to see if the things are signalled right now -- we will wait on them again later.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> Ignore the dispatch source (it&#x27;s not in the wait set anymore) and also don&#x27;t run the observers here since we are polling.</span></span><br><span class="line">            __CFRunLoopSetSleeping(rl);</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            </span><br><span class="line">            __CFRunLoopWaitForMultipleObjects(waitSet, <span class="type">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="operator">&amp;</span>livePort, <span class="type">NULL</span>);</span><br><span class="line">            </span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">            <span class="comment">// If we have a new live port then it will be handled below as normal</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">MACH_PORT_NULL</span> <span class="operator">==</span> livePort) &#123;</span><br><span class="line">            <span class="type">CFRUNLOOP_WAKEUP_FOR_NOTHING</span>();</span><br><span class="line">            <span class="comment">// handle nothing</span></span><br><span class="line">            <span class="comment">//通过CFRunloopWake唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (livePort <span class="operator">==</span> rl-&gt;_wakeUpPort) &#123;</span><br><span class="line">            <span class="type">CFRUNLOOP_WAKEUP_FOR_WAKEUP</span>();</span><br><span class="line">            <span class="comment">//什么都不干，跳回2重新循环</span></span><br><span class="line">            <span class="comment">// do nothing on Mac OS</span></span><br><span class="line"><span class="keyword">#if</span> <span class="type">DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">            <span class="comment">// Always reset the wake up port, or risk spinning forever</span></span><br><span class="line">            <span class="type">ResetEvent</span>(rl-&gt;_wakeUpPort);</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">#if</span> <span class="type">USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">        <span class="comment">//如果是定时器事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (modeQueuePort <span class="operator">!=</span> <span class="type">MACH_PORT_NULL</span> <span class="operator">&amp;&amp;</span> livePort <span class="operator">==</span> modeQueuePort) &#123;</span><br><span class="line">            <span class="type">CFRUNLOOP_WAKEUP_FOR_TIMER</span>();</span><br><span class="line">            <span class="comment">//9.1 处理timer事件</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="operator">!</span>__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer, because we apparently fired early</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line"><span class="keyword">#if</span> <span class="type">USE_MK_TIMER_TOO</span></span><br><span class="line">        <span class="comment">//如果是定时器事件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_timerPort <span class="operator">!=</span> <span class="type">MACH_PORT_NULL</span> <span class="operator">&amp;&amp;</span> livePort <span class="operator">==</span> rlm-&gt;_timerPort) &#123;</span><br><span class="line">            <span class="type">CFRUNLOOP_WAKEUP_FOR_TIMER</span>();</span><br><span class="line">            <span class="comment">// On Windows, we have observed an issue where the timer port is set before the time which we requested it to be set. For example, we set the fire time to be TSR 167646765860, but it is actually observed firing at TSR 167646764145, which is 1715 ticks early. The result is that, when __CFRunLoopDoTimers checks to see if any of the run loop timers should be firing, it appears to be &#x27;too early&#x27; for the next timer, and no timers are handled.</span></span><br><span class="line">            <span class="comment">// In this case, the timer port has been automatically reset (since it was returned from MsgWaitForMultipleObjectsEx), and if we do not re-arm it, then no timers will ever be serviced again unless something adjusts the timer list (e.g. adding or removing timers). The fix for the issue is to reset the timer here if CFRunLoopDoTimers did not handle a timer itself. 9308754</span></span><br><span class="line">           <span class="comment">//9.1处理timer事件</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="operator">!</span>__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">        <span class="comment">//如果是dispatch到main queue的block</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (livePort <span class="operator">==</span> dispatchPort) &#123;</span><br><span class="line">            <span class="type">CFRUNLOOP_WAKEUP_FOR_DISPATCH</span>();</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">            __CFRunLoopUnlock(rl);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void <span class="operator">*</span>)<span class="number">6</span>, <span class="type">NULL</span>);</span><br><span class="line"><span class="keyword">#if</span> <span class="type">DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">            void <span class="operator">*</span>msg <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">            <span class="comment">//9.2执行block</span></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void <span class="operator">*</span>)<span class="number">0</span>, <span class="type">NULL</span>);</span><br><span class="line">            __CFRunLoopLock(rl);</span><br><span class="line">            __CFRunLoopModeLock(rlm);</span><br><span class="line">            sourceHandledThisLoop <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            didDispatchPortLastTime <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">CFRUNLOOP_WAKEUP_FOR_SOURCE</span>();</span><br><span class="line">            <span class="comment">// Despite the name, this works for windows handles as well</span></span><br><span class="line">            <span class="type">CFRunLoopSourceRef</span> rls <span class="operator">=</span> __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">            <span class="comment">// 有source1事件待处理</span></span><br><span class="line">            <span class="keyword">if</span> (rls) &#123;</span><br><span class="line"><span class="keyword">#if</span> <span class="type">DEPLOYMENT_TARGET_MACOSX</span> <span class="operator">||</span> <span class="type">DEPLOYMENT_TARGET_EMBEDDED</span> <span class="operator">||</span> <span class="type">DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">                mach_msg_header_t <span class="operator">*</span>reply <span class="operator">=</span> <span class="type">NULL</span>;</span><br><span class="line">                <span class="comment">//9.2 处理source1事件</span></span><br><span class="line">                sourceHandledThisLoop <span class="operator">=</span> __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, <span class="operator">&amp;</span>reply) <span class="operator">||</span> sourceHandledThisLoop;</span><br><span class="line">                <span class="keyword">if</span> (<span class="type">NULL</span> <span class="operator">!=</span> reply) &#123;</span><br><span class="line">                    (void)mach_msg(reply, <span class="type">MACH_SEND_MSG</span>, reply-&gt;msgh_size, <span class="number">0</span>, <span class="type">MACH_PORT_NULL</span>, <span class="number">0</span>, <span class="type">MACH_PORT_NULL</span>);</span><br><span class="line">                    <span class="type">CFAllocatorDeallocate</span>(kCFAllocatorSystemDefault, reply);</span><br><span class="line">                &#125;</span><br><span class="line">#elif <span class="type">DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">                sourceHandledThisLoop <span class="operator">=</span> __CFRunLoopDoSource1(rl, rlm, rls) <span class="operator">||</span> sourceHandledThisLoop;</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">#if</span> <span class="type">DEPLOYMENT_TARGET_MACOSX</span> <span class="operator">||</span> <span class="type">DEPLOYMENT_TARGET_EMBEDDED</span> <span class="operator">||</span> <span class="type">DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="operator">&amp;&amp;</span> msg <span class="operator">!=</span> (mach_msg_header_t <span class="operator">*</span>)msg_buffer) free(msg);</span><br><span class="line"><span class="keyword">#endif</span></span><br><span class="line">        </span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop <span class="operator">&amp;&amp;</span> stopAfterHandle) &#123;</span><br><span class="line">            <span class="comment">//进入run loop时传入的参数，处理完事件就返回</span></span><br><span class="line">            retVal <span class="operator">=</span> kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR <span class="operator">&lt;</span> mach_absolute_time()) &#123;</span><br><span class="line">            <span class="comment">//run loop超时</span></span><br><span class="line">            retVal <span class="operator">=</span> kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            <span class="comment">//run loop被手动终止</span></span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal <span class="operator">=</span> kCFRunLoopRunStopped;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">            <span class="comment">//mode被终止</span></span><br><span class="line">            rlm-&gt;_stopped <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            retVal <span class="operator">=</span> kCFRunLoopRunStopped;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            <span class="comment">//mode中没有要处理的事件</span></span><br><span class="line">            retVal <span class="operator">=</span> kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//除了上面这几种情况，都继续循环</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span> <span class="operator">==</span> retVal);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (timeout_timer) &#123;</span><br><span class="line">        dispatch_source_cancel(timeout_timer);</span><br><span class="line">        dispatch_release(timeout_timer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        free(timeout_context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RunLoop操作"><a href="#RunLoop操作" class="headerlink" title="RunLoop操作"></a>RunLoop操作</h2><ul>
<li>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。</li>
<li>线程刚创建时并没有 RunLoop（没有加到对应的runloop字典中），如果你不主动获取，那它一直都不会有。</li>
<li>RunLoop 的创建是发生在第一次获取时。一般是获取主线程的时候。</li>
<li>RunLoop 的销毁是发生在线程结束时。</li>
<li>只能在一个线程的内部获取其 RunLoop（主线程除外），否则就这个Runloop就没有注册销毁回调。这一点是根据pthread_equal(t, pthread_self())后面的代码，如果是当前线程后面才会注册销毁回调。因为上面讲过Runlopp暴露给外部的创建方式只有CFRunLoopGetMain() 和 CFRunLoopGetCurrent()两种，所以这种情况不用考虑。下面是CFRunloop.h的头文件暴露接口，可以看到获取方式只有两种。</li>
</ul>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmliaXJlbWUuY29tLzIwMTUvMDUvMTgvcnVubG9vcC8=">还是YY大神的博客<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 1. 通知Observers，即将进入RunLoop</span></span><br><span class="line">    <span class="comment">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span></span><br><span class="line">    <span class="built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopEntry);</span><br><span class="line">    do &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 2. 通知 Observers: 即将触发 Timer 回调。</span></span><br><span class="line">        <span class="built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="comment">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span></span><br><span class="line">        <span class="built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeSources);</span><br><span class="line">        <span class="built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span>(block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 4. 触发 Source0 (非基于port的) 回调。</span></span><br><span class="line">        <span class="built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span>(source0);</span><br><span class="line">        <span class="built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span>(block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 6. 通知Observers，即将进入休眠</span></span><br><span class="line">        <span class="comment">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span></span><br><span class="line">        <span class="built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeWaiting);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 7. sleep to wait msg.</span></span><br><span class="line">        <span class="built_in">mach_msg</span>() -&gt; <span class="built_in">mach_msg_trap</span>();</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 8. 通知Observers，线程被唤醒</span></span><br><span class="line">        <span class="built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopAfterWaiting);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果是被Timer唤醒的，回调Timer</span></span><br><span class="line">        <span class="built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span>(timer);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span></span><br><span class="line">        <span class="built_in">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>(dispatched_block);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span></span><br><span class="line">        <span class="built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span>(source1);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125; while (...);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 10. 通知Observers，即将退出RunLoop</span></span><br><span class="line">    <span class="comment">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span></span><br><span class="line">    <span class="built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><p>在最开始介绍CFRunloop的时候就简单提了一下其中关于block的两个字段blocks_head，blocks_tail。并且也提到在runloop周期中会对此调用__CFRunLoopDoBlocks来执行加入到这个runloop的block。下面从源码来说明一下block如何与runloop结合的。</p>
<p>先来看看最基本的block_item 数据结构，特别注意这里保存了runloop的model，决定了block是否应该执行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_block_item</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_block_item</span> *<span class="title class_">_next</span>;</span><br><span class="line">    <span class="title class_">CFTypeRef</span> <span class="title class_">_mode</span>;	// <span class="title class_">CFString</span> <span class="title class_">or</span> <span class="title class_">CFSet</span></span><br><span class="line">    <span class="title class_">void</span> (^<span class="title class_">_block</span>)(<span class="title class_">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在执行block的时候会传入</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 执行block</span></span><br><span class="line"><span class="comment"> @param rl runloop</span></span><br><span class="line"><span class="comment"> @param rlm 当前的model</span></span><br><span class="line"><span class="comment"> @return 是否执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Boolean</span> __CFRunLoopDoBlocks(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopModeRef</span> rlm) &#123; <span class="comment">// Call with rl and rlm locked</span></span><br><span class="line">   <span class="comment">//如果头结点没有、或者model不存在则强制返回，什么也不做</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>rl-&gt;_blocks_head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>rlm <span class="operator">||</span> <span class="operator">!</span>rlm-&gt;_name) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Boolean</span> did <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//记录其中一个block结点是否被执行过</span></span><br><span class="line">    <span class="comment">//取出头尾结点，并且将当前runloop保存的头尾节点置位NULL</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_block_item</span> *<span class="title class_">head</span> = <span class="title class_">rl</span>-&gt;<span class="title class_">_blocks_head</span>;</span><br><span class="line">    <span class="title class_">struct</span> <span class="title class_">_block_item</span> *<span class="title class_">tail</span> = <span class="title class_">rl</span>-&gt;<span class="title class_">_blocks_tail</span>;</span><br><span class="line">    <span class="title class_">rl</span>-&gt;<span class="title class_">_blocks_head</span> = <span class="title class_">NULL</span>;</span><br><span class="line">    <span class="title class_">rl</span>-&gt;<span class="title class_">_blocks_tail</span> = <span class="title class_">NULL</span>;</span><br><span class="line">    //取出被标记为<span class="title class_">common</span>的所有<span class="title class_">mode</span>、及当前<span class="title class_">model</span>的<span class="title class_">name</span></span><br><span class="line">    <span class="title class_">CFSetRef</span> <span class="title class_">commonModes</span> = <span class="title class_">rl</span>-&gt;<span class="title class_">_commonModes</span>;</span><br><span class="line">    <span class="title class_">CFStringRef</span> <span class="title class_">curMode</span> = <span class="title class_">rlm</span>-&gt;<span class="title class_">_name</span>;</span><br><span class="line">    <span class="title class_">__CFRunLoopModeUnlock</span>(<span class="title class_">rlm</span>);</span><br><span class="line">    <span class="title class_">__CFRunLoopUnlock</span>(<span class="title class_">rl</span>);</span><br><span class="line">    </span><br><span class="line">    //定义两个临时变量，用于对保存<span class="title class_">block</span>链表的遍历</span><br><span class="line">    <span class="title class_">struct</span> <span class="title class_">_block_item</span> *<span class="title class_">prev</span> = <span class="title class_">NULL</span>;</span><br><span class="line">    <span class="title class_">struct</span> <span class="title class_">_block_item</span> *<span class="title class_">item</span> = <span class="title class_">head</span>;//记录头指针，从头部开始遍历</span><br><span class="line">    //开始遍历<span class="title class_">block</span>链表</span><br><span class="line">    <span class="title class_">while</span> (<span class="title class_">item</span>) &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">_block_item</span> *<span class="title class_">curr</span> = <span class="title class_">item</span>;</span><br><span class="line">        <span class="title class_">item</span> = <span class="title class_">item</span>-&gt;<span class="title class_">_next</span>;</span><br><span class="line">	<span class="title class_">Boolean</span> <span class="title class_">doit</span> = <span class="title class_">false</span>；//表示是否应该执行这个<span class="title class_">block</span>,注意和前面的<span class="title class_">did</span>区分开</span><br><span class="line">	</span><br><span class="line">	//从<span class="title class_">blockitem</span>结构体就知道,其中的<span class="title class_">_mode</span>只能是<span class="title class_">CFString</span> 或者<span class="title class_">CFSet</span></span><br><span class="line">	//如果<span class="title class_">block</span>结点保存的<span class="title class_">model</span>是<span class="title class_">CFString</span>类型</span><br><span class="line">	<span class="title class_">if</span> (<span class="title class_">CFStringGetTypeID</span>() == <span class="title class_">CFGetTypeID</span>(<span class="title class_">curr</span>-&gt;<span class="title class_">_mode</span>)) &#123;</span><br><span class="line">	   <span class="comment">//是否执行block只需要满足下面三个条件中的一个</span></span><br><span class="line">	   <span class="comment">//1. blockitem 中保存的model是当前的model</span></span><br><span class="line">	   <span class="comment">//2. blockitem 中保存的model是标记为kCFRunLoopCommonModes的model</span></span><br><span class="line">	   <span class="comment">//3. 当前model保存在commonModes数组</span></span><br><span class="line">	    doit <span class="operator">=</span> <span class="type">CFEqual</span>(curr-&gt;_mode, curMode) <span class="operator">||</span> (<span class="type">CFEqual</span>(curr-&gt;_mode, kCFRunLoopCommonModes) <span class="operator">&amp;&amp;</span> <span class="type">CFSetContainsValue</span>(commonModes, curMode));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//如果block结点保存的model是CFSet类型，步骤和上面一样，等于换成了包含。</span></span><br><span class="line">	    doit <span class="operator">=</span> <span class="type">CFSetContainsValue</span>((<span class="type">CFSetRef</span>)curr-&gt;_mode, curMode) <span class="operator">||</span> (<span class="type">CFSetContainsValue</span>((<span class="type">CFSetRef</span>)curr-&gt;_mode, kCFRunLoopCommonModes) <span class="operator">&amp;&amp;</span> <span class="type">CFSetContainsValue</span>(commonModes, curMode));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果不执行block,则直接移动当前结点，进行下一个blockitem的判断</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="operator">!</span>doit) prev <span class="operator">=</span> curr;</span><br><span class="line">	<span class="keyword">if</span> (doit) &#123;</span><br><span class="line">	<span class="comment">//如果执行block,则先移动结点。</span></span><br><span class="line">	    <span class="keyword">if</span> (prev) prev-&gt;_next <span class="operator">=</span> item;</span><br><span class="line">	    <span class="keyword">if</span> (curr <span class="operator">==</span> head) head <span class="operator">=</span> item;</span><br><span class="line">	    <span class="keyword">if</span> (curr <span class="operator">==</span> tail) tail <span class="operator">=</span> prev;</span><br><span class="line">	   </span><br><span class="line">	    void (<span class="operator">^</span>block)(void) <span class="operator">=</span> curr-&gt;_block;</span><br><span class="line">            <span class="type">CFRelease</span>(curr-&gt;_mode);</span><br><span class="line">            free(curr);</span><br><span class="line">	    <span class="keyword">if</span> (doit) &#123;</span><br><span class="line">	    <span class="comment">//最终在这里执行block，__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__的函数原型就是调用block</span></span><br><span class="line">                __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line">	        did <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">            <span class="type">Block_release</span>(block); <span class="comment">// do this before relocking to prevent deadlocks where some yahoo wants to run the run loop reentrantly from their dealloc</span></span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    __CFRunLoopModeLock(rlm);</span><br><span class="line">    <span class="comment">//重建循环链表</span></span><br><span class="line">    <span class="keyword">if</span> (head) &#123;</span><br><span class="line">	tail-&gt;_next <span class="operator">=</span> rl-&gt;_blocks_head;</span><br><span class="line">	rl-&gt;_blocks_head <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>rl-&gt;_blocks_tail) rl-&gt;_blocks_tail <span class="operator">=</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> did;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面分析可以知道：</p>
<ul>
<li>block其实在runloop中通过循环链表保存的</li>
<li>如果block可以加入到多个model下面，但是执行block只有在加入的那个model下才能之后，或者加入modle用common标记</li>
<li>每次调用__CFRunLoopDoBlocks，会把加入的block遍历执行，然后重置循环链表。</li>
</ul>
<h2 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h2><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h2 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h2><p>上面可以看到第二个observe就是_UIGestureRecognizerUpdateObserver，关于手势识别的。</p>
<p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h2 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h2><p>上面可以看到第三和四个observe分别是_beforeCACommitHandler与_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv，是关于动画及界面更新的。</p>
<p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>上面截图中还有个timer</p>
<p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 来实现延迟执行，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。<code>所以如果当前线程没有 RunLoop，则这个方法会失效。</code></p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，<code>同样的，如果对应线程没有 RunLoop 该方法也会失效。</code></p>
<h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>回到主线程<br>dispatch_async(dispatch_get_main_queue(), ^{<br>                                   &lt;##&gt;<br>                               });</p>
<h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><p>常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<h1 id="Runloop在平时开发中的应用"><a href="#Runloop在平时开发中的应用" class="headerlink" title="Runloop在平时开发中的应用"></a>Runloop在平时开发中的应用</h1><ul>
<li>AFN线程保活</li>
</ul>
<p>AF希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop。过程在networkRequestThreadEntryPoint中，因为RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>
<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中，具体内容对应start方法。</p>
<ul>
<li>AsyncDisplayKit</li>
</ul>
<p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p>
<p>可以直接看源码进行分析<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rYXJjaGl2ZS9Bc3luY0Rpc3BsYXlLaXQ=">AsyncDisplayKit<i class="fa fa-external-link-alt"></i></span>，但是现在更名为<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RleHR1cmVncm91cC90ZXh0dXJlLw==">Texture<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="RunLoop的启动和退出"><a href="#RunLoop的启动和退出" class="headerlink" title="RunLoop的启动和退出"></a>RunLoop的启动和退出</h1><ul>
<li>启动RunLoop的三种方式<br>通过[NSRunLoop currentRunLoop]或者CFRunLoopGetCurrent()可以获取当前线程的runloop。<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>run;  </span><br><span class="line">- <span class="params">(void)</span>runUntilDate:<span class="params">(NSDate *)</span>limitDate；</span><br><span class="line">- <span class="params">(void)</span>runMode:<span class="params">(NSString *)</span>mode beforeDate:<span class="params">(NSDate *)</span>limitDate;</span><br></pre></td></tr></table></figure>
这三种方式无论通过哪一种方式启动runloop，如果没有<code>一个输入源或者timer</code>附加于<code>runloop</code>上，<code>runloop</code>就会立刻退出。<br>(1) 第一种方式，runloop会一直运行下去(线程常驻)，在此期间会处理来自输入源的数据，并且会在NSDefaultRunLoopMode模式下重复调用<code>runMode:beforeDate:</code>方法。<br>(2) 第二种方式，可以设置超时时间，在超时时间到达之前，runloop会一直运行，在此期间runloop会处理来自输入源的数据，并且也会在NSDefaultRunLoopMode模式下重复调用<code>runMode:beforeDate:</code>方法。<br>(3) 第三种方式，runloop会运行一次，超时时间到达或者第一个input source被处理，则runloop就会退出。<br><code>前两种启动方式会重复调用runMode:beforeDate:方法。</code></li>
</ul>
<ul>
<li>退出RunLoop的方式</li>
</ul>
<p>(1) 第一种启动方式的退出方法<br>文档说，如果想退出runloop，不应该使用第一种启动方式来启动runloop。<br>如果runloop没有input sources或者附加的timer，runloop就会退出。<br>虽然这样可以将runloop退出，但是苹果并不建议我们这么做，因为系统内部有可能会在当前线程的runloop中添加一些输入源，所以通过手动移除input source或者timer这种方式，并不能保证runloop一定会退出。<br>(2)第二种启动方式的退出方法 <code>runUntilDate:</code><br>可以通过 设置超时时间 来退出 runloop。<br>(3)第三种启动方式的退出方法 <code>runMode:beforeDate:</code><br>通过这种方式启动，runloop只会运行一次，当超时时间到达或者第一个输入源被处理，runloop就会退出。</p>
<p>如果我们想控制 runloop 的退出时机，而不是在处理完一个输入源事件之后就退出，那么就要重复调用<code>runMode:beforeDate:</code><br>具体可以参考苹果文档给出的方案，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSRunLoop</span> *myLoop  = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">myPort = (<span class="built_in">NSMachPort</span> *)[<span class="built_in">NSMachPort</span> port];</span><br><span class="line">[myLoop addPort:_port forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"><span class="type">BOOL</span> isLoopRunning = <span class="literal">YES</span>; <span class="comment">// global</span></span><br><span class="line"><span class="keyword">while</span> (isLoopRunning &amp;&amp; [myLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]]);</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在关闭runloop的地方</span></span><br><span class="line">- (<span class="type">void</span>)quitLoop</span><br><span class="line">&#123;</span><br><span class="line">    isLoopRunning = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之<br>如果不想退出runloop可以使用第一种方式启动runloop；<br>使用第二种方式启动runloop，可以通过设置超时时间来退出；<br>使用第三种方式启动runloop，可以通过设置超时时间或者使用CFRunLoopStop方法来退出。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>面试总结</category>
        <category>RunLoop</category>
      </categories>
      <tags>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化</title>
    <url>/iOS/interview/xingneng.html</url>
    <content><![CDATA[<h1 id="入门级"><a href="#入门级" class="headerlink" title="入门级"></a>入门级</h1><ol>
<li><p>用 ARC 管理内存 </p>
</li>
<li><p>在正确的地方使用 reuseIdentifier </p>
</li>
<li><p>尽量把 views 设置为透明 </p>
</li>
<li><p>避免过于庞大的 XIB </p>
</li>
<li><p>不要阻塞主线程</p>
</li>
<li><p>在 ImageViews 中调整图片大小。如果要在 UIImageView 中显示一个来自 bundle 的图片，你应保证图片 的大小和 UIImageView 的大小相同。在运行中缩放图片是很耗费资源的，特别是 UIImageView 嵌套在 UIScrollView 中的情况下。如果图片是从远端服务加载的你不能控制图片大小，比如在下载前调整到合适大 小的话，你可以在下载完成后，最好是用 background thread，缩放一次，然后在 UIImageView 中使用缩放后的图片。 </p>
</li>
<li><p>选择正确的 Collection。</p>
<ul>
<li>Arrays: 有序的一组值。使用 index 来 lookup 很快，使用 value lookup 很慢， 插入/删除很慢。 </li>
<li>Dictionaries: 存储键值对。 用键来查找比较快。</li>
<li>Sets: 无序的一组值。用值来查找很快，插入/删除很快。</li>
</ul>
</li>
<li><p>打开 gzip 压缩。app 可能大量依赖于服务器资源，问题是我们的目标是移动设备，因此你就不能指望网 络状况有多好。减小文档的一个方式就是在服务端和你的 app 中打开 gzip。这对于文字这种能有更高压缩 率的数据来说会有更显著的效用。<br>iOS 已经在 NSURLConnection 中默认支持了 gzip 压缩，当然 AFNetworking 这些基于它的框架亦然。</p>
</li>
</ol>
<h1 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h1><ol>
<li><p>重用和延迟加载(lazy load) Views</p>
<ul>
<li>更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在 UIScrollView 里边的 app 更是如此。</li>
<li>这里我们用到的技巧就是模仿UITableView和UICollectionView的操作:不要一次创建所有的subview， 而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。这样的话你就只需要在 滚动发生时创建你的 views，避免了不划算的内存分配。</li>
</ul>
</li>
<li><p>Cache, Cache, 还是 Cache!</p>
<ul>
<li>一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。</li>
<li>我们能缓存些什么呢?一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。</li>
<li>NSCache 和 NSDictionary 类似，不同的是系统回收内存的时候它会自动删掉它的内容。</li>
</ul>
</li>
<li><p>权衡渲染方法.性能能还是要 bundle 保持合适的大小。</p>
</li>
<li><p>处理内存警告.移除对缓存，图片 object 和其他一些可以重创建的 objects 的 strong references. </p>
</li>
<li><p>重用大开销对象</p>
</li>
<li><p>一些 objects 的初始化很慢，比如 NSDateFormatter 和 NSCalendar。然而，你又不可避免地需要使用它们， 比如从 JSON 或者 XML 中解析数据。想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性 到你的 class 里或者创建静态变量来实现。</p>
</li>
<li><p>避免反复处理数据.在服务器端和客户端使用相同的数据结构很重要。</p>
</li>
<li><p>选择正确的数据格式.解析 JSON 会比 XML 更快一些，JSON 也通常更小更便于传输。从 iOS5 起有了官方 内建的 JSON deserialization 就更加方便使用了。但是 XML 也有 XML 的好处，比如使用 SAX 来解析 XML 就 像解析本地文件一样，你不需像解析 json 一样等到整个文档下载完成才开始解析。当你处理很大的数据的 时候就会极大地减低内存消耗和增加性能。</p>
</li>
<li><p>正确设定背景图片</p>
<ul>
<li>全屏背景图，在view中添加一个UIImageView作为一个子View</li>
<li>只是某个小的view的背景图，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存:</li>
</ul>
</li>
<li><p>减少使用 Web 特性。想要更高的性能你就要调整下你的 HTML 了。第一件要做的事就是尽可能移除不 必要的 javascript，避免使用过大的框架。能只用原生 js 就更好了。尽可能异步加载例如用户行为统计 script 这种不影响页面表达的 javascript。注意你使用的图片，保证图片的符合你使用的大小。</p>
</li>
<li><p>Shadow Path 。CoreAnimation 不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。 使用 shadowPath 的话就避免了这个问题。使用 shadow path 的话 iOS 就不必每次都计算如何渲染，它使用 一个预先计算好的路径。但问题是自己计算 path 的话可能在某些 View 中比较困难，且每当 view 的 frame 变化的时候你都需要去 update shadow path.</p>
</li>
<li><p>优化 Table View</p>
<ul>
<li>正确使用reuseIdentifier来重用cells</li>
<li>尽量使所有的viewopaque，包括cell自身</li>
<li>避免渐变，图片缩放，后台选人</li>
<li>缓存行高</li>
<li>如果cell内现实的内容来自web，使用异步加载，缓存请求结果</li>
<li>使用shadowPath来画阴影</li>
<li>减少subviews的数量</li>
<li>尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用-一次然后缓存结果</li>
<li>使用正确的数据结构来存储数据</li>
<li>使用 rowHeight, sectionFooterHeight 和 sectionHeaderHeight 来设定固定的高，不要请求 delegate</li>
</ul>
</li>
<li><p>选择正确的数据存储选项</p>
<ul>
<li>NSUserDefaults 的问题是什么?虽然它很 nice 也很便捷，但是它只适用于小数据，比如一些简单的布 尔型的设置选项，再大点你就要考虑其它方式了</li>
<li>XML 这种结构化档案呢?总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用 SAX 又是一个很麻烦的事情。</li>
<li>NSCoding?不幸的是，它也需要读写文件，所以也有以上问题。</li>
<li>在这种应用场景下，使用 SQLite 或者 Core Data 比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。</li>
<li>在性能层面来讲，SQLite和CoreData是很相似的。他们的不同在于具体使用方法。</li>
<li>Core Data 代表一个对象的 graph model，但 SQLite 就是一个 DBMS。</li>
<li>Apple 在一般情况下建议使用 Core Data，但是如果你有理由不使用它，那么就去使用更加底层的 SQLite吧。</li>
<li>如果你使用SQLite，你可以用FMDB这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C API了。</li>
</ul>
</li>
</ol>
<h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><ol>
<li>加速启动时间。快速打开 app 是很重要的，特别是用户第一次打开它时，对 app 来讲，第一印象太太太 重要了。你能做的就是使它尽可能做更多的异步任务，比如加载远端或者数据库数据，解析数据。避免过 于庞大的 XIB，因为他们是在主线程上加载的。所以尽量使用没有这个问题的 Storyboards 吧!一定要把设 备从 Xcode 断开来测试启动速度</li>
<li>使用 Autorelease Pool。NSAutoreleasePool`负责释放 block 中的 autoreleased objects。一般情况下它会自 动被 UIKit 调用。但是有些状况下你也需要手动去创建它。假如你创建很多临时对象，你会发现内存一直在 减少直到这些对象被 release 的时候。这是因为只有当 UIKit 用光了 autorelease pool 的时候 memory 才会被 释放。消息是你可以在你自己的@autoreleasepool 里创建临时的对象来避免这个行为。</li>
<li>选择是否缓存图片。常见的从 bundle 中加载图片的方式有两种，一个是用 imageNamed，二是用 imageWithContentsOfFile，第一种比较常见一点。</li>
<li>避免日期格式转换。如果你要用 NSDateFormatter 来处理很多日期格式，应该小心以待。就像先前提到 的，任何时候重用 NSDateFormatters 都是一个好的实践。如果你可以控制你所处理的日期格式，尽量选择 Unix 时间戳。你可以方便地从时间戳转换到 NSDate:</li>
</ol>
<h1 id="如何提升-tableview-的流畅度"><a href="#如何提升-tableview-的流畅度" class="headerlink" title="如何提升 tableview 的流畅度?"></a>如何提升 tableview 的流畅度?</h1><p>本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。</p>
<ul>
<li>CPU:对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、 图像的绘制</li>
<li>GPU:纹理的渲染</li>
</ul>
<p>卡顿优化在 CPU 层面</p>
<ul>
<li>尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView</li>
<li>不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的<br>修改</li>
<li>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</li>
<li>Autolayout 会比直接设置 frame 消耗更多的 CPU 资源</li>
<li>图片的 size 最好刚好跟 UIImageView 的 size 保持一致</li>
<li>控制一下线程的最大并发数量</li>
<li>尽量把耗时的操作放到子线程</li>
<li>文本处理(尺寸计算、绘制) - 图片处理(解码、绘制)</li>
</ul>
<p>卡顿优化在 GPU 层面</p>
<ul>
<li>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</li>
<li>GPU 能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以<br>纹理尽量不要超过这个尺寸</li>
<li>尽量减少视图数量和层次</li>
<li>减少透明的视图(alpha&lt;1)，不透明的就设置 opaque 为 YES</li>
<li>尽量避免出现离屏渲染</li>
</ul>
<p>1.预排版，提前计算<br>在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提 前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。<br>尽量少用 UILabel，可以使用 CALayer 。避免使用 AutoLayout 的自动布局技术，采取纯代码的方 式</p>
<p>2.预渲染，提前绘制<br>例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，<br>回到主线程后直接调用就可以了<br>避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。<br>3.异步绘制<br>4.全局并发线程 5.高效的图片异步加载</p>
<h1 id="如何优化-APP-的电量"><a href="#如何优化-APP-的电量" class="headerlink" title="如何优化 APP 的电量?"></a>如何优化 APP 的电量?</h1><h4 id="程序的耗电主要在以下四个方面"><a href="#程序的耗电主要在以下四个方面" class="headerlink" title="程序的耗电主要在以下四个方面:"></a>程序的耗电主要在以下四个方面:</h4><ul>
<li>CPU 处理</li>
<li>定位</li>
<li>网络</li>
<li>图像</li>
</ul>
<h4 id="优化的途径主要体现在以下几个方面"><a href="#优化的途径主要体现在以下几个方面" class="headerlink" title="优化的途径主要体现在以下几个方面:"></a>优化的途径主要体现在以下几个方面:</h4><ul>
<li>尽可能降低 CPU、GPU 的功耗。</li>
<li>尽量少用 定时器。</li>
<li>优化 I/O 操作。<br>o 不要频繁写入小数据，而是积攒到一定数量再写入<br>o 读写大量的数据可以使用 Dispatch_io ，GCD 内部已经做了优化。 o 数据量比较大时，建议使用数据库</li>
<li>网络方面的优化<br>o 减少压缩网络数据 (XML -&gt; JSON -&gt; ProtoBuf)，如果可能建议使用 ProtoBuf。<br>o 如果请求的返回数据相同，可以使用 NSCache 进行缓存<br>o 使用断点续传，避免因网络失败后要重新下载。<br>o 网络不可用的时候，不尝试进行网络请求<br>o 长时间的网络请求，要提供可以取消的操作<br>o 采取批量传输。下载视频流的时候，尽量一大块一大块的进行下载，广告可以一次下载<br>多个 - 定位层面的优化<br>o 如果只是需要快速确定用户位置，最好用 CLLocationManager 的 requestLocation 方法。 定位完成后，会自动让定位硬件断电<br>o 如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务<br>o 尽量降低定位精度，比如尽量不要使用精度最高的 kCLLocationAccuracyBest<br>o 需要后台定位时，尽量设置 pausesLocationUpdatesAutomatically 为 YES，如果用户不太<br>可能移动的时候系统会自动暂停位置更新<br>o 尽 量 不 要 使 用 startMonitoringSignificantLocationChanges ， 优 先 考 虑<br>startMonitoringForRegion:</li>
<li>硬件检测优化<br>用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、 磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件</li>
</ul>
<h1 id="如何有效降低-APP-包的大小"><a href="#如何有效降低-APP-包的大小" class="headerlink" title="如何有效降低 APP 包的大小?"></a>如何有效降低 APP 包的大小?</h1><p>可执行文件</p>
<ul>
<li>编译器优化</li>
<li>Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default 设置为 YES</li>
<li>去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为 NO， Other C Flags 添加 -fno-exceptions</li>
<li>利用 AppCode 检测未使用的代码:菜单栏 -&gt; Code -&gt; Inspect Code</li>
<li>编写LLVM插件检测出重复代码、未被调用的代码<br>资源<br>资源包括 图片、音频、视频 等</li>
<li>优化的方式可以对资源进行无损的压缩 </li>
<li>去除没有用到的资源</li>
</ul>
<h1 id="什么是-离屏渲染-什么情况下会触发-该如何应对"><a href="#什么是-离屏渲染-什么情况下会触发-该如何应对" class="headerlink" title="什么是 离屏渲染?什么情况下会触发?该如何应对?"></a>什么是 离屏渲染?什么情况下会触发?该如何应对?</h1><p>离屏渲染出发的场景有以下:</p>
<ul>
<li>圆角(maskToBounds并用才会触发) - 图层蒙版</li>
<li>阴影</li>
<li>光栅化<br>为什么要避免离屏渲染?<br>CPUGPU 在绘制渲染视图时做了大量的工作。离屏渲染发生在 GPU 层面上，会创建新的渲染缓冲区，会 触发 OpenGL 的多通道渲染管线，图形上下文的切换会造成额外的开销，增加 GPU 工作量。如果 CPU GPU 累计耗时 16.67 毫秒还没有完成，就会造成卡顿掉帧。<br>圆角属性、蒙层遮罩 都会触发离屏渲染。指定了以上属性，标记了它在新的图形上下文中，在未愈合之前， 不可以用于显示的时候就出发了离屏渲染。</li>
<li>在OpenGL中，GPU有2种渲染方式</li>
<li>On-Screen Rendering:当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作</li>
<li>Off-Screen Rendering:离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作</li>
<li>离屏渲染消耗性能的原因</li>
<li>需要创建新的缓冲区</li>
<li>离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕(On-Screen)切换到离屏 (Off-Screen);等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文 环境从离屏切换到当前屏幕</li>
<li>哪些操作会触发离屏渲染?</li>
<li>光栅化，layer.shouldRasterize = YES</li>
<li>遮罩，layer.mask</li>
<li>圆角，同时设置layer.masksToBounds=YES、layer.cornerRadius大于0</li>
<li>考虑通过 CoreGraphics 绘制裁剪圆角，或者叫美工提供圆角图片</li>
<li>阴影，layer.shadowXXX，如果设置了 layer.shadowPath 就不会产生离屏渲染</li>
</ul>
]]></content>
      <categories>
        <category>performance</category>
      </categories>
      <tags>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/iOS/memorymanagerment/memory.html</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9jbGFuZy5sbHZtLm9yZy9kb2NzL0F1dG9tYXRpY1JlZmVyZW5jZUNvdW50aW5nLmh0bWwjYXV0b3JlbGVhc2Vwb29s">Clang ARC的文档<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="autoReleasePool-什么时候释放"><a href="#autoReleasePool-什么时候释放" class="headerlink" title="autoReleasePool 什么时候释放?"></a><code>autoReleasePool</code> 什么时候释放?</h2><p><code>App</code>启动后，苹果在主线程 <code>RunLoop</code> 里注册了两个 <code>Observer</code>，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p>
<p>第一个 <code>Observer</code> 监视的事件是 <code>Entry(即将进入Loop)</code>，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 <code>order</code> 是 <code>-2147483647</code>，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 <code>Observer</code> 监视了两个事件： <code>BeforeWaiting</code>(准备进入休眠) 时调用<code>_objc_autoreleasePoolPop()</code>  和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；<code>Exit</code>(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。这个 <code>Observer</code> 的 <code>order</code> 是 <code>2147483647</code>，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、<code>Timer</code>回调内的。这些回调会被 <code>RunLoop</code> 创建好的 <code>AutoreleasePool</code> 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 <code>Pool</code> 了。</p>
<h2 id="在-Obj-C-中，如何检测内存泄漏？你知道哪些方式？"><a href="#在-Obj-C-中，如何检测内存泄漏？你知道哪些方式？" class="headerlink" title="在 Obj-C 中，如何检测内存泄漏？你知道哪些方式？"></a>在 <code>Obj-C</code> 中，如何检测内存泄漏？你知道哪些方式？</h2><p>目前我知道的方式有以下几种</p>
<ul>
<li>Memory Leaks</li>
<li>Alloctions</li>
<li>Analyse</li>
<li>Debug Memory Graph</li>
<li>MLeaksFinder</li>
</ul>
<p>泄露的内存主要有以下两种：</p>
<ul>
<li><code>Laek Memory</code> 这种是忘记 <code>Release</code> 操作所泄露的内存。</li>
<li><code>Abandon Memory</code> 这种是循环引用，无法释放掉的内存。</li>
</ul>
<p>上面所说的五种方式，其实前四种都比较麻烦，需要不断地调试运行，第五种是腾讯阅读团队出品，效果好一些，感兴趣的可以看一下这两篇文章：</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3dlcmVhZHRlYW0uZ2l0aHViLmlvLzIwMTYvMDIvMjIvTUxlYWtzRmluZGVyLw==">MLeaksFinder：精准 iOS 内存泄露检测工具<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3dlcmVhZHRlYW0uZ2l0aHViLmlvLzIwMTYvMDcvMjAvTUxlYWtzRmluZGVyMi8=">MLeaksFinder 新特性<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS内存管理</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>iOS内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Mach微内核简介</title>
    <url>/iOS/kernelarchitecture/mach.html</url>
    <content><![CDATA[<h1 id="Mach"><a href="#Mach" class="headerlink" title="Mach"></a>Mach</h1><p>OS X内核的基本服务和基本类型都基于Mach 3.0。苹果对Mach进行了修改和扩展，以更好地满足OS X的功能和性能目标。</p>
<p>Mach 3.0最初被认为是一个简单、可扩展的通信微内核。它能够作为一个独立的内核运行，而其他传统的操作系统服务(如I/O、文件系统和网络堆栈)作为用户模式服务器运行。</p>
<p>然而，在OS X中，Mach与其他内核组件<code>链接到一个内核地址空间</code>中。这主要是<code>为了性能</code>;在链接组件之间进行直接调用要比在单独<code>任务之间发送消息</code>或<code>执行远程过程调用(RPC)</code>快得多。这种模块化的结构导致了一个比单一内核所允许的更健壮和可扩展的系统，而没有纯微内核的性能损失。</p>
<p>因此，在OS X中，Mach主要不是客户机和服务器之间的通信中心。相反，它的价值由抽象、可扩展性和灵活性组成。特别地，Mach提供了</p>
<ul>
<li>基于对象的api，使用通信通道(例如端口)作为对象引用</li>
<li>高度并行执行，包括预先调度的线程和对SMP的支持</li>
<li>一个灵活的调度框架，支持实时使用</li>
<li>一组完整的IPC原语，包括消息传递、RPC、同步和通知</li>
<li>支持大型虚拟地址空间、共享内存区域和由持久性存储支持的内存对象</li>
<li>经过验证的可扩展性和可移植性，例如跨指令集体系结构和分布式环境</li>
<li>安全与资源管理作为设计的基本原则;所有资源都是虚拟化的</li>
</ul>
<h1 id="Mach内核抽象化"><a href="#Mach内核抽象化" class="headerlink" title="Mach内核抽象化"></a>Mach内核抽象化</h1><p>Mach提供了一组被设计成既简单又强大的抽象。这些是主要的内核抽象:</p>
<ul>
<li>任务(Tasks)。资源所有权单位;每个任务由一个虚拟地址空间、一个端口名称空间和一个或多个线程组成。(类似于流程。)</li>
<li>线程(Threads)。任务中CPU执行的单位。</li>
<li>地址空间(Address space)。与内存管理器一起，Mach实现了稀疏虚拟地址空间和共享内存的概念。</li>
<li>内存对象(Memory objects)。内存管理的内部单元。内存对象包括命名项和区域;它们表示可能映射到地址空间的持久数据。</li>
<li>端口(Ports)。安全、简单的通信通道，只能通过发送和接收功能(称为端口权限)访问。</li>
<li>IPC。消息队列、远程过程调用、通知、信号量和锁集。</li>
<li>时间(Time)。时钟、定时器和等待。</li>
</ul>
<p>在陷阱级别，大多数Mach抽象的接口由<code>表示这些对象的内核端口之间</code>的<code>消息</code>组成。陷阱(trap)级别的<code>接口</code>(例如mach_msg_overwrite_trap)和<code>消息格式</code>在正常使用中由Mach接口生成器(MIG)抽象出来。MIG用于编译基于消息的api的<code>过程接口</code>，基于这些api的<code>描述</code>。（MIG参看下面总结部分）</p>
<h1 id="任务和线程"><a href="#任务和线程" class="headerlink" title="任务和线程"></a>任务和线程</h1><p>OS X进程和POSIX线程(pthreads)分别在Mach任务和线程之上实现。线程是任务中的控制流点。存在一个任务来为其包含的线程提供资源。这种分割是为了提供并行性和资源共享。</p>
<p>一个线程</p>
<ul>
<li>是任务中的控制流点。</li>
<li>可以访问包含任务的所有元素。</li>
<li>与其他线程(可能)并行执行，甚至是同一任务中的线程。</li>
<li>具有最小的状态信息，以降低开销。</li>
</ul>
<p>一个任务</p>
<ul>
<li>是系统资源的集合。这些资源(地址空间除外)由端口引用。如果对端口被分配了权限，那么这些资源可以与其他任务共享。</li>
<li>提供一个大的、可能稀疏的地址空间，由虚拟地址引用。这个空间的一部分可以通过继承或外部内存管理共享。</li>
<li>包含一些线程。</li>
</ul>
<p>请注意，任务没有自己的线程执行指令的生命周期。当说“task Y做X”时，真正的意思是“task Y中包含的线程做X”。</p>
<ol>
<li><p>任务是一个相当昂贵的实体。它的存在是资源的集合。任务中的所有线程都共享所有内容。如果没有显式的操作(尽管操作通常很简单)，两个任务就不能共享任何内容，而且一些资源(例如端口接收权限)根本不能在两个任务之间共享。</p>
</li>
<li><p>线程是一个相当轻量级的实体。它的创建成本相当低，操作开销也很低。这是真的，因为一个线程只有很少的状态信息(主要是它的寄存器状态)。它所拥有的任务承担着资源管理的重担。在多处理器计算机上，任务中的多个线程可以并行执行。即使并行性不是目标，多线程也有一个优势，即每个线程都可以使用同步编程风格，而不是试图使用单个线程进行异步编程来提供多个服务。</p>
</li>
<li><p>线程是基本的计算实体。一个线程只属于一个任务，这个任务定义了它的虚拟地址空间。影响地址空间的结构或引用任何资源以外的地址空间,线程必须执行一个<code>特殊的陷阱指令</code> 引起<code>内核代表线程</code>执行操作或<code>发送消息代理</code>代表线程。通常，这些陷阱操作与包含线程的任务相关的资源。内核可以发出请求来操作这些实体:创建它们、删除它们并影响它们的状态。</p>
</li>
<li><p>Mach为线程调度策略提供了一个灵活的框架。OS X的早期版本同时支持分时和固定优先级策略。提高和降低分时线程的优先级，以平衡它与其他分时线程之间的资源消耗。</p>
</li>
<li><p>固定优先级的线程执行一定的时间量，然后放在具有相同优先级的线程队列的末尾。将固定优先级线程的量子级别设置为无穷大，可以让线程一直运行，直到阻塞，或者直到被优先级更高的线程抢占为止。<code>高优先级实时线程</code>通常是<code>固定优先级</code>的。</p>
</li>
<li><p>OS X还为实时性能提供了时间约束调度。这个调度允许您指定线程必须在一定时间内获得一定的时间量。</p>
</li>
</ol>
<p>Mach调度在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0Rhcndpbi9Db25jZXB0dWFsL0tlcm5lbFByb2dyYW1taW5nL3NjaGVkdWxlci9zY2hlZHVsZXIuaHRtbCMvL2FwcGxlX3JlZi9kb2MvdWlkL1RQMzAwMDA5MDUtQ0gyMTEtQkVISkRGQ0E=">Mach调度和线程接口<i class="fa fa-external-link-alt"></i></span>中有进一步的描述。</p>
<h1 id="端口、端口权限、端口集和端口名称空间"><a href="#端口、端口权限、端口集和端口名称空间" class="headerlink" title="端口、端口权限、端口集和端口名称空间"></a>端口、端口权限、端口集和端口名称空间</h1><p>除了任务的虚拟地址空间之外，所有其他Mach资源都是通过称为端口的间接级别访问的。端口是请求服务的客户机和提供服务的服务器之间单向通信通道的端点。如果要向此类服务请求提供应答，则必须使用第二个端口。这类似于UNIX中的(单向)管道。</p>
<p>在大多数情况下，<code>由端口访问的资源(即由端口命名的资源)被称为对象</code>。大多数由端口命名的对象都有<code>一个接收方</code>和(可能的)<code>多个发送方</code>。也就是说，对于典型对象(如消息队列)，只有一个接收端口，至少有一个发送端口。</p>
<p>对象提供的服务由接收发送到对象的请求的管理器决定。因此，内核是与内核提供的对象关联的端口的接收方，而与任务提供的对象关联的端口的接收方是提供这些对象的任务。</p>
<p>对于命名任务提供的对象的端口，可以将该端口的请求接收方更改为不同的任务，例如通过在消息中将该端口传递给该任务。一个任务可能有多个引用其支持的资源的端口。就此而言，任何给定的实体都可以有多个表示它的端口，每个端口表示不同的允许操作集。例如，许多对象都有一个名称端口和一个控制端口(有时称为特权端口)。对控制端口的访问允许操作对象;对name端口的访问简单地为对象命名，这样您就可以获得关于它的信息，或者对它执行其他非特权操作。</p>
<p>任务具有以特定方式访问端口的权限(发送、接收、发送一次);这些被称为port rights。端口只能通过右值访问。端口通常用于授予客户机对Mach内对象的访问权。有权发送到对象的IPC端口表示有权以规定的方式操作对象。因此，<code>端口所有权是Mach内部的基本安全机制</code>。<code>拥有访问对象的权利</code>就是<code>拥有访问或操作该对象的能力</code>。</p>
<p>端口权限可以通过IPC在<code>任务之间复制和移动</code>。这样做实际上是将功能传递给某个对象或服务器。</p>
<p>一种类型的对象引用一个端口是一个端口组。顾名思义,端口设置一组端口的权利时,可以当作一个单独的单元接收消息或事件的任何成员集。港口集允许一个线程等待的消息和事件源,例如在工作循环。</p>
<p>传统上，在Mach中，由端口表示的通信通道总是消息队列。然而，OS X支持其他类型的通信通道，这些新的IPC对象类型也由端口和端口权限表示。有关消息和其他IPC类型的详细信息，请参阅下面进程间通信(Interprocess Communication, IPC)一节。</p>
<p>端口和端口权限没有允许直接操作任意端口或权限的系统范围名称。只有当任务在其端口名称空间中具有端口权时，才可以由任务操作端口。端口权由端口名称指定，一个整数索引进入一个32位端口名称空间。每个任务都与它关联一个端口名称空间。</p>
<p>当另一个任务显式地将它们插入它的名称空间时，当它们在消息中接收到权限时，任务通过创建返回对象权限的对象获得端口权限，并通过Mach调用特定的特殊端口(mach_thread_self、mach_task_self和mach_reply_port)获得端口权限。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>与大多数现代操作系统一样，Mach提供对大型、稀疏的虚拟地址空间的寻址。运行时访问是通过虚拟地址进行的，这些虚拟地址可能与初始访问时物理内存中的位置不对应。Mach负责获取一个请求的虚拟地址，并在物理内存中为它分配一个相应的位置。它通过请求分页来实现这一点。</p>
<p>当内存对象映射到虚拟地址空间的范围时，将用数据填充虚拟地址空间的范围。地址空间中的所有数据最终都是通过内存对象提供的。Mach在物理内存中建立页面时，向内存对象(分页器)的所有者询问页面的内容，并在回收页面之前将可能修改过的数据返回给分页器。OS X包含两个内置分页器——默认分页器和vnode分页器(default pager and the vnode pager)。</p>
<p>默认的分页器处理非持久性内存，称为匿名内存。匿名内存是零初始化的，并且只在任务执行期间存在。vnode分页器将文件映射到内存对象。Mach向内存对象导出一个接口，允许用户模式任务提供内存对象的内容。这个接口称为外部内存管理接口(EMMI)。</p>
<p>内存管理子系统导出称为命名项或命名内存项的虚拟内存句柄。与大多数内核资源一样，这些资源由端口表示。拥有一个命名的内存条目句柄，允许所有者映射底层虚拟内存对象，或者将映射底层对象的权利传递给其他人。在两个不同的任务中映射命名项会在两个任务之间生成共享内存窗口，从而为建立共享内存提供了一种灵活的方法。</p>
<p>从OS X v10.1开始，EMMI系统得到了增强，以支持“无端口”EMMI。在传统的EMMI中，为每个内存区域创建两个Mach端口，同样也为每个缓存的vnode创建两个端口。在最初的实现中，无端口的EMMI用直接内存引用(基本上是指针)替换了这一点。在将来的版本中，端口将用于与内核外部的分页器通信，同时使用直接引用与驻留在内核空间中的分页器通信。这些更改的最终结果是，早期版本的无端口EMMI不支持运行在内核空间之外的分页器。这种支持有望在未来的版本中恢复。</p>
<p>虚拟内存空间的地址范围也可以通过直接分配(使用vm_allocation)来填充。底层虚拟内存对象是匿名的，并由默认分页程序支持。地址空间的共享范围也可以通过继承设置。创建新任务时，将从父任务中克隆它们。这种克隆也属于底层内存地址空间。根据与映射相关的属性，对象的映射部分可以作为副本继承，也可以作为共享，或者根本不可以。Mach采用一种称为“写中复制”的延迟复制形式，以优化任务创建时继承副本的性能。</p>
<p>不是直接复制范围，而是通过受保护的共享来实现写时复制优化。这两个任务共享要复制的内存，但具有只读访问。当任何一个任务试图修改范围的一部分时，该部分将被复制。这种对内存副本的延迟计算是一种重要的优化，它允许在几个方面进行简化，尤其是消息传递api。</p>
<p>Mach还提供了另一种形式的共享，通过导出指定的区域。命名区域是命名条目的一种形式，但是它不是由虚拟内存对象支持的，而是由虚拟映射片段支持的。这个片段可能包含到许多虚拟内存对象的映射。它可以映射到其他虚拟映射，提供了一种方法，不仅可以继承一组虚拟内存对象，还可以继承它们现有的映射关系。该特性在任务设置中提供了重要的优化，例如在共享用于共享库的地址空间的复杂区域时。</p>
<h1 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h1><p>任务之间的通信是Mach哲学的一个重要元素。Mach支持客户机/服务器系统结构，其中任务(客户机)通过通过通信通道发送的消息请求其他任务(服务器)来访问服务。</p>
<p>Mach中这些通信通道的端点称为端口，而端口权限表示使用该通道的权限。Mach提供的IPC形式包括</p>
<ul>
<li>消息队列</li>
<li>信号量</li>
<li>通知</li>
<li>锁集</li>
<li>远程过程调用(rpc)</li>
</ul>
<p>由端口表示的IPC对象的类型决定了该端口上允许的操作，以及数据传输的方式(和是否)。</p>
<blockquote>
<p>重要提示:OS X中的IPC设施处于过渡状态。在系统的早期版本中，并不是所有这些IPC类型都可以实现。</p>
</blockquote>
<p>对于端口的原始操作，有两种基本不同的Mach api, mach_ipc家族和mach_msg家族。在合理的范围内，这两个系列都可以用于任何IPC对象;然而，在新代码中，mach_ipc调用是首选的。mach_ipc调用在适当的地方维护状态信息，以便支持事务的概念。mach_msg调用支持遗留代码，但不推荐使用;他们是无状态的。</p>
<h2 id="IPC事务和事件调度"><a href="#IPC事务和事件调度" class="headerlink" title="IPC事务和事件调度"></a>IPC事务和事件调度</h2><p>当线程调用mach_ipc_dispatch,它反复处理事件设置的注册端口。这些事件可以从RPC参数块对象(如客户调用的结果),一个锁对象被(由于其他线程释放锁),通知或信号量被发布或消息来自一个传统的消息队列。</p>
<p>这些事件通过mach_msg_dispatch的调用来处理。有些事件暗示调用生命周期内存在事务。在锁的情况下，状态是锁的所有权。当callout返回时，锁被释放。在远程过程调用的情况下，状态是客户机的标识、参数块和应答端口。当callout返回时，将发送应答。</p>
<p>当callout返回时，事务(如果有的话)就完成了，线程等待下一个事件。mach_ipc_dispatch工具旨在支持工作循环。</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>最初，Mach中进程间通信的唯一样式是消息队列。只有一个任务可以持有表示消息队列的端口的接收权。这个任务允许从端口队列接收(读取)消息。多个任务可以拥有向队列发送(写)消息的端口的权限。</p>
<p>任务通过构建包含一组数据元素的数据结构与另一个任务通信，然后在其拥有发送权限的端口上执行消息发送操作。稍后，具有该端口接收权限的任务将执行消息接收操作。</p>
<p>一条消息可包括以下部分或全部:</p>
<ul>
<li>纯数据</li>
<li>存储范围的副本</li>
<li>端口的权利</li>
<li>内核隐式属性，如发送方的安全令牌</li>
</ul>
<p>消息传输是一个异步操作。消息逻辑上被复制到接收任务中，可能使用写时复制优化。接收任务中的多个线程可以尝试从给定端口接收消息，但是只有一个线程可以接收任何给定的消息。</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量IPC对象支持等待、post和post所有操作。这些是计数信号量，如果在该信号量的等待队列中当前没有线程在等待，则保存(计数)post。post all操作将唤醒所有当前等待的线程。</p>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>与信号量一样，通知对象也支持post和wait操作，但添加了一个state字段。状态是一个固定大小、固定格式的字段，在创建通知对象时定义。每个post更新状态字段;每个post都覆盖一个状态。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是提供对临界区互斥访问的对象。锁的主要接口是面向事务的(参见IPC事务和事件调度)。在事务期间，线程持有锁。当它从事务返回时，锁被释放。</p>
<h2 id="远程过程调用-RPC-对象"><a href="#远程过程调用-RPC-对象" class="headerlink" title="远程过程调用(RPC)对象"></a>远程过程调用(RPC)对象</h2><p>顾名思义，RPC对象旨在促进和优化远程过程调用。RPC对象的主要接口是面向事务的(参见IPC事务和事件调度)</p>
<p>当创建RPC对象时，定义一组参数块格式。当客户机发出RPC(对象上的发送)时，它会导致以预定义格式之一的消息创建并在对象上排队，然后最终传递给服务器(接收方)。当服务器从事务返回时，将回复返回给发送方。Mach试图通过使用客户机的资源执行服务器来优化事务;这称为<code>线程迁移</code>。</p>
<h1 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h1><p>Mach中时间的传统抽象是时钟，它提供了一组基于mach_timspec_t的异步报警服务。有一个或多个时钟对象，每个对象定义一个以纳秒为单位的单调递增的时间值。实时时钟是内置的，是最重要的，但是系统中可能还有其他时钟用于其他时间概念。时钟支持获取当前时间、给定时间段的睡眠、设置闹钟(在给定时间发送的通知)等操作。</p>
<p>mach_timespec_t API在OS x中是不推荐的。更新的、首选的API基于计时器对象，而计时器对象又使用AbsoluteTime作为基本数据类型。AbsoluteTime是一种依赖于机器的类型，通常基于平台本机时基。提供了一些例程来将绝对时间值转换为其他数据类型，或者从其他数据类型转换为绝对时间值，比如纳秒。计时器对象支持异步、无漂移通知、取消和提前警报。它们比时钟效率更高，分辨率更高。</p>
<h1 id="我们总结一下"><a href="#我们总结一下" class="headerlink" title="我们总结一下"></a>我们总结一下</h1><h2 id="Mach-、端口、Mach消息部分"><a href="#Mach-、端口、Mach消息部分" class="headerlink" title="Mach 、端口、Mach消息部分"></a>Mach 、端口、Mach消息部分</h2><ul>
<li>在Mach中所有东西（Task、线程、虚拟内存等）都是对象</li>
<li>对象与对象之间通信只能(任务虚拟地址空间)通过<code>端口</code>收发(<code>一个接收方，可以多个发送方</code>)消息。</li>
</ul>
<p>Mach做以下几件事儿：</p>
<ul>
<li>“控制点”或执行单元的管理。</li>
<li>线程或线程组（Task）的资源分配。</li>
<li>虚拟内存的分配和管理。</li>
<li>底层物理资源–即CPU、内存和任何物理设备的分配。</li>
</ul>
<h3 id="Mach消息结构体"><a href="#Mach消息结构体" class="headerlink" title="Mach消息结构体"></a>Mach消息结构体</h3><ul>
<li>最基本的包含两部分：消息头、消息体。可选的消息尾<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>	<span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">mach_msg_bits_t</span>	msgh_bits;<span class="comment">//标志位</span></span><br><span class="line">  <span class="type">mach_msg_size_t</span>	msgh_size;<span class="comment">//大小</span></span><br><span class="line">  <span class="type">mach_port_t</span>		msgh_remote_port;<span class="comment">//目标端口（发送：接受方，接收：发送方）</span></span><br><span class="line">  <span class="type">mach_port_t</span>		msgh_local_port; <span class="comment">//源端口（发送：发送方，接收：接收方）</span></span><br><span class="line">  <span class="type">mach_port_name_t</span>	msgh_voucher_port;</span><br><span class="line">  <span class="type">mach_msg_id_t</span>		msgh_id;</span><br><span class="line">&#125; <span class="type">mach_msg_header_t</span>; <span class="comment">//消息头</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">mach_msg_size_t</span> msgh_descriptor_count;</span><br><span class="line">&#125; <span class="type">mach_msg_body_t</span>;<span class="comment">//消息体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">mach_msg_header_t</span>       header;</span><br><span class="line">        <span class="type">mach_msg_body_t</span>         body;</span><br><span class="line">&#125; <span class="type">mach_msg_base_t</span>; <span class="comment">//基本消息</span></span><br><span class="line"><span class="keyword">typedef</span>	<span class="type">unsigned</span> <span class="type">int</span> <span class="type">mach_msg_trailer_type_t</span>;<span class="comment">//消息尾的类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">mach_msg_trailer_type_t</span>	msgh_trailer_type;</span><br><span class="line">  <span class="type">mach_msg_trailer_size_t</span>	msgh_trailer_size;</span><br><span class="line">&#125; <span class="type">mach_msg_trailer_t</span>; <span class="comment">//消息尾</span></span><br></pre></td></tr></table></figure></li>
<li>复杂一点的，将消息头的标志位mach_msg_bits_t设置为MACH_MSGH_BITS_COMPLEX，就表示复杂消息。此时消息体里面指定了描述符的个数，接下来就是一个接着一个的描述符：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">uint64_t</span>			address;<span class="comment">//数据的大小</span></span><br><span class="line">  <span class="type">boolean_t</span>     		deallocate: <span class="number">8</span>;<span class="comment">//发送之后是否接触分配</span></span><br><span class="line">  <span class="type">mach_msg_copy_options_t</span>       copy: <span class="number">8</span>;<span class="comment">//复制指令</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>     		pad1: <span class="number">8</span>;</span><br><span class="line">  <span class="type">mach_msg_descriptor_type_t</span>    type: <span class="number">8</span>;</span><br><span class="line">  <span class="type">mach_msg_size_t</span>       	size;<span class="comment">//数据的大小</span></span><br><span class="line">&#125; <span class="type">mach_msg_ool_descriptor64_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="消息收发"><a href="#消息收发" class="headerlink" title="消息收发"></a>消息收发</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">mach_msg_return_t</span>	<span class="title function_">mach_msg</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_header_t</span> *msg,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_option_t</span> option,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> send_size,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> rcv_size,</span></span><br><span class="line"><span class="params">					<span class="type">mach_port_name_t</span> rcv_name,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_timeout_t</span> timeout,</span></span><br><span class="line"><span class="params">					<span class="type">mach_port_name_t</span> notify)</span>;</span><br></pre></td></tr></table></figure>

<p>步骤如下：<br>发送消息：</p>
<ul>
<li>调用current_space()获取当前的IPC空间。</li>
<li>调用current_map()获取虚拟空间</li>
<li>消息大小正确性检查</li>
<li>计算要分配的消息大小</li>
<li>通过ipc_kmsg_alloc分配消息</li>
<li>复制消息</li>
<li>复制消息关联的端口权限，然后通过ipc_kmsg_copyin将所有的out-of-line数据的内存复制到当前虚拟空间。(如果不复制权限可能导致无法访问数据)</li>
<li>调用ipc_kmsg_send()发送消息<ul>
<li>获得msgh_remote_port引用并锁定端口</li>
<li>调用ipc_mqueue_send()，将消息直接复制到端口的ipc_messages队列中并唤醒等待的线程。</li>
</ul>
</li>
</ul>
<p>接收消息</p>
<ul>
<li>调用current_space()获取当前的IPC空间。</li>
<li>调用current_map()获取虚拟空间</li>
<li>调用ipc_mqueue_copyin()获取IPC队列。</li>
<li>调用ipc_mqueue_receive()从队列中取出消息</li>
<li>执行</li>
</ul>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>端口实际上就是一个整型的标识符，是如下结构（在osfmk/ipc/ipc_port.h中定义）的一个句柄：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initial sub-structure in common with ipc_pset</span></span><br><span class="line"><span class="comment">	 * First element is an ipc_object second is a</span></span><br><span class="line"><span class="comment">	 * message queue</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> <span class="title">ip_object</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_mqueue</span> <span class="title">ip_messages</span>;</span></span><br><span class="line">	<span class="type">natural_t</span> ip_sprequests:<span class="number">1</span>,	<span class="comment">/* send-possible requests outstanding */</span></span><br><span class="line">		  ip_spimportant:<span class="number">1</span>,	<span class="comment">/* ... at least one is importance donating */</span></span><br><span class="line">		  ip_impdonation:<span class="number">1</span>,	<span class="comment">/* port supports importance donation */</span></span><br><span class="line">		  ip_tempowner:<span class="number">1</span>,	<span class="comment">/* dont give donations to current receiver */</span></span><br><span class="line">		  ip_guarded:<span class="number">1</span>,         <span class="comment">/* port guarded (use context value as guard) */</span></span><br><span class="line">		  ip_strict_guard:<span class="number">1</span>,	<span class="comment">/* Strict guarding; Prevents user manipulation of context values directly */</span></span><br><span class="line">		  ip_reserved:<span class="number">2</span>,</span><br><span class="line">		  ip_impcount:<span class="number">24</span>;	<span class="comment">/* number of importance donations in nested queue */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> *<span class="title">receiver</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">destination</span>;</span></span><br><span class="line">		<span class="type">ipc_port_timestamp_t</span> timestamp;</span><br><span class="line">	&#125; data;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">ipc_kobject_t</span> kobject;</span><br><span class="line">		<span class="type">ipc_importance_task_t</span> imp_task;</span><br><span class="line">		<span class="type">uintptr_t</span> alias;</span><br><span class="line">	&#125; kdata;</span><br><span class="line">		</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">ip_nsrequest</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">ip_pdrequest</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port_request</span> *<span class="title">ip_requests</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_kmsg</span> *<span class="title">ip_premsg</span>;</span></span><br><span class="line">	<span class="type">mach_vm_address_t</span> ip_context;</span><br><span class="line">	<span class="type">mach_port_mscount_t</span> ip_mscount;</span><br><span class="line">	<span class="type">mach_port_rights_t</span> ip_srights;</span><br><span class="line">	<span class="type">mach_port_rights_t</span> ip_sorights;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	MACH_ASSERT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IP_NSPARES		4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IP_CALLSTACK_MAX	16</span></span><br><span class="line"><span class="comment">/*	queue_chain_t	ip_port_links;*/</span><span class="comment">/* all allocated ports */</span></span><br><span class="line">	<span class="type">thread_t</span>	ip_thread;	<span class="comment">/* who made me?  thread context */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	ip_timetrack;	<span class="comment">/* give an idea of &quot;when&quot; created */</span></span><br><span class="line">	<span class="type">uintptr_t</span>	ip_callstack[IP_CALLSTACK_MAX]; <span class="comment">/* stack trace */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	ip_spares[IP_NSPARES]; <span class="comment">/* for debugging */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* MACH_ASSERT */</span></span></span><br><span class="line">&#125; __attribute__((__packed__));</span><br></pre></td></tr></table></figure>

<h3 id="Mach接口生成器-MIG"><a href="#Mach接口生成器-MIG" class="headerlink" title="Mach接口生成器 MIG"></a>Mach接口生成器 MIG</h3><p>Mach消息传递模型是远程调用（Remote Procedure Call，RPC）的一种现实(类似Thrift)。在/usr/include/mach目录下可以看到一些.defs文件，这些文件包含了Mach子系统（一组操作）的定义。操作类型如下：</p>
<img src="/images/iOS/mig_opt.png" class="">

<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><ul>
<li>Mach的每个Task都包含一个指针，这个指针指向一个IPC命名空间，这个IPC命名空间了包含了Task的端口，当然Task还可以获取系统范围的端口，例如：主机端口、特权端口（可以重启机器等）等。</li>
<li>在用户态下，消息传递都是通过mach_msg()函数实现的，这个函数会触发一个mach陷阱mach_msg_trap()，接下来mach_msg_trap()又会调用mach_msg_overwrite_trap()，它会通过MACH_SEND_MSG和MACH_RCV_MSG来判断是发送操作，还是接收操作。</li>
<li>期中内核态中还可以通过mach_msg_receive()和mach_msg_send()来收发数据。</li>
</ul>
<h2 id="主机、时钟、处理器、处理器集"><a href="#主机、时钟、处理器、处理器集" class="headerlink" title="主机、时钟、处理器、处理器集"></a>主机、时钟、处理器、处理器集</h2><h3 id="主机对象-Host"><a href="#主机对象-Host" class="headerlink" title="主机对象 Host"></a>主机对象 Host</h3><p>主机就是一组“特殊”端口的集合，以及一组异常处理程序的集合，同时定义了一个锁用于保护异常处理的并发访问。结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>	<span class="title">host</span> &#123;</span></span><br><span class="line">	decl_lck_mtx_data(,lock)		<span class="comment">/* lock to protect exceptions */</span></span><br><span class="line">	<span class="type">ipc_port_t</span> special[HOST_MAX_SPECIAL_PORT + <span class="number">1</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">exception_action</span> <span class="title">exc_actions</span>[<span class="title">EXC_TYPES_COUNT</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="时钟对象（Clock）"><a href="#时钟对象（Clock）" class="headerlink" title="时钟对象（Clock）"></a>时钟对象（Clock）</h3><p>Mach内核提供了一个简单的“时钟”对象（在osfmk/kern/clock.h中定义）的抽象，这个对象用于计时和闹铃，期中最重要的内部API是clock_deadline_for_periodic_event（），调度器通过它设置了一个重复发生的通知–从而保证了多任务引擎的运转。</p>
<h3 id="处理器对象（Processer）"><a href="#处理器对象（Processer）" class="headerlink" title="处理器对象（Processer）"></a>处理器对象（Processer）</h3><p>在多核架构中每一个核心都可以看做是一个CPU，处理器被分配给处理器集，处理器是CPU的简单抽象，被Mach用于一些基本的操作，比如：启动和关闭一个CPU，向CPU分发要执行的线程。结构的定义（在osfmk/kern/processor.h）如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">processor</span> &#123;</span></span><br><span class="line">	<span class="type">queue_chain_t</span>		processor_queue;<span class="comment">/* idle/active queue link,</span></span><br><span class="line"><span class="comment">										 * MUST remain the first element */</span></span><br><span class="line">	<span class="type">int</span>					state;			<span class="comment">/* See below */</span></span><br><span class="line">	<span class="type">boolean_t</span>		is_SMT;</span><br><span class="line">	<span class="type">boolean_t</span>		is_recommended;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">thread</span></span></span><br><span class="line"><span class="class">						*<span class="title">active_thread</span>,	/* <span class="title">thread</span> <span class="title">running</span> <span class="title">on</span> <span class="title">processor</span> */</span></span><br><span class="line"><span class="class">						*<span class="title">next_thread</span>,	/* <span class="title">next</span> <span class="title">thread</span> <span class="title">when</span> <span class="title">dispatched</span> */</span></span><br><span class="line"><span class="class">						*<span class="title">idle_thread</span>;</span>	<span class="comment">/* this processor&#x27;s idle thread. */</span></span><br><span class="line">	<span class="type">processor_set_t</span>		processor_set;	<span class="comment">/* assigned set */</span></span><br><span class="line">	<span class="type">int</span>					current_pri;	<span class="comment">/* priority of current thread */</span></span><br><span class="line">	<span class="type">sched_mode_t</span>		current_thmode;	<span class="comment">/* sched mode of current thread */</span></span><br><span class="line">	<span class="type">sfi_class_id_t</span>		current_sfi_class;	<span class="comment">/* SFI class of current thread */</span></span><br><span class="line">	<span class="type">int</span>					cpu_id;			<span class="comment">/* platform numeric id */</span></span><br><span class="line">	<span class="type">timer_call_data_t</span>	quantum_timer;	<span class="comment">/* timer for quantum expiration */</span></span><br><span class="line">	<span class="type">uint64_t</span>			quantum_end;	<span class="comment">/* time when current quantum ends */</span></span><br><span class="line">	<span class="type">uint64_t</span>			last_dispatch;	<span class="comment">/* time of last dispatch */</span></span><br><span class="line">	<span class="type">uint64_t</span>			deadline;		<span class="comment">/* current deadline */</span></span><br><span class="line">	<span class="type">boolean_t</span>               first_timeslice;                <span class="comment">/* has the quantum expired since context switch */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span>	<span class="title">runq</span>;</span>			<span class="comment">/* runq for this processor */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SCHED_TRADITIONAL)</span></span><br><span class="line">	<span class="type">int</span>					runq_bound_count; <span class="comment">/* # of threads bound to this processor */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SCHED_GRRR)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">grrr_run_queue</span>	<span class="title">grrr_runq</span>;</span>      <span class="comment">/* Group Ratio Round-Robin runq */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">processor_t</span>			processor_primary;	<span class="comment">/* pointer to primary processor for</span></span><br><span class="line"><span class="comment">											 * secondary SMT processors, or a pointer</span></span><br><span class="line"><span class="comment">											 * to ourselves for primaries or non-SMT */</span></span><br><span class="line">	<span class="type">processor_t</span>		processor_secondary;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *	<span class="title">processor_self</span>;</span>	<span class="comment">/* port for operations */</span></span><br><span class="line">	<span class="type">processor_t</span>			processor_list;	<span class="comment">/* all existing processors */</span></span><br><span class="line">	<span class="type">processor_data_t</span>	processor_data;	<span class="comment">/* per-processor data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中最重要的是runq，这是分发到这个处理器的线程队列。</p>
<h3 id="处理器集"><a href="#处理器集" class="headerlink" title="处理器集"></a>处理器集</h3><p>处理器集就是一个或多个processor_t的分组，也被称为pset。pset通常维护三个队列：</p>
<p>active_queue：用于保存当前正在执行线程的CPU。<br>idle_queue：用于保存当前空闲的CPU（例如：正在执行idle_thread）。<br>pset_runq：保存了在这个集合中的所有CPU上执行的线程。<br>processor_set的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">processor_set</span> &#123;</span></span><br><span class="line">	<span class="type">queue_head_t</span>		active_queue;	<span class="comment">/* active processors */</span></span><br><span class="line">	<span class="type">queue_head_t</span>		idle_queue;		<span class="comment">/* idle processors */</span></span><br><span class="line">	<span class="type">queue_head_t</span>		idle_secondary_queue;		<span class="comment">/* idle secondary processors */</span></span><br><span class="line">	<span class="type">int</span>					online_processor_count;</span><br><span class="line">	<span class="type">int</span>					cpu_set_low, cpu_set_hi;</span><br><span class="line">	<span class="type">int</span>					cpu_set_count;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __SMP__</span></span><br><span class="line">	decl_simple_lock_data(,sched_lock)	<span class="comment">/* lock for above */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SCHED_TRADITIONAL) || defined(CONFIG_SCHED_MULTIQ)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">run_queue</span>	<span class="title">pset_runq</span>;</span>      <span class="comment">/* runq for this processor set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SCHED_TRADITIONAL)</span></span><br><span class="line">	<span class="type">int</span>					pset_runq_bound_count;</span><br><span class="line">		<span class="comment">/* # of threads in runq bound to any processor in pset */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* CPUs that have been sent an unacknowledged remote AST for scheduling purposes */</span></span><br><span class="line">	<span class="type">uint64_t</span>			pending_AST_cpu_mask;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SCHED_DEFERRED_AST)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A seperate mask, for ASTs that we may be able to cancel.  This is dependent on</span></span><br><span class="line"><span class="comment">	 * some level of support for requesting an AST on a processor, and then quashing</span></span><br><span class="line"><span class="comment">	 * that request later.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The purpose of this field (and the associated codepaths) is to infer when we</span></span><br><span class="line"><span class="comment">	 * no longer need a processor that is DISPATCHING to come up, and to prevent it</span></span><br><span class="line"><span class="comment">	 * from coming out of IDLE if possible.  This should serve to decrease the number</span></span><br><span class="line"><span class="comment">	 * of spurious ASTs in the system, and let processors spend longer periods in</span></span><br><span class="line"><span class="comment">	 * IDLE.</span></span><br><span class="line"><span class="comment">	 *\/</span></span><br><span class="line"><span class="comment">	uint64_t			pending_deferred_AST_cpu_mask;</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">	struct ipc_port	*	pset_self;		/* port for operations */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *	<span class="title">pset_name_self</span>;</span>	<span class="comment">/* port for information */</span></span><br><span class="line">	<span class="type">processor_set_t</span>		pset_list;		<span class="comment">/* chain of associated psets */</span></span><br><span class="line">	<span class="type">pset_node_t</span>			node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>iOS</category>
        <category>Mach内核</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>系统架构</tag>
        <tag>Mach内核</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果内核架构</title>
    <url>/iOS/kernelarchitecture/overview.html</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0Rhcndpbi9Db25jZXB0dWFsL0tlcm5lbFByb2dyYW1taW5nL0FyY2hpdGVjdHVyZS9BcmNoaXRlY3R1cmUuaHRtbA==">官方文档地址<i class="fa fa-external-link-alt"></i></span> </p>
<h1 id="OS-X简介"><a href="#OS-X简介" class="headerlink" title="OS X简介"></a>OS X简介</h1><p>OS X为Macintosh用户和开发人员社区提供了许多好处。这些优点包括改进的可靠性和性能、增强的网络特性、基于对象的系统编程接口以及对行业标准的更多支持。</p>
<p>在创建OS X的过程中，苹果彻底改造了Mac OS核心操作系统。形成OS X的基础是内核。下图说明了OS X体系结构。</p>
<img src="/images/iOS/osxlayers.png" class="" title="osxlayers">

<p>内核为OS x提供了许多增强功能，包括抢占、内存保护、增强的性能、改进的网络设施、对Macintosh(扩展版和标准版)和非Macintosh (UFS、ISO 9660等等)文件系统的支持、面向对象的api等等。其中两个特性，抢占和内存保护，导致了更健壮的环境。</p>
<p>在Mac OS 9中，应用程序协作共享处理器时间。类似地，所有应用程序之间共享计算机的内存。Mac OS 9是一个协作的多任务环境。如果一个应用程序不合作，那么所有进程的响应性都会受到影响。另一方面，实时应用程序(如多媒体)需要保证具有可预测的、时间关键的行为。</p>
<p>相比之下，OS X是一个先发制人的多任务环境。在OS X中，内核提供了强制合作，调度进程来共享时间(抢占)。这支持需要实时行为的应用程序。</p>
<p>在OS X中，进程通常不共享内存。相反，内核为每个进程分配自己的地址空间，控制对这些地址空间的访问。此控件确保任何应用程序都不能无意中访问或修改另一个应用程序的内存(保护)。规模不是问题;由于OS X包含了虚拟内存系统，每个应用程序都可以访问自己的4 GB地址空间。</p>
<p>从整体上看，所有应用程序都在用户空间中运行，但这并不意味着它们共享内存。用户空间只是所有用户级应用程序的组合地址空间的术语。内核本身有它自己的地址空间，称为内核空间。在OS X中，没有应用程序可以直接修改系统软件(内核)的内存。</p>
<p>虽然默认情况下用户进程不像Mac OS 9那样共享内存，但应用程序之间的通信(甚至内存共享)仍然是可能的。例如，内核提供了一组丰富的原语，允许进程之间共享一些信息。这些基本类型包括共享库、框架和POSIX共享内存。<code>Mach消息传递提供了另一种方法，将内存从一个进程传递到另一个进程。</code>然而，与Mac OS 9不同的是，如果没有程序员的显式操作，内存共享就无法实现。</p>
<h1 id="达尔文操作系统"><a href="#达尔文操作系统" class="headerlink" title="达尔文操作系统"></a>达尔文操作系统</h1><p><code>OS X内核是一个开源项目</code>。内核以及OS X的其他核心部分<code>统称为Darwin</code>。Darwin是一个完整的操作系统，基于与OS x相同的许多技术。但是，Darwin不包括Apple专有的图形或应用程序层，比如Quartz、QuickTime、Cocoa、Carbon或OpenGL。</p>
<p>下图显示了Darwin和OS X之间的关系，它们都构建在相同的内核之上，但是OS X添加了核心服务、应用程序服务和QuickTime，以及经典的Carbon、Cocoa和Java (JDK)应用程序环境。Darwin和OS X都包含BSD命令行应用程序环境;然而，在OS X中，不需要使用环境，因此它对用户是隐藏的，除非用户选择访问它。</p>
<img src="/images/iOS/darwinlayers.png" class="" title="darwinlayers">

<p>Darwin技术基于BSD、Mach 3.0和苹果技术。最重要的是，<code>Darwin技术是开源技术</code>，这意味着开发人员可以完全访问源代码。实际上，OS X第三方开发人员可以成为Darwin核心系统软件开发团队的一部分。开发人员还可以看到苹果在核心操作系统中是如何工作的，并在自己的产品中采用(或调整)代码。有关详细信息，请参阅Apple公共源许可证(APSL)。</p>
<p>因为相同的软件构成了OS X和Darwin的核心，所以开发人员可以创建在OS X和Darwin上运行的底层软件，而<code>几乎不需要进行任何更改</code>。唯一的区别可能是软件与应用程序环境的交互方式。</p>
<p>达尔文是基于许多来源的成熟技术。这项技术的很大一部分来自FreeBSD，这是4.4BSD的一个版本，提供了先进的网络、性能、安全和兼容性特性。该系统软件的其他部分，如Mach，基于苹果MkLinux项目、OS X服务器以及NeXT收购的技术。大部分代码与平台无关。所有核心操作系统代码都以源代码的形式提供。</p>
<p>选择核心技术有几个原因。<code>Mach提供了一组干净的抽象，用于处理内存管理、进程间(和处理器间)通信(IPC)和其他低级操作系统功能。</code>在当今快速变化的硬件环境中，这在操作系统和底层硬件之间提供了一个有用的隔离层。</p>
<p>BSD是一个精心设计的成熟操作系统，具有许多功能。事实上，当今大多数商业UNIX和类UNIX操作系统都包含大量BSD代码。BSD还提供了一组行业标准api。</p>
<p>新技术，如I/O工具包和网络内核扩展(NKEs)，都是由苹果公司设计和设计的，以利用先进的功能，如面向对象编程模型提供的功能。OS X将这些新技术与经过时间检验的行业标准结合起来，创建了一个稳定、可靠、灵活和可扩展的操作系统。</p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>Darwin和OS X的基础层由几个体系结构组件组成，如下图所示。这些组件合在一起构成内核环境。</p>
<img src="/images/iOS/osxarchitecture.png" class="" title="osxarchitecture">
<blockquote>
<p>重要提示:注意OS X使用术语内核的方式与您可能期望的有所不同。</p>
</blockquote>
<p>在传统的操作系统术语中，内核是一个很小的软件核心，它只提供实现附加操作系统服务所需的最小设施。——摘自《4.4 BSD操作系统的设计与实现》，McKusick, Bostic, Karels和Quarterman, 1996。</p>
<p>类似地，在传统的基于Mach的操作系统中，内核指的是Mach微内核，忽略了额外的底层代码，没有这些底层代码，Mach几乎做不了什么。</p>
<p>然而，在OS X中，内核环境包含的内容比Mach内核本身多得多。<code>OS X内核环境包括Mach内核、BSD、I/O工具包、文件系统和网络组件。这些通常统称为内核</code>。下面几节将简要描述这些组件。有关进一步的详细信息，请参阅具体的组成部分章节或参考书目中列出的参考资料。</p>
<p>因为OS X包含三个基本组件(<code>Mach、BSD和I/O工具包</code>)，所以对于某些关键操作，常常有多达三个api。一般来说，所选择的API应该与正在使用它的内核部分匹配，而内核部分又由您的代码试图执行的操作决定。本章的其余部分将介绍Mach、BSD和I/O工具包，并概述这些组件提供的功能。</p>
<h2 id="Mach"><a href="#Mach" class="headerlink" title="Mach"></a>Mach</h2><p>Mach管理CPU使用情况和内存等处理器资源，处理调度，提供内存保护，并为其他操作系统层提供以消息为中心的基础设施。</p>
<p>参看我的另外一篇<a href="./iOS/kernelarchitecture/mach.html">Mach概览一章</a></p>
<p>Mach组件提供</p>
<ul>
<li>无类型进程间通信(IPC)</li>
<li>远程过程调用(RPC)</li>
<li>对称多处理(SMP)的调度程序支持</li>
<li>对实时服务的支持</li>
<li>虚拟内存支持</li>
<li>支持寻呼机</li>
<li>模块化的体系结构</li>
</ul>
<p>有关Mach的一般信息可以在<a href="./iOS/kernelarchitecture/mach.html">Mach概览一章</a>中找到。有关调度的信息可以在<code>Mach调度和线程接口</code>一章中找到。有关VM系统的信息可以在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0Rhcndpbi9Db25jZXB0dWFsL0tlcm5lbFByb2dyYW1taW5nL3ZtL3ZtLmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDMwMDAwOTA1LUNIMjEwLUJFSEpERkNB">内存和虚拟内存<i class="fa fa-external-link-alt"></i></span>中找到。</p>
<h2 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h2><p>在Mach层之上，BSD层提供“OS personality”api和服务。BSD层基于BSD内核，主要是FreeBSD。BSD组件提供</p>
<ul>
<li>文件系统</li>
<li>联网(硬件设备级除外)</li>
<li>UNIX的安全模型</li>
<li>系统调用的支持</li>
<li>BSD过程模型，包括过程id和信号</li>
<li>FreeBSD内核api</li>
<li>许多POSIX api</li>
<li>对pthreads (POSIX线程)的内核支持</li>
</ul>
<p>BSD组件在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0Rhcndpbi9Db25jZXB0dWFsL0tlcm5lbFByb2dyYW1taW5nL0JTRC9CU0QuaHRtbCMvL2FwcGxlX3JlZi9kb2MvdWlkL1RQMzAwMDA5MDUtQ0gyMTQtVFBYUkVGMTAx">BSD概述一章<i class="fa fa-external-link-alt"></i></span>中有更详细的描述。</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>OS X网络利用BSD的高级网络功能来提供对现代特性的支持，比如网络地址转换(NAT)和防火墙。网络组件提供</p>
<ul>
<li>4.4BSD TCP/IP栈和套接字api</li>
<li>同时支持IP和DDP (AppleTalk传输)</li>
<li>multihoming</li>
<li>路由</li>
<li>多播支持</li>
<li>服务器调优</li>
<li>信息包过滤</li>
<li>Mac OS经典支持(通过过滤器)</li>
</ul>
<p>有关网络的更多信息可以在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0Rhcndpbi9Db25jZXB0dWFsL0tlcm5lbFByb2dyYW1taW5nL05ldHdvcmtpbmcvTmV0d29ya2luZy5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFAzMDAwMDkwNS1DSDIxNi1CQUJIQ0hGQw==">网络体系结构一章<i class="fa fa-external-link-alt"></i></span>中找到。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>OS X支持多种类型的文件系统，包括HFS、HFS+、UFS、NFS、ISO 9660等。默认的文件系统类型是HFS+;OS X引导(和“根”)来自HFS+、UFS、ISO、NFS和UDF。OS X文件系统的高级功能包括一个增强的虚拟文件系统(VFS)设计。VFS提供了分层的体系结构(文件系统是可堆叠的)。文件系统组件提供</p>
<ul>
<li>utf - 8 (Unicode)支持</li>
<li>与以前版本的Mac OS相比，性能有所提高。</li>
</ul>
<p>更多信息可以在章节<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0Rhcndpbi9Db25jZXB0dWFsL0tlcm5lbFByb2dyYW1taW5nL0ZpbGVzeXN0ZW0vRmlsZXN5c3RlbS5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFAzMDAwMDkwNS1DSDIxNS1CQUJFRUhGRg==">文件系统概述<i class="fa fa-external-link-alt"></i></span>中找到。</p>
<h2 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I / O设备"></a>I / O设备</h2><p>I/O工具包为简化驱动程序开发提供了一个框架，支持多种类型的设备。I/O工具包提供了一个面向对象的I/O体系结构，该体系结构在c++的一个受限子集中实现。I/O工具包框架是模块化和可扩展的。I/O工具包组件提供</p>
<ul>
<li>真正的即插即用</li>
<li>动态设备管理</li>
<li>动态(按需)加载驱动程序</li>
<li>桌面系统和便携式设备的电源管理</li>
<li>多处理器能力</li>
</ul>
<p>I/O工具包在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0Rhcndpbi9Db25jZXB0dWFsL0tlcm5lbFByb2dyYW1taW5nL0lPS2l0L0lPS2l0Lmh0bWwjLy9hcHBsZV9yZWYvZG9jL3VpZC9UUDMwMDAwOTA1LUNIMjEzLUJFSEpERkNB">I/O工具包概述一章<i class="fa fa-external-link-alt"></i></span>中有更详细的描述。</p>
<h1 id="内核扩展"><a href="#内核扩展" class="headerlink" title="内核扩展"></a>内核扩展</h1><p>OS X提供了一种内核扩展机制，作为一种允许将代码片段动态加载到内核空间的方法，而不需要重新编译。这些代码通常称为插件<code>plug-ins</code>，或者在OS X内核环境中称为<code>kernel extensions</code>或<code>KEXTs</code>。</p>
<p>因为<code>KEXTs</code>同时提供模块化和动态可加载性，所以对于需要访问不导出到用户空间的接口的任何相对自包含的服务，KEXTs都是一个自然的选择。内核环境的许多组件都支持这种扩展机制，尽管它们以不同的方式支持。</p>
<p>例如，一些新的网络特性涉及到使用网络内核扩展(NKEs)。这些将在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0Rhcndpbi9Db25jZXB0dWFsL0tlcm5lbFByb2dyYW1taW5nL05ldHdvcmtpbmcvTmV0d29ya2luZy5odG1sIy8vYXBwbGVfcmVmL2RvYy91aWQvVFAzMDAwMDkwNS1DSDIxNi1CQUJIQ0hGQw==">网络体系结构一章<i class="fa fa-external-link-alt"></i></span>讨论。</p>
<p>动态添加新文件系统实现的能力基于VFS KEXTs, I/O工具包中的设备驱动程序和设备族使用KEXTs实现。对于编写驱动程序或编写代码以支持新的卷格式或网络协议的开发人员来说，KEXTs使开发变得更加容易。在<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0Rhcndpbi9Db25jZXB0dWFsL0tlcm5lbFByb2dyYW1taW5nL0V4dGVuZC9FeHRlbmQuaHRtbCMvL2FwcGxlX3JlZi9kb2MvdWlkL1RQMzAwMDA5MDUtQ0gyMjAtQkVCREdGSEk=">内核扩展概述一章<i class="fa fa-external-link-alt"></i></span>中将更详细地讨论KEXTs。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>苹果内核架构</category>
      </categories>
      <tags>
        <tag>系统架构</tag>
        <tag>苹果内核架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Mach微内核简介</title>
    <url>/iOS/kernelarchitecture/xnu.html</url>
    <content><![CDATA[<h1 id="XNU-怎么加载-App"><a href="#XNU-怎么加载-App" class="headerlink" title="XNU 怎么加载 App?"></a>XNU 怎么加载 App?</h1><p>iOS 的可执行文件和动态库都是 Mach-O 格式，所以加载 APP 实际上就是加载 Mach-O 文件。<br>Mach-O header 信息结构代码如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> mach_header_64 &#123;</span><br><span class="line">    uint32_t        magic;          <span class="comment">//64位还是32位</span></span><br><span class="line">    cpu_type_t      cputype;        <span class="comment">//CPU 类型，比如 arm 或 X86</span></span><br><span class="line">    cpu_subtype_t   cpusubtype;     <span class="comment">//CPU 子类型，比如 armv8</span></span><br><span class="line">    uint32_t        filetype;       <span class="comment">// 文件类型</span></span><br><span class="line">    uint32_t        ncmds;          <span class="comment">// load commands 的数量</span></span><br><span class="line">    uint32_t        sizeofcmds;     <span class="comment">// load commands 大小</span></span><br><span class="line">    uint32_t        flags;          <span class="comment">// 标签</span></span><br><span class="line">    uint32_t        reserved;       <span class="comment">// 保留字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，文件类型 filetype 表示了当前 Mach-O 属于哪种类型。Mach-O 包括以下几种类型。</p>
<ul>
<li>OBJECT，指的是 .o 文件或者 .a 文件;</li>
<li>EXECUTE，指的是IPA 拆包后的文件;</li>
<li>DYLIB，指的是 .dylib 或 .framework 文件; </li>
<li>DYLINKER，指的是动态链接器; </li>
<li>DSYM，指的是保存有符号信息用于分析闪退信息的文件。</li>
</ul>
<p>加载 Mach-O 文件，内核会 fork 进程，并对进程进行一些基本设置，比如为进程分配虚拟内存、为进程创 建主线程、代码签名等。用户态 dyld 会对 Mach-O 文件做库加载和符号解析。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>XNU:App如何加载</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>系统架构</tag>
        <tag>XNU:App如何加载</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/iOS/multithreading/index.html</url>
    <content><![CDATA[<h1 id="置顶"><a href="#置顶" class="headerlink" title="置顶"></a>置顶</h1><h2 id="NSOperation的小tip"><a href="#NSOperation的小tip" class="headerlink" title="NSOperation的小tip"></a>NSOperation的小tip</h2><p>在ios4以前，只有非并发的情况下，队列会为operation开启一个线程来执行。如果是并发的情况，operation需要自己创建一个线程来执行。所以说，NSoperation的并发和非并发不是传统意义上的串行和并行。<br>但是在ios4以后，不管是并发还是非并发，队列都会为operation提供一个线程来执行。所以isConcurrent这个变量也就没有用处了。<br>但是，这里还设涉及到了两个方法，start和main.<br>按照官方文档所说，如果是非并发就使用main，并发就使用start。</p>
<p>那现在并发和非并发已经没有区别了，start和main的区别在哪里呢？</p>
<p>main方法的话，如果main方法执行完毕，那么整个operation就会从队列中被移除。如果你是一个自定义的operation并且它是某些类的代理，这些类恰好有异步方法，这是就会找不到代理导致程序出错了。<br>然而start方法就算执行完毕，它的finish属性也不会变，因此你可以控制这个operation的生命周期了。<br>然后在任务完成之后手动cancel掉这个operation即可。</p>
<blockquote>
<p>说句简单的，   main不需要自己管理状态，op会自己移出。  start需要自己管理op，包括状态。<br>参看SDWebImage的实现，多阅读源码，有助于理解。</p>
</blockquote>
<h1 id="简介，下面有GCD-源码解析"><a href="#简介，下面有GCD-源码解析" class="headerlink" title="简介，下面有GCD 源码解析,"></a>简介，下面有GCD 源码解析,</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul>
<li>1.进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元.</li>
<li>2.进程是指在系统中正在运行的一个应用程序，就是一段程序的执行过程,我们可以理解为手机上的一个app.</li>
<li>3.每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>1.程序执行流的最小单元，线程是进程中的一个实体.</li>
<li>2.一个进程要想执行任务,必须至少有一条线程.应用程序启动的时候，系统会默认开启一条线程,也就是主线程<span id="more"></span> </li>
</ul>
<h2 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h2><ul>
<li>1.线程是进程的执行单元，进程的所有任务都在线程中执行</li>
<li>2.线程是 CPU 分配资源和调度的最小单位</li>
<li>3.一个程序可以对应多个进程(多进程),一个进程中可有多个线程,但至少要有一条线程</li>
<li>4.同一个进程内的线程共享进程资源<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2>打开mac的活动监视器，可以看到很多个进程同时运行</li>
<li>进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的(静态的)，进程是活的(动态的)。</li>
<li>进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身;所有由用户启动的进程都是用户进程。进程是操作系统进行资源分配的单位。</li>
<li>进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多进程。</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li>同一时间，CPU只能处理1条线程，只有1条线程在执行。多线程并发执行，其实是CPU快速地在多条线程之间调度（切换）。如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象</li>
<li>如果线程非常非常多，CPU会在N多线程之间调度，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）</li>
<li>多线程的优点:<br>能适当提高程序的执行效率<br>能适当提高资源利用率（CPU、内存利用率）</li>
<li>多线程的缺点:<br>开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能<br>线程越多，CPU在调度线程上的开销就越大<br>程序设计更加复杂：比如线程之间的通信、多线程的数据共享</li>
</ul>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>就是执行操作的意思，也就是在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：同步执行（sync）和异步执行（async）</p>
<ul>
<li>**同步(Sync)**：同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行，即会阻塞线程。只能在当前线程中执行任务(是当前线程，不一定是主线程)，不具备开启新线程的能力。</li>
<li>**异步(Async)**：线程会立即返回，无需等待就会继续执行下面的任务，不阻塞当前线程。可以在新的线程中执行任务，具备开启新线程的能力(并不一定开启新线程)。如果不是添加到主队列上，异步会在子线程中执行任务</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列（Dispatch Queue）：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务<br>在 GCD 中有两种队列：串行队列和并发队列。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。</p>
<ul>
<li>串行队列（Serial Dispatch Queue）：<br>同一时间内，队列中只能执行一个任务，只有当前的任务执行完成之后，才能执行下一个任务。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）。主队列是主线程上的一个串行队列,是系统自动为我们创建的</li>
<li>并发队列（Concurrent Dispatch Queue）：<br>同时允许多个任务并发执行。（可以开启多个线程，并且同时执行任务）。并发队列的并发功能只有在异步（dispatch_async）函数下才有效</li>
</ul>
<h2 id="iOS中的多线程"><a href="#iOS中的多线程" class="headerlink" title="iOS中的多线程"></a>iOS中的多线程</h2><p><strong>主要有三种：NSThread、NSoperationQueue、GCD</strong></p>
<h3 id="1、NSThread：轻量级别的多线程技术"><a href="#1、NSThread：轻量级别的多线程技术" class="headerlink" title="1、NSThread：轻量级别的多线程技术"></a><strong>1、NSThread：轻量级别的多线程技术</strong></h3><p>是我们自己手动开辟的子线程，如果使用的是初始化方式就需要我们自己启动，如果使用的是构造器方式它就会自动启动。只要是我们手动开辟的线程，都需要我们自己管理该线程，不只是启动，还有该线程使用完毕后的资源回收</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(testThread:) object:<span class="string">@&quot;我是参数&quot;</span>];</span><br><span class="line">  <span class="comment">// 当使用初始化方法出来的主线程需要start启动</span></span><br><span class="line">  [thread start];</span><br><span class="line">  <span class="comment">// 可以为开辟的子线程起名字</span></span><br><span class="line">  thread.name = <span class="string">@&quot;NSThread线程&quot;</span>;</span><br><span class="line">  <span class="comment">// 调整Thread的权限 线程权限的范围值为0 ~ 1 。越大权限越高，先执行的概率就会越高，由于是概率，所以并不能很准确的的实现我们想要的执行顺序，默认值是0.5</span></span><br><span class="line">  thread.threadPriority = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 取消当前已经启动的线程</span></span><br><span class="line">  [thread cancel];</span><br><span class="line">  <span class="comment">// 通过遍历构造器开辟子线程</span></span><br><span class="line">  [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(testThread:) toTarget:<span class="keyword">self</span> withObject:<span class="string">@&quot;构造器方式&quot;</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>performSelector…只要是NSObject的子类或者对象都可以通过调用方法进入子线程和主线程，其实这些方法所开辟的子线程也是NSThread的另一种体现方式。<br>在编译阶段并不会去检查方法是否有效存在，如果不存在只会给出警告<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在当前线程。延迟1s执行。响应了OC语言的动态性:延迟到运行时才绑定方法</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(aaa) withObject:<span class="literal">nil</span> afterDelay:<span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 回到主线程。waitUntilDone:是否将该回调方法执行完在执行后面的代码，如果为YES:就必须等回调方法执行完成之后才能执行后面的代码，说白了就是阻塞当前的线程；如果是NO：就是不等回调方法结束，不会阻塞当前线程</span></span><br><span class="line">    [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(aaa) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">  <span class="comment">//开辟子线程</span></span><br><span class="line">    [<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(aaa) withObject:<span class="literal">nil</span>];</span><br><span class="line">  <span class="comment">//在指定线程执行</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(aaa) onThread:[<span class="built_in">NSThread</span> currentThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>]</span><br></pre></td></tr></table></figure>
需要注意的是：如果是带afterDelay的延时函数，会在内部创建一个 NSTimer，然后添加到当前线程的Runloop中。也就是如果当前线程没有开启runloop，该方法会失效。在子线程中，需要启动runloop(注意调用顺序)<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(aaa) withObject:<span class="literal">nil</span> afterDelay:<span class="number">1</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br></pre></td></tr></table></figure>
而performSelector:withObject:只是一个单纯的消息发送，和时间没有一点关系。所以不需要添加到子线程的Runloop中也能执行<h3 id="2、GCD-对比-NSOprationQueue"><a href="#2、GCD-对比-NSOprationQueue" class="headerlink" title="2、GCD 对比 NSOprationQueue"></a><strong>2、GCD 对比 NSOprationQueue</strong></h3>我们要明确NSOperationQueue与GCD之间的关系<br>GCD是面向底层的C语言的API，NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象。<br>1、GCD执行效率更高，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便<br>2、GCD只支持FIFO的队列，而NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序<br>3、NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂<br>4、NSOperationQueue因为面向对象，所以支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）</li>
<li>实际项目开发中，很多时候只是会用到异步操作，不会有特别复杂的线程关系管理，所以苹果推崇的且优化完善、运行快速的GCD是首选</li>
<li>如果考虑异步操作之间的事务性，顺序行，依赖关系，比如多线程并发下载，GCD需要自己写更多的代码来实现，而NSOperationQueue已经内建了这些支持</li>
<li>不论是GCD还是NSOperationQueue，我们接触的都是任务和队列，都没有直接接触到线程，事实上线程管理也的确不需要我们操心，系统对于线程的创建，调度管理和释放都做得很好。而NSThread需要我们自己去管理线程的生命周期，还要考虑线程同步、加锁问题，造成一些性能上的开销</li>
</ul>
<h2 id="GCD—队列"><a href="#GCD—队列" class="headerlink" title="GCD—队列"></a>GCD—队列</h2><p>iOS中，有GCD、NSOperation、NSThread等几种多线程技术方案。<br>而GCD共有三种队列类型：<br>main queue：通过dispatch_get_main_queue()获得，这是一个与主线程相关的串行队列。</p>
<p>global queue：全局队列是并发队列，由整个进程共享。存在着高、中、低三种优先级的全局队列。调用dispath_get_global_queue并传入优先级来访问队列。</p>
<p>自定义队列：通过函数dispatch_queue_create创建的队列。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁就是队列引起的循环等待</p>
<p><strong>1、一个比较常见的死锁例子:主队列同步</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    <span class="selector-attr">[super viewDidLoad]</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">NSLog</span>(@&quot;deallock&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主线程中运用主队列同步，也就是把任务放到了主线程的队列中。<br>同步对于任务是立刻执行的，那么当把任务放进主队列时，它就会立马执行,只有执行完这个任务，viewDidLoad才会继续向下执行。<br>而viewDidLoad和任务都是在主队列上的，由于队列的先进先出原则，任务又需等待viewDidLoad执行完毕后才能继续执行，viewDidLoad和这个任务就形成了相互循环等待，就造成了死锁。<br>想避免这种死锁，可以将同步改成异步dispatch_async,或者将dispatch_get_main_queue换成其他串行或并行队列，都可以解决。</p>
<p><strong>2、同样，下边的代码也会造成死锁：</strong></p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(<span class="string">&quot;test&quot;</span>, DISPATCH_QUEUE_SERIAL)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async(<span class="name">serialQueue</span>, ^&#123;</span><br><span class="line">       </span><br><span class="line">        dispatch_sync(<span class="name">serialQueue</span>, ^&#123;</span><br><span class="line">            </span><br><span class="line">            NSLog(@<span class="string">&quot;deadlock&quot;</span>)<span class="comment">;</span></span><br><span class="line">        &#125;)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>外面的函数无论是同步还是异步都会造成死锁。<br>这是因为里面的任务和外面的任务都在同一个serialQueue队列内，又是同步，这就和上边主队列同步的例子一样造成了死锁<br>解决方法也和上边一样，将里面的同步改成异步dispatch_async,或者将serialQueue换成其他串行或并行队列，都可以解决</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t </span>serialQueue = <span class="keyword">dispatch_queue_create(&quot;test&quot;, </span><span class="keyword">DISPATCH_QUEUE_SERIAL);</span></span><br><span class="line"><span class="keyword"></span> </span><br><span class="line"> <span class="keyword">dispatch_queue_t </span>serialQueue2 = <span class="keyword">dispatch_queue_create(&quot;test&quot;, </span><span class="keyword">DISPATCH_QUEUE_SERIAL);</span></span><br><span class="line"><span class="keyword"></span> </span><br><span class="line"> <span class="keyword">dispatch_async(serialQueue, </span>^&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">dispatch_sync(serialQueue2, </span>^&#123;</span><br><span class="line">         </span><br><span class="line">         NSLog(@<span class="string">&quot;deadlock&quot;</span>);</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>这样是不会死锁的,并且serialQueue和serialQueue2是在同一个线程中的。</p>
<h2 id="GCD任务执行顺序"><a href="#GCD任务执行顺序" class="headerlink" title="GCD任务执行顺序"></a>GCD任务执行顺序</h2><p>1、串行队列 先异步后同步</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(<span class="string">&quot;test&quot;</span>, DISPATCH_QUEUE_SERIAL)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">NSLog(@<span class="string">&quot;1&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_async(<span class="name">serialQueue</span>, ^&#123;</span><br><span class="line">    </span><br><span class="line">     NSLog(@<span class="string">&quot;2&quot;</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">NSLog(@<span class="string">&quot;3&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">dispatch_sync(<span class="name">serialQueue</span>, ^&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@<span class="string">&quot;4&quot;</span>)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">NSLog(@<span class="string">&quot;5&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>打印顺序是13245<br>原因是:<br>首先先打印1<br>接下来将任务2其添加至串行队列上，由于任务2是异步，不会阻塞线程，继续向下执行，打印3<br>然后是任务4,将任务4添加至串行队列上，因为任务4和任务2在同一串行队列，根据队列先进先出原则，任务4必须等任务2执行后才能执行，又因为任务4是同步任务，会阻塞线程，只有执行完任务4才能继续向下执行打印5<br>所以最终顺序就是13245。<br>这里的任务4在主线程中执行，而任务2在子线程中执行。<br>如果任务4是添加到另一个串行队列或者并行队列，则任务2和任务4无序执行(可以添加多个任务看效果)</p>
<p><strong>2、performSelector</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">dispatch_async</span>(<span class="title function_ invoke__">dispatch_get_global_queue</span>(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        </span><br><span class="line">        [<span class="built_in">self</span> <span class="attr">performSelector</span>:@<span class="title function_ invoke__">selector</span>(<span class="attr">test</span>:) <span class="attr">withObject</span>:nil <span class="attr">afterDelay</span>:<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>这里的test方法是不会去执行的，原因在于</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(void)</span>performSelector:<span class="params">(SEL)</span>aSelector withObject:<span class="params">(nullable id)</span>anArgument afterDelay:<span class="params">(NSTimeInterval)</span>delay;</span><br></pre></td></tr></table></figure>

<p>这个方法要创建提交任务到runloop上的，而gcd底层创建的线程是默认没有开启对应runloop的，所有这个方法就会失效。<br>而如果将dispatch_get_global_queue改成主队列，由于主队列所在的主线程是默认开启了runloop的，就会去执行(将dispatch_async改成同步，因为同步是在当前线程执行，那么如果当前线程是主线程，test方法也是会去执行的)。</p>
<blockquote>
<p><a href="./iOS/RunLoop">详细请看RunLoop章节详解</a></p>
</blockquote>
<h2 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h2><p><strong>1、问：怎么用GCD实现多读单写？</strong><br>多读单写的意思就是：可以多个读者同时读取数据，而在读的时候，不能取写入数据。并且，在写的过程中，不能有其他写者去写。即读者之间是并发的，写者与读者或其他写者是互斥的。</p>
<p>这里的写处理就是通过栅栏的形式去写。<br>就可以用dispatch_barrier_sync(栅栏函数)去实现<br><strong>2、dispatch_barrier_sync的用法：</strong></p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">&quot;test&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%zd&quot;</span>,i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_barrier_sync(concurrentQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;barrier&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">10</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123; </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%zd&quot;</span>,i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的dispatch_barrier_sync上的队列要和需要阻塞的任务在同一队列上，否则是无效的。<br>从打印上看，任务2-6和任务任务7-13因为是异步并发的原因，彼此是无序的。而由于栅栏函数的存在，导致顺序必然是先执行任务2-6，再执行栅栏函数，再去执行任务7-13。</p>
<ul>
<li><p>dispatch_barrier_sync: Submits a barrier block object for execution and waits until that block completes.(提交一个栅栏函数在执行中,它会等待栅栏函数执行完)</p>
</li>
<li><p>dispatch_barrier_async: Submits a barrier block for asynchronous execution and returns immediately.(提交一个栅栏函数在异步执行中,它会立马返回)<br>而dispatch_barrier_sync和dispatch_barrier_async的区别也就在于会不会阻塞当前线程<br>比如，上述代码如果在dispatch_barrier_async后随便加一条打印，则会先去执行该打印，再去执行任务0-9和栅栏函数；而如果是dispatch_barrier_sync，则会在任务0-9和栅栏函数后去执行这条打印。</p>
</li>
</ul>
<p><strong>3、则可以这样设计多读单写：</strong></p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (id)readDataForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    __block id result;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_concurrentQueue, ^&#123;</span><br><span class="line">        result = [self valueForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)writeData:(id)data forKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_barrier_async</span>(_concurrentQueue, ^&#123;</span><br><span class="line">        [self setValue:data forKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dispatch-group-async"><a href="#dispatch-group-async" class="headerlink" title="dispatch_group_async"></a>dispatch_group_async</h2><p>场景：在n个耗时并发任务都完成后，再去执行接下来的任务。比如，在n个网络请求完成后去刷新UI页面。</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(<span class="string">&quot;test1&quot;</span>, DISPATCH_QUEUE_CONCURRENT)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    dispatch_group_t group = dispatch_group_create()<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    for (<span class="name">NSInteger</span> i = <span class="number">0</span><span class="comment">; i &lt; 10; i++) &#123;</span></span><br><span class="line">        </span><br><span class="line">        dispatch_group_async(<span class="name">group</span>, concurrentQueue, ^&#123;</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">            </span><br><span class="line">            NSLog(@<span class="string">&quot;%zd:网络请求&quot;</span>,i)<span class="comment">;</span></span><br><span class="line">        &#125;)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(<span class="name">group</span>, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@<span class="string">&quot;刷新页面&quot;</span>)<span class="comment">;</span></span><br><span class="line">    &#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="Dispatch-Semaphore"><a href="#Dispatch-Semaphore" class="headerlink" title="Dispatch Semaphore"></a>Dispatch Semaphore</h2><p>GCD 中的信号量是指 Dispatch Semaphore，是持有计数的信号。</p>
<p>Dispatch Semaphore 提供了三个函数</p>
<p><strong>1.dispatch_semaphore_create：创建一个Semaphore并初始化信号的总量</strong><br><strong>2.dispatch_semaphore_signal：发送一个信号，让信号总量加1</strong><br><strong>3.dispatch_semaphore_wait：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。</strong></p>
<p>Dispatch Semaphore 在实际开发中主要用于：</p>
<ul>
<li>保持线程同步，将异步执行任务转换为同步执行任务</li>
<li>保证线程安全，为线程加锁</li>
</ul>
<p><strong>1、保持线程同步：</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch<span class="constructor">_semaphore_create(0)</span>;</span><br><span class="line">    </span><br><span class="line">    __block NSInteger number = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    dispatch<span class="constructor">_async(<span class="params">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span>, ^&#123;</span><br><span class="line">        </span><br><span class="line">        number = <span class="number">100</span>;</span><br><span class="line">        </span><br><span class="line">        dispatch<span class="constructor">_semaphore_signal(<span class="params">semaphore</span>)</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch<span class="constructor">_semaphore_wait(<span class="params">semaphore</span>, DISPATCH_TIME_FOREVER)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="constructor">NSLog(@<span class="string">&quot;semaphore---end,number = %zd&quot;</span>,<span class="params">number</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>dispatch_semaphore_wait加锁阻塞了当前线程，dispatch_semaphore_signal解锁后当前线程继续执行</p>
<p><strong>2、保证线程安全，为线程加锁：</strong></p>
<p>在线程安全中可以将dispatch_semaphore_wait看作加锁，而dispatch_semaphore_signal看作解锁<br>首先创建全局变量</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">_semaphore</span> = dispatch_semaphore_create(<span class="number">1</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>注意到这里的初始化信号量是1。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)asyncTask</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_semaphore_wait</span>(_semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">    count++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(@&quot;执行任务:%zd&quot;,count);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_semaphore_signal</span>(_semaphore);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步并发调用asyncTask</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">for (NSInteger i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">          </span><br><span class="line">          <span class="selector-attr">[self asyncTask]</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后发现打印是从任务1顺序执行到100，没有发生两个任务同时执行的情况。</p>
<p>原因如下:<br>在子线程中并发执行asyncTask，那么第一个添加到并发队列里的，会将信号量减1，此时信号量等于0，可以执行接下来的任务。而并发队列中其他任务，由于此时信号量不等于0，必须等当前正在执行的任务执行完毕后调用dispatch_semaphore_signal将信号量加1，才可以继续执行接下来的任务，以此类推，从而达到线程加锁的目的。</p>
<h2 id="延时函数-dispatch-after"><a href="#延时函数-dispatch-after" class="headerlink" title="延时函数(dispatch_after)"></a>延时函数(dispatch_after)</h2><p>dispatch_after能让我们添加进队列的任务延时执行，该函数并不是在指定时间后执行处理，而只是在指定时间追加处理到dispatch_queue</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数是time，第二个参数是dispatch_queue，第三个参数是要执行的block</span></span><br><span class="line">    <span class="built_in">dispatch_after</span>(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * NSEC_PER_SEC)), <span class="built_in">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(@&quot;dispatch_after&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于其内部使用的是dispatch_time_t管理时间，而不是NSTimer。<br>所以如果在子线程中调用，相比performSelector:afterDelay,不用关心runloop是否开启</p>
</blockquote>
<h2 id="使用dispatch-once实现单例"><a href="#使用dispatch-once实现单例" class="headerlink" title="使用dispatch_once实现单例"></a>使用dispatch_once实现单例</h2><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">+ (instancetype)shareInstance &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword"> static</span> dispatch_once_t onceToken;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword"> static</span> id<span class="built_in"> instance </span>= nil;</span><br><span class="line">    </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        </span><br><span class="line">       <span class="built_in"> instance </span>= [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">   <span class="built_in"> return </span>instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NSOperationQueue的优点"><a href="#NSOperationQueue的优点" class="headerlink" title="NSOperationQueue的优点"></a>NSOperationQueue的优点</h2><p>NSOperation、NSOperationQueue 是苹果提供给我们的一套多线程解决方案。实际上 NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。</p>
<p>1、可以添加任务依赖，方便控制执行顺序</p>
<p>2、可以设定操作执行的优先级</p>
<p>3、任务执行状态控制:isReady,isExecuting,isFinished,isCancelled</p>
<p>如果只是重写NSOperation的main方法，由底层控制变更任务执行及完成状态，以及任务退出<br>如果重写了NSOperation的start方法，自行控制任务状态<br>系统通过KVO的方式移除isFinished==YES的NSOperation</p>
<p>4、可以设置最大并发量</p>
<h2 id="NSOperation和NSOperationQueue"><a href="#NSOperation和NSOperationQueue" class="headerlink" title="NSOperation和NSOperationQueue"></a>NSOperation和NSOperationQueue</h2><ul>
<li><strong>操作（Operation）：</strong></li>
</ul>
<p>执行操作的意思，换句话说就是你在线程中执行的那段代码。<br>在 GCD 中是放在 block 中的。在 NSOperation 中，使用 NSOperation 子类 NSInvocationOperation、NSBlockOperation，或者自定义子类来封装操作。</p>
<ul>
<li><strong>操作队列（Operation Queues）：</strong></li>
</ul>
<p>这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。</p>
<p>操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行。</p>
<p>NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。</p>
<h2 id="NSThread-runloop实现常驻线程"><a href="#NSThread-runloop实现常驻线程" class="headerlink" title="NSThread+runloop实现常驻线程"></a>NSThread+runloop实现常驻线程</h2><p>NSThread在实际开发中比较常用到的场景就是去实现常驻线程。</p>
<ul>
<li>由于每次开辟子线程都会消耗cpu，在需要频繁使用子线程的情况下，频繁开辟子线程会消耗大量的cpu，而且创建线程都是任务执行完成之后也就释放了，不能再次利用，那么如何创建一个线程可以让它可以再次工作呢？也就是创建一个常驻线程。</li>
</ul>
<p>首先常驻线程既然是常驻，那么我们可以用GCD实现一个单例来保存NSThread</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSThread</span> *)shareThread &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *shareThread = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        </span><br><span class="line">        shareThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(threadTest) object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">        [shareThread setName:<span class="string">@&quot;threadTest&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        [shareThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> shareThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样创建的thread就不会销毁了吗？</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:[ViewController shareThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;test:%@&quot;</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并没有打印，说明test方法没有被调用。<br>那么可以用runloop来让线程常驻</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSThread</span> *)shareThread &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *shareThread = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        </span><br><span class="line">        shareThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(threadTest2) object:<span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        [shareThread setName:<span class="string">@&quot;threadTest&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        [shareThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> shareThread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)threadTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        </span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        </span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候再去调用performSelector就有打印了。</p>
<h2 id="自旋锁与互斥锁"><a href="#自旋锁与互斥锁" class="headerlink" title="自旋锁与互斥锁"></a>自旋锁与互斥锁</h2><p><strong>自旋锁：</strong></p>
<p>是一种用于保护多线程共享资源的锁，与一般互斥锁（mutex）不同之处在于当自旋锁尝试获取锁时以忙等待（busy waiting）的形式不断地循环检查锁是否可用。当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会一直等待（不会睡眠），当上一个线程的任务执行完毕，下一个线程会立即执行。<br>在多CPU的环境中，对持有锁较短的程序来说，使用自旋锁代替一般的互斥锁往往能够提高程序的性能。</p>
<p><strong>互斥锁：</strong></p>
<p>当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会进入睡眠状态等待任务执行完毕，当上一个线程的任务执行完毕，下一个线程会自动唤醒然后执行任务。</p>
<p><strong>总结：</strong></p>
<p>自旋锁会忙等: 所谓忙等，即在访问被锁资源时，调用者线程不会休眠，而是不停循环在那里，直到被锁资源释放锁。<br>　　互斥锁会休眠: 所谓休眠，即在访问被锁资源时，调用者线程会休眠，此时cpu可以调度其他线程工作。直到被锁资源释放锁。此时会唤醒休眠线程。<br>　　<br><strong>优缺点：</strong></p>
<p>自旋锁的优点在于，因为自旋锁不会引起调用者睡眠，所以不会进行线程调度，CPU时间片轮转等耗时操作。所有如果能在很短的时间内获得锁，自旋锁的效率远高于互斥锁。</p>
<p>　　缺点在于，自旋锁一直占用CPU，他在未获得锁的情况下，一直运行－－自旋，所以占用着CPU，如果不能在很短的时 间内获得锁，这无疑会使CPU效率降低。自旋锁不能实现递归调用。<br>　　<br><strong>自旋锁：atomic、OSSpinLock、dispatch_semaphore_t</strong><br><strong>互斥锁：pthread_mutex、@ synchronized、NSLock、NSConditionLock 、NSCondition、NSRecursiveLock</strong><br>更多内容可移步大神详解<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmliaXJlbWUuY29tLzIwMTYvMDEvMTYvc3BpbmxvY2tfaXNfdW5zYWZlX2luX2lvcy8=">OSSpinLock<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>创建队列得时候，都会走到这么一个函数进入_dispatch_lane_create_with_target(）源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="type">static</span> <span class="type">dispatch_queue_t</span></span><br><span class="line">_dispatch_lane_create_with_target(<span class="type">const</span> <span class="type">char</span> *label, <span class="type">dispatch_queue_attr_t</span> dqa,</span><br><span class="line">        <span class="type">dispatch_queue_t</span> tq, <span class="type">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// dqai 创建 -</span></span><br><span class="line">    <span class="type">dispatch_queue_attr_info_t</span> dqai = _dispatch_queue_attr_to_info(dqa);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一步：规范化参数，例如qos, overcommit, tq</span></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拼接队列名称</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *vtable;</span><br><span class="line">    <span class="type">dispatch_queue_flags_t</span> dqf = legacy ? DQF_MUTABLE : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (dqai.dqai_concurrent) &#123; <span class="comment">//vtable表示类的类型</span></span><br><span class="line">        <span class="comment">// OS_dispatch_queue_concurrent</span></span><br><span class="line">        vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建队列，并初始化</span></span><br><span class="line">    <span class="type">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">            <span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_lane_s)); <span class="comment">// alloc</span></span><br><span class="line">    <span class="comment">//根据dqai.dqai_concurrent的值，就能判断队列 是 串行 还是并发</span></span><br><span class="line">    _dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">            DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">            (dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>)); <span class="comment">// init</span></span><br><span class="line">    <span class="comment">//设置队列label标识符</span></span><br><span class="line">    dq-&gt;dq_label = label;<span class="comment">//label赋值</span></span><br><span class="line">    dq-&gt;dq_priority = _dispatch_priority_make((<span class="type">dispatch_qos_t</span>)dqai.dqai_qos, dqai.dqai_relpri);<span class="comment">//优先级处理</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类似于类与元类的绑定，不是直接的继承关系，而是类似于模型与模板的关系</span></span><br><span class="line">    dq-&gt;do_targetq = tq;</span><br><span class="line">    _dispatch_object_debug(dq, <span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> _dispatch_trace_queue_create(dq)._dq;<span class="comment">//研究dq</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_dispatch_lane_create_with_target 分析</p>
<p>【第一步】通过_dispatch_queue_attr_to_info方法传入dqa（即队列类型，串行、并发等）创建dispatch_queue_attr_info_t类型的对象dqai，用于存储队列的相关属性信息<br>【第二步】设置队列相关联的属性，例如服务质量qos等<br>【第三步】通过DISPATCH_VTABLE拼接队列名称，即vtable，其中DISPATCH_VTABLE是宏定义，如下所示，所以队列的类型是通过OS_dispatch_+队列类型queue_concurrent拼接而成的<br>串行队列类型：<code>OS_dispatch_queue_serial</code><br>并发队列类型：<code>OS_dispatch_queue_concurrent</code><br>【第四步】通过alloc+init初始化队列，即dq，其中在_dispatch_queue_init传参中根据dqai.dqai_concurrent的布尔值，就能判断队列 是 串行 还是并发，而 vtable表示队列的类型，说明队列也是对象<br>【第五步】通过_dispatch_trace_queue_create对创建的队列进行处理，其中_dispatch_trace_queue_create是_dispatch_introspection_queue_create封装的宏定义，最后会返回处理过的_dq</p>
<p>非常不错的 <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC82OTNlYzk2MmIzZDM=">https://www.jianshu.com/p/693ec962b3d3<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络</title>
    <url>/iOS/network/index.html</url>
    <content><![CDATA[<h2 id="Http-和-Https-的区别？为什么更加安全？"><a href="#Http-和-Https-的区别？为什么更加安全？" class="headerlink" title="Http 和 Https 的区别？为什么更加安全？"></a><code>Http</code> 和 <code>Https</code> 的区别？为什么更加安全？</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>1.<code>HTTPS</code> 需要向机构申请 <code>CA</code> 证书，极少免费。</li>
<li>2.<code>HTTP</code> 属于明文传输，<code>HTTPS</code>基于 <code>SSL</code> 进行加密传输。</li>
<li>3.<code>HTTP</code> 端口号为 <code>80</code>，<code>HTTPS</code> 端口号为 <code>443</code> 。</li>
<li>4.<code>HTTPS</code> 是加密传输，有身份验证的环节，更加安全。</li>
</ul>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p><strong>SSL(安全套接层)</strong><br><strong>TLS(传输层安全)</strong></p>
<p>以上两者在传输层之上，对网络连接进行加密处理，保障数据的完整性，更加的安全。</p>
<h2 id="TCP-IP-五层模型的协议"><a href="#TCP-IP-五层模型的协议" class="headerlink" title="TCP/IP 五层模型的协议?"></a><code>TCP/IP</code> 五层模型的协议?</h2><ul>
<li>应用层</li>
<li>传输层</li>
<li>网路层 </li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<h2 id="OSI-七层模型的协议"><a href="#OSI-七层模型的协议" class="headerlink" title="OSI 七层模型的协议?"></a><code>OSI</code> 七层模型的协议?</h2><ul>
<li>应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</li>
<li>表示层 数据格式化，代码转换，数据加密 没有协议</li>
<li>会话层 解除或建立与别的接点的联系 没有协议</li>
<li>传输层 提供端对端的接口 TCP，UDP</li>
<li>网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP</li>
<li>数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU</li>
<li>物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2</li>
</ul>
<h2 id="断点续传-功能该怎么实现？"><a href="#断点续传-功能该怎么实现？" class="headerlink" title="断点续传 功能该怎么实现？"></a><code>断点续传</code> 功能该怎么实现？</h2><ul>
<li>1.利用 <code>http</code> 的头部字段 ，设置 <code>http</code> 的 <code>Range</code> 属性</li>
<li>2.检测下载进度，并且判断是否需要重新创建下载文件</li>
</ul>
<h2 id="DNS-的解析过程？网络的-DNS-优化。"><a href="#DNS-的解析过程？网络的-DNS-优化。" class="headerlink" title="DNS 的解析过程？网络的 DNS 优化。"></a><code>DNS</code> 的解析过程？网络的 <code>DNS</code> 优化。</h2><blockquote>
<p><code>DNS</code> 是域名到 <code>IP</code> 地址的映射，<code>DNS</code> 解析使用 <code>UDP</code> 数据报，端口号53，并且采用明文传输的方式</p>
</blockquote>
<p>客户端在向服务端发送请求时，会先将 <code>域名</code> 到 <code>DNS</code> 服务器映射出 <code>IP</code> 地址，然后再访问。</p>
<h3 id="DNS-解析的两种方式"><a href="#DNS-解析的两种方式" class="headerlink" title="DNS 解析的两种方式"></a><code>DNS</code> 解析的两种方式</h3><h4 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h4><p>不断地自下而上遍历解析，“我去给你问一下”的方式</p>
<h4 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h4><p>迭代查询 是 “我告诉你谁可能知道”的方式</p>
<h3 id="DNS-解析存在的问题"><a href="#DNS-解析存在的问题" class="headerlink" title="DNS 解析存在的问题"></a><code>DNS</code> 解析存在的问题</h3><h4 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a><code>DNS</code> 劫持</h4><p>被钓鱼网站劫持，有可能返回错误的 <code>IP</code>，浏览的不是目标浏览器</p>
<h4 id="DNS-解析转发"><a href="#DNS-解析转发" class="headerlink" title="DNS 解析转发"></a><code>DNS</code> 解析转发</h4><p>晓得运营商可能将 <code>DNS</code> 解析请求转发，解析的比较慢，效率低</p>
<h3 id="DNS-劫持解决办法"><a href="#DNS-劫持解决办法" class="headerlink" title="DNS 劫持解决办法"></a><code>DNS</code> 劫持解决办法</h3><h4 id="httpDNS"><a href="#httpDNS" class="headerlink" title="httpDNS"></a>httpDNS</h4><p>使用 <code>http</code> 协议向 <code>DNS</code> 服务器 80 端口进行请求</p>
<h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><p>找一个中间的长连 <code>server</code> ,在内网专线进行 <code>Http</code> 请求。客户端和这个长连 <code>server</code>通信即可。</p>
<h2 id="Post请求体有哪些格式？"><a href="#Post请求体有哪些格式？" class="headerlink" title="Post请求体有哪些格式？"></a><code>Post</code>请求体有哪些格式？</h2><h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h3><p>这应该是最常见的 <code>POST</code> 提交数据的方式了。浏览器的原生 <code>form</code> 表单，如果不设置 <code>enctype</code> 属性，那么最终就会以 <code>application/x-www-form-urlencoded</code> 方式提交数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST  HTTP/1.1</span><br><span class="line">Host: www.demo.com</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Postman-Token: 81d7b315-d4be-8ee8-1237-04f3976de032</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">key=value&amp;testKey=testValue</span><br></pre></td></tr></table></figure>

<h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST  HTTP/1.1</span><br><span class="line">Host: www.demo.com</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Postman-Token: 679d816d-8757-14fd-57f2-fbc2518dddd9</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=&quot;key&quot;</span><br><span class="line"></span><br><span class="line">value</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=&quot;testKey&quot;</span><br><span class="line"></span><br><span class="line">testValue</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=&quot;imgFile&quot;; filename=&quot;no-file&quot;</span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">in</span> <span class="attr">here</span>&gt;</span></span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW--</span><br></pre></td></tr></table></figure>
<h3 id="application-json"><a href="#application-json" class="headerlink" title="application/json"></a>application/json</h3><h3 id="text-xml"><a href="#text-xml" class="headerlink" title="text/xml"></a>text/xml</h3><h2 id="什么是-Mimetype"><a href="#什么是-Mimetype" class="headerlink" title="什么是 Mimetype ?"></a>什么是 <code>Mimetype</code> ?</h2><p>在浏览器中显示的内容有 <code>HTML</code>、有 <code>XML</code>、有 <code>GIF</code>、还有 <code>Flash</code> ……那么，浏览器是如何区分它们，决定什么内容用什么形式来显示呢？答案是 <code>MIME Type</code>，也就是该资源的媒体类型。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向该文件发送请求,根据请求头拿到该文件的MIMEType</span></span><br><span class="line">-(<span class="built_in">NSString</span> *)getMIMETypeURLRequestAtPath:(<span class="built_in">NSString</span>*)path</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.确定请求路径</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> fileURLWithPath:path];</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//2.创建可变的请求对象</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.发送请求</span></span><br><span class="line">    <span class="built_in">NSHTTPURLResponse</span> *response = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendSynchronousRequest:request returningResponse:&amp;response error:<span class="literal">nil</span>];</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">NSString</span> *mimeType = response.MIMEType;</span><br><span class="line">    <span class="keyword">return</span> mimeType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="网络请求的状态码都大致代表什么意思？"><a href="#网络请求的状态码都大致代表什么意思？" class="headerlink" title="网络请求的状态码都大致代表什么意思？"></a>网络请求的状态码都大致代表什么意思？</h2><h3 id="1-1xx"><a href="#1-1xx" class="headerlink" title="1.1xx"></a>1.1xx</h3><blockquote>
<p>1xx 代表临时响应，需要请求者继续执行操作的状态代码。</p>
</blockquote>
<h3 id="2-2xx"><a href="#2-2xx" class="headerlink" title="2.2xx"></a>2.2xx</h3><blockquote>
<p>2xx 代表的多是操作成功。</p>
</blockquote>
<h3 id="3-3xx"><a href="#3-3xx" class="headerlink" title="3.3xx"></a>3.3xx</h3><blockquote>
<p>3xx 代表重定向，表示要完成请求，需要进一步操作</p>
</blockquote>
<h3 id="4-4xx"><a href="#4-4xx" class="headerlink" title="4.4xx"></a>4.4xx</h3><blockquote>
<p>4xx 代表请求错误，表示请求可能出错，妨碍了服务器的处理。</p>
</blockquote>
<h3 id="5-5xx"><a href="#5-5xx" class="headerlink" title="5.5xx"></a>5.5xx</h3><blockquote>
<p>5xx 代表服务器错误，表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错</p>
</blockquote>
<h2 id="如何判断一个请求是否结束？"><a href="#如何判断一个请求是否结束？" class="headerlink" title="如何判断一个请求是否结束？"></a>如何判断一个请求是否结束？</h2><ul>
<li>1.查看 <code>Content-Length</code> 是否达到 1024 字节。</li>
<li>2.通过 <code>Post</code> 发送请求时，消息一般都是一段一段返回的，看最后的一个 <code>chunked</code> 是否为空?</li>
</ul>
<h2 id="SSL-传输协议？说一下-SSL-验证过程？"><a href="#SSL-传输协议？说一下-SSL-验证过程？" class="headerlink" title="SSL 传输协议？说一下 SSL 验证过程？"></a>SSL 传输协议？说一下 SSL 验证过程？</h2><ul>
<li>1.配备了 <code>身份证书</code>，防止被冒充。</li>
<li>2.有 <code>校验机制</code>，一旦被篡改，双方都会知道。</li>
<li>3.通过 <code>加密</code> 进行传播。</li>
</ul>
<h3 id="连接过程如下："><a href="#连接过程如下：" class="headerlink" title="连接过程如下："></a>连接过程如下：</h3><ul>
<li>①：客户端向服务端发消息，包括客户端支持的 <code>加密算法</code> 以及 <code>随机数1</code> 、<code>TLS</code> 版本号。</li>
<li>②：服务端向客户端返回信息，包括双方已经匹配好的 <code>加密算法</code> 以及 <code>随机数2</code>、<code>Server证书</code> 。</li>
<li>③：服务端向客户端返回 <code>验证证书</code>。</li>
<li>④：客户端进行证书验证，首先要评估信任证书<ul>
<li>1.服务端向客户端返回证书的 <code>数字摘要</code> 与服务端证书返回客户端，解密后的是否一致，防止被篡改。</li>
<li>2.验证证书链：逐级验证服务端证书是否在可信任证书列表。</li>
<li>3.验证通过后：<ul>
<li>①：将 <code>随机数1</code>、<code>随机数2</code>、服务器端返回 <code>证书公钥</code> 加密过后的 <code>预主秘钥</code> 三者组合成 <code>会话密钥</code>。</li>
<li>②：服务端拿到 <code>会话秘钥</code>  后，会用服务端证书 <code>私钥</code>进行解密，得到 <code>预主秘钥</code>。</li>
<li>③：服务端将 <code>随机数1</code>、<code>随机数2</code>、服务器端证书私钥解密得到的 <code>预主秘钥</code> 三者组合成 <code>会话密钥</code>。此时客户端的 <code>会话秘钥</code> 和 服务端的 <code>会话秘钥</code> 应该是一致的。</li>
<li>④：接下来会经行验证：<pre><code>- 1.客户端通过 `会话秘钥`，加密信息发给服务端，看服务端能否成功接收。
- 2.服务端通过 `会话秘钥`，加密信息返给客户端，看客户端能否成功解析。
</code></pre>
</li>
</ul>
</li>
<li>4.以上步骤都通过了，此时 <code>SSL</code> 验证连接。</li>
</ul>
</li>
</ul>
<h2 id="解释一下-三次握手-和-四次挥手？"><a href="#解释一下-三次握手-和-四次挥手？" class="headerlink" title="解释一下 三次握手 和 四次挥手？"></a>解释一下 <code>三次握手</code> 和 <code>四次挥手</code>？</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul>
<li>1.由客户端向服务端发送 <code>SYN</code> 同步报文。</li>
<li>2.当服务端收到 <code>SYN</code> 同步报文之后，会返回给客户端 <code>SYN</code> 同步报文和 <code>ACK</code> 确认报文。</li>
<li>3.客户端会向服务端发送 <code>ACK</code> 确认报文，此时客户端和服务端的连接正式建立。</li>
</ul>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><ul>
<li>1.这个时候客户端就可以通过 <code>Http</code> 请求报文，向服务端发送请求</li>
<li>2.服务端接收到客户端的请求之后，向客户端回复 <code>Http</code> 响应报文。</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><strong>当客户端和服务端的连接想要断开的时候，要经历四次挥手的过程，步骤如下：</strong></p>
<ul>
<li>1.先由客户端向服务端发送 <code>FIN</code> 结束报文。</li>
<li>2.服务端会返回给客户端 <code>ACK</code> 确认报文 。此时，由客户端发起的断开连接已经完成。</li>
<li>3.服务端会发送给客户端 <code>FIN</code> 结束报文 和 <code>ACK</code> 确认报文。</li>
<li>4.客户端会返回 <code>ACK</code> 确认报文到服务端，至此，由服务端方向的断开连接已经完成。</li>
</ul>
<h3 id="解释一下为什么是”三次握手”"><a href="#解释一下为什么是”三次握手”" class="headerlink" title="解释一下为什么是”三次握手”"></a>解释一下为什么是”三次握手”</h3><blockquote>
<p>客户端在与服务端建立连接的过程中，客户端向服务端发送连接请求，如果因为网络的原因，导致它超时触发了重传机制，那么客户端会重新向服务端发送一次连接请求，那有可能第二次发送的连接请求，服务端收到之后，直接返回给客户端确认连接的报文。</p>
</blockquote>
<blockquote>
<p>如果只需要两次就可以建立连接，假如说第一次建立连接的请求终于被服务端接收到了，那服务端收到之后，会以为客户端想新建另外一个链接，这样的话就会建立两个连接。</p>
</blockquote>
<blockquote>
<p>而采取三次握手，在客户端收到服务端的确认报文之后，客户端再向服务端发送一个确认报文，这时才正式建立连接。那么第一次因为超时而迟迟没有收到的建立连接的请求，这时在收到之后，服务端依然会向客户端返回一个确认报文，但是服务端现在已经与客户端建立的连接，所以客户端就不会再向服务端发送确认报文，服务端迟迟没有收到确认报文，那么也就不会真正的建立再一次连接。</p>
</blockquote>
<h3 id="又为什么是”四次挥手”？"><a href="#又为什么是”四次挥手”？" class="headerlink" title="又为什么是”四次挥手”？"></a>又为什么是”四次挥手”？</h3><blockquote>
</blockquote>
<p>建立的时候是双方面的建立，而释放的时候，也必然是客户端和服务端双方面的断开连接。</p>
<blockquote>
<p>客户端与服务端建立的连接是双通的，这也就意味着客户端可以向服务端发送请求，服务端向客户端返回响应，同样的也可以从服务端向客户端发送，然后由客户端向服务端返回，如果你只关闭了客户端，向服务端通道，这只叫半关闭状态，并没有完全的切断客户端与服务端的关联。</p>
</blockquote>
<h2 id="谈一谈网络中的-session-和-cookie"><a href="#谈一谈网络中的-session-和-cookie" class="headerlink" title="谈一谈网络中的 session 和 cookie?"></a>谈一谈网络中的 <code>session</code> 和 <code>cookie</code>?</h2><p>因为 <code>Http</code> 无状态的特性，如果需要判断是哪个用户，这时就需要 <code>Cookie</code> 和 <code>Session</code>。</p>
<p><code>Cookie</code> 存储在客户端，用来记录用户状态，区分用户。一般都是服务端把生成的 <code>Cookie</code> 通过响应返回给客户端，客户端保存。</p>
<p><code>Session</code> 存储在网络端，需要依赖 <code>Cookie</code> 机制。服务端生成了 <code>Session</code> 后，返回给客户端，客户端 <code>setCookie:sessionID</code>，所以下次请求的时候，客户端把 <code>Cookie</code> 发送给服务端，服务端解析出 <code>SessionID</code>，在服务端根据 <code>SessionID</code> 判断当前的用户。</p>
<h3 id="如何修改-Cookie"><a href="#如何修改-Cookie" class="headerlink" title="如何修改 Cookie?"></a>如何修改 <code>Cookie</code>?</h3><ul>
<li><p>相同 <code>Key</code> 值得新的 <code>Cookie</code> 会覆盖旧的 <code>Cookie</code>.</p>
</li>
<li><p>覆盖规则是 name path 和 domain 等需要与原有的一致</p>
</li>
</ul>
<h3 id="如何删除-Cookie"><a href="#如何删除-Cookie" class="headerlink" title="如何删除 Cookie?"></a>如何删除 <code>Cookie</code>?</h3><ul>
<li><p>相同 <code>Key</code> 值得新的 <code>Cookie</code> 会覆盖旧的 <code>Cookie</code>.</p>
</li>
<li><p>覆盖规则是 name path 和 domain 等需要与原有的一致</p>
</li>
<li><p>设置 <code>Cookie</code> 的 <code>expires</code> 为过去的一个时间点，或者 <code>maxAge = 0</code></p>
</li>
</ul>
<h3 id="如何保证-Cookie-的安全？"><a href="#如何保证-Cookie-的安全？" class="headerlink" title="如何保证 Cookie 的安全？"></a>如何保证 <code>Cookie</code> 的安全？</h3><ul>
<li>对 <code>Cookie</code> 进行加密处理</li>
<li>只在 <code>Https</code> 上携带 <code>Cookie</code>。 </li>
<li>设置 <code>Cookie</code> 为 <code>httpOnly</code>，防止跨站脚本攻击。</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C 语言</title>
    <url>/iOS/objective-c/index.html</url>
    <content><![CDATA[<h2 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h2><p>个人语言简述如下</p>
<ul>
<li>事件(例如点击屏幕)产生后，系统会把事件传递给当前的application，然后是window依次传递给viewcontroller，最后是手指所接触的view，</li>
<li>这个过程会被阻断，比如 userInteractionEnabled = NO,再比如隐藏 hidden = YES.透明度&lt;0.01,再比如指定了<code>hitTest：withEvent：</code>方法等。</li>
<li>然后，开始处理事件，view(UIResponder)来响应，view不处理，则上一级接受到继续，一直到application,这个过程重要的方法如下</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 上一个响应者可能是父控件</span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123; </span><br><span class="line"><span class="regexp">//</span> 默认会把事件传递给上一个响应者,上一个响应者是父控件,交给父控件处理</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>再比如自己处理完还想让父响应者也处理，就在这写一些东西</span><br><span class="line"><span class="regexp">//</span><span class="keyword">do</span> something here</span><br><span class="line"></span><br><span class="line">[super touchesBegan:touches withEvent:event]; </span><br><span class="line"><span class="regexp">//</span> 注意不是调用父控件的touches方法，而是调用父类的touches方法</span><br><span class="line"><span class="regexp">//</span> super是父类 superview是父控件 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h2><p>1.读写权限：readonly,readwrite(默认)<br>2.原子性: atomic(默认)，nonatomic。atomic读写线程安全，但效率低，而且不是绝对的安全，比如如果修饰的是数组，那么对数组的读写是安全的，但如果是操作数组进行添加移除其中对象的还，就不保证安全了。<br>3.引用计数：</p>
<ul>
<li>retain/strong</li>
<li>assign：修饰基本数据类型，修饰对象类型时，不改变其引用计数，会产生悬垂指针，修饰的对象在被释放后，assign指针仍然指向原对象内存地址，如果使用assign指针继续访问原对象的话，就可能会导致内存泄漏或程序异常</li>
<li>weak：不改变被修饰对象的引用计数，所指对象在被释放后，weak指针会自动置为nil</li>
<li>copy：分为深拷贝和浅拷贝<br>浅拷贝：对内存地址的复制，让目标对象指针和原对象指向同一片内存空间会增加引用计数<br>深拷贝：对对象内容的复制，开辟新的内存空间</li>
</ul>
<p>可变对象的copy和mutableCopy都是深拷贝<br>不可变对象的copy是浅拷贝，mutableCopy是深拷贝<br>copy方法返回的都是不可变对象</p>
<ul>
<li>@property (nonatomic, copy) NSMutableArray * array;这样写有什么影响？<br>因为copy方法返回的都是不可变对象，所以array对象实际上是不可变的，如果对其进行可变操作如添加移除对象，则会造成程序crash</li>
</ul>
<h2 id="KVO-Key-value-observing"><a href="#KVO-Key-value-observing" class="headerlink" title="KVO (Key-value observing)"></a>KVO (Key-value observing)</h2><p>KVO是观察者模式的另一实现。<br>使用了isa混写(isa-swizzling)来实现KVO</p>
<p>使用setter方法改变值KVO会生效，使用setValue:forKey即KVC改变值KVO也会生效，因为KVC会去调用setter方法</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">- (void)setValue:(id)value</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-attr">[self willChangeValueForKey:@<span class="string">&quot;key&quot;</span>]</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-attr">[super setValue:value]</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-attr">[self didChangeValueForKey:@<span class="string">&quot;key&quot;</span>]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>那么通过直接赋值成员变量会触发KVO吗？<br>不会，因为不会调用setter方法，需要加上<br>willChangeValueForKey和didChangeValueForKey方法来手动触发才行</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
        <category>Objetive-C</category>
      </categories>
      <tags>
        <tag>Objetive-C</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C中的分类</title>
    <url>/iOS/origincode/category.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面试题</p>
<ul>
<li>Category的实现原理，以及Category为什么只能加方法不能加属性。</li>
<li>Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？</li>
<li>load、initialize的区别，以及它们在category重写的时候的调用的次序。</li>
</ul>
<p>分类中的对象方法依然是存储在类对象中的，同对象方法在同一个地方，那么调用步骤也同调用对象方法一样。如果是类方法的话，也同样是存储在元类对象中</p>
<p>category和extension?</p>
<ul>
<li><p>extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2xpYnJhcnkvYXJjaGl2ZS9kb2N1bWVudGF0aW9uL0NvY29hL0NvbmNlcHR1YWwvUHJvZ3JhbW1pbmdXaXRoT2JqZWN0aXZlQy9DdXN0b21pemluZ0V4aXN0aW5nQ2xhc3Nlcy9DdXN0b21pemluZ0V4aXN0aW5nQ2xhc3Nlcy5odG1s">（详见2）<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>但是category则完全不一样，它是在运行期决议的。 就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p>
</li>
</ul>
<h1 id="话不多说，源码来看"><a href="#话不多说，源码来看" class="headerlink" title="话不多说，源码来看"></a>话不多说，源码来看</h1><p>我们知道，所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了：</p>
<ul>
<li>1)、类的名字（name）</li>
<li>2)、类（cls）</li>
<li>3)、category中所有给类添加的实例方法的列表（instanceMethods）</li>
<li>4)、category中所有添加的类方法的列表（classMethods）</li>
<li>5)、category实现的所有协议的列表（protocols）</li>
<li>6)、category中添加的所有属性（instanceProperties）</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> category_t &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="type">char</span> *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    <span class="keyword">struct</span> method_list_t *instanceMethods; <span class="comment">// 对象方法</span></span><br><span class="line">    <span class="keyword">struct</span> method_list_t *classMethods; <span class="comment">// 类方法</span></span><br><span class="line">    <span class="keyword">struct</span> protocol_list_t *protocols; <span class="comment">// 协议</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *instanceProperties; <span class="comment">// 属性</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="keyword">struct</span> property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *methodsForMeta(<span class="type">bool</span> isMeta) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    property_list_t *propertiesForMeta(<span class="type">bool</span> isMeta, <span class="keyword">struct</span> header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从源码基本可以看出我们平时使用categroy的方式，对象方法，类方法，协议，和属性都可以找到对应的存储方式。并且我们发现分类结构体中是不存在成员变量的，因此分类中是不允许添加成员变量的。分类中添加的属性并不会帮助我们自动生成成员变量，只会生成get set方法的声明，需要我们自己去实现。</p>
<p>通过源码我们发现，分类的方法，协议，属性等好像确实是存放在categroy结构体里面的，那么他又是如何存储在类对象中的呢？<br>我们来看一下底层的内部方法探寻其中的原理。<br>首先我们通过命令行将MyClass+MyAddition.m.m文件转化为c++文件，查看其中的编译过程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -<span class="built_in">arch</span> arm64 -rewrite-objc MyClass+MyAddition.m</span><br></pre></td></tr></table></figure>
<p>好吧，我们得到了一个3M大小，10w多行的.cpp文件（这绝对是Apple值得吐槽的一点），我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段：</p>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">static struct <span class="comment">/*_method_list_t*/</span> &#123;</span><br><span class="line">unsigned int entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct <span class="variable">_objc_method</span> method_list[<span class="number">1</span>];</span><br><span class="line">&#125; <span class="variable">_OBJC_</span>$<span class="variable">_CATEGORY_INSTANCE_METHODS_MyClass_</span>$<span class="variable">_MyAddition</span> <span class="variable">__attribute__</span> ((used, section (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line"><span class="built_in">sizeof</span>(<span class="variable">_objc_method</span>),</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">&#123;&#123;(struct objc_selector *)<span class="string">&quot;printName&quot;</span>, <span class="string">&quot;v16@0:8&quot;</span>, (void *)<span class="variable">_I_MyClass_MyAddition_printName</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct <span class="comment">/*_prop_list_t*/</span> &#123;</span><br><span class="line">unsigned int entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">unsigned int count_of_properties;</span><br><span class="line">struct <span class="variable">_prop_t</span> prop_list[<span class="number">1</span>];</span><br><span class="line">&#125; <span class="variable">_OBJC_</span>$<span class="variable">_PROP_LIST_MyClass_</span>$<span class="variable">_MyAddition</span> <span class="variable">__attribute__</span> ((used, section (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line"><span class="built_in">sizeof</span>(<span class="variable">_prop_t</span>),</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line">&#123;&#123;<span class="string">&quot;name&quot;</span>,<span class="string">&quot;T@\&quot;</span>NSString\<span class="string">&quot;,C,N&quot;</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern <span class="string">&quot;C&quot;</span> <span class="variable">__declspec</span>(dllexport) struct <span class="variable">_class_t</span> OBJC_CLASS_$<span class="variable">_MyClass</span>;</span><br><span class="line"></span><br><span class="line">static struct <span class="variable">_category_t</span> <span class="variable">_OBJC_</span>$<span class="variable">_CATEGORY_MyClass_</span>$<span class="variable">_MyAddition</span> <span class="variable">__attribute__</span> ((used, section (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) =</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;MyClass&quot;</span>,</span><br><span class="line"><span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_MyClass,</span></span><br><span class="line">(const struct <span class="variable">_method_list_t</span> *)&amp;<span class="variable">_OBJC_</span>$<span class="variable">_CATEGORY_INSTANCE_METHODS_MyClass_</span>$<span class="variable">_MyAddition</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">(const struct <span class="variable">_prop_list_t</span> *)&amp;<span class="variable">_OBJC_</span>$<span class="variable">_PROP_LIST_MyClass_</span>$<span class="variable">_MyAddition</span>,</span><br><span class="line">&#125;;</span><br><span class="line">static void OBJC_CATEGORY_SETUP_$<span class="variable">_MyClass_</span>$<span class="variable">_MyAddition</span>(void ) &#123;</span><br><span class="line"><span class="variable">_OBJC_</span>$<span class="variable">_CATEGORY_MyClass_</span>$<span class="variable">_MyAddition</span>.cls = &amp;OBJC_CLASS_$<span class="variable">_MyClass</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma section(<span class="string">&quot;.objc_inithooks$B&quot;</span>, long, read, write)</span></span><br><span class="line"><span class="variable">__declspec</span>(allocate(<span class="string">&quot;.objc_inithooks$B&quot;</span>)) static void *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">(void *)&amp;OBJC_CATEGORY_SETUP_$<span class="variable">_MyClass_</span>$<span class="variable">_MyAddition</span>,</span><br><span class="line">&#125;;</span><br><span class="line">static struct <span class="variable">_class_t</span> *L_OBJC_LABEL_CLASS_$ [<span class="number">1</span>] <span class="variable">__attribute__</span>((used, section (<span class="string">&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;</span>)))= &#123;</span><br><span class="line">&amp;OBJC_CLASS_$<span class="variable">_MyClass</span>,</span><br><span class="line">&#125;;</span><br><span class="line">static struct <span class="variable">_class_t</span> *<span class="variable">_OBJC_LABEL_NONLAZY_CLASS_</span>$[] = &#123;</span><br><span class="line">&amp;OBJC_CLASS_$<span class="variable">_MyClass</span>,</span><br><span class="line">&#125;;</span><br><span class="line">static struct <span class="variable">_category_t</span> *L_OBJC_LABEL_CATEGORY_$ [<span class="number">1</span>] <span class="variable">__attribute__</span>((used, section (<span class="string">&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;</span>)))= &#123;</span><br><span class="line">&amp;<span class="variable">_OBJC_</span>$<span class="variable">_CATEGORY_MyClass_</span>$<span class="variable">_MyAddition</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，</p>
<ul>
<li><p>1)、首先编译器生成了实例方法列表OBJC$_CATEGORY_INSTANCE_METHODSMyClass$_MyAddition和属性列表OBJC$_PROP_LISTMyClass$_MyAddition，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的<code>category名不能重复</code>，否则会出现编译错误。</p>
</li>
<li><p>2)、其次，编译器生成了category本身OBJC$_CATEGORYMyClass$_MyAddition，并用前面生成的列表来初始化category本身。</p>
</li>
<li><p>3)、最后，编译器在DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组L_OBJC_LABELCATEGORY$（当然，如果有多个category，会生成对应长度的数组^_^），用于运行期category的加载。</p>
</li>
</ul>
<p>到这里，编译器的工作就接近尾声了，对于category在运行期怎么加载?</p>
<h1 id="Runtime的时候加载"><a href="#Runtime的时候加载" class="headerlink" title="Runtime的时候加载"></a>Runtime的时候加载</h1><p>我们知道，Objective-C的运行是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。</p>
<p>对于OC运行时，入口方法如下（在objc-os.mm文件中）：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _objc_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// Register for unmap first, in case some +load unmaps something</span></span><br><span class="line">    _dyld_register_func_for_remove_image(&amp;unmap_image);</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_bound,</span><br><span class="line">                                             <span class="number">1</span><span class="comment">/*batch*/</span>, &amp;map_images);</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, <span class="number">0</span><span class="comment">/*not batch*/</span>, &amp;load_images);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ategory被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Discover categories. </span></span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist =</span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            class_t *cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cls) &#123;</span><br><span class="line">                <span class="comment">// Category&#x27;s target class is missing (probably weak-linked).</span></span><br><span class="line">                <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">                catlist[i] = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span></span><br><span class="line">                                 <span class="string">&quot;missing weak-linked target class&quot;</span>,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process this category. </span></span><br><span class="line">            <span class="comment">// First, register the category with its target class. </span></span><br><span class="line">            <span class="comment">// Then, rebuild the class&#x27;s method lists (etc) if </span></span><br><span class="line">            <span class="comment">// the class is realized. </span></span><br><span class="line">            <span class="type">BOOL</span> classExists = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols </span><br><span class="line">                ||  cat-&gt;instanceProperties)</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                <span class="keyword">if</span> (isRealized(cls)) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: found category -%s(%s) %s&quot;</span>,</span><br><span class="line">                                 getName(cls), cat-&gt;name,</span><br><span class="line">                                 classExists ? <span class="string">&quot;on existing class&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols </span><br><span class="line">                <span class="comment">/* ||  cat-&gt;classProperties */</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;isa, hi);</span><br><span class="line">                <span class="keyword">if</span> (isRealized(cls-&gt;isa)) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;isa);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(<span class="string">&quot;CLASS: found category +%s(%s)&quot;</span>,</span><br><span class="line">                                 getName(cls), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中我们可以知道这段代码是用来查找有没有分类的。通过_getObjc2CategoryList函数获取到分类列表之后，进行遍历，获取其中的方法，协议，属性等。可以看到最终都调用了remethodizeClass(cls);函数。我们来到remethodizeClass(cls);函数内部查看。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">void</span> remethodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="type">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="literal">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;CLASS: attaching categories to class &#x27;%s&#x27; %s&quot;</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? <span class="string">&quot;(meta)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        attachCategories(cls, cats, <span class="literal">true</span> <span class="comment">/*flush caches*/</span>);        </span><br><span class="line">        free(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述代码我们发现attachCategories函数接收了类对象cls和分类数组cats，如我们一开始写的代码所示，一个类可以有多个分类。之前我们说到分类信息存储在category_t结构体中，那么多个分类则保存在category_list中。<br>我们来到attachCategories函数内部。</p>
<img src="/images/iOS/attachCategoryMethods.jpeg" class="" title="attachCategoryMethods">

<p>attachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法,继续往下看</p>
<img src="/images/iOS/attachLists.jpeg" class="" title="attachLists">
<p>需要注意的有两点：</p>
<ul>
<li><p>1)、category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA</p>
</li>
<li><p>2)、category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。</p>
</li>
</ul>
<p>问： Category的实现原理，以及Category为什么只能加方法不能加属性?<br>答：分类的实现原理是将category中的方法，属性，协议数据放在category_t结构体中，然后将结构体内的方法列表拷贝到类对象的方法列表中。<br>Category可以添加属性，但是并不会自动生成成员变量及set/get方法。因为category_t结构体中并不存在成员变量。通过之前对对象的分析我们知道<code>成员变量是存放在实例对象中的</code>，并且<code>编译的那一刻</code>就已经<code>决定</code>好了。而分类是在运行时才去加载的。那么我们就无法再程序运行时将分类的成员变量中添加到实例对象的结构体中。因此分类中不可以添加成员变量。</p>
<h1 id="load-和-initialize"><a href="#load-和-initialize" class="headerlink" title="load 和 initialize"></a>load 和 initialize</h1><p>load方法会在程序启动就会调用，当装载类信息的时候就会调用。 调用顺序看一下源代码。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> call_load_methods(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">bool</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="type">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();   <span class="comment">//看这里看这里！！！！！ 先调用类的load</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();  <span class="comment">//看这里看这里！！！！！ 分类的load</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>load方法依次调用 类 分类  ,函数式调用的哦</p>
<p>initialize是通过消息发送机制调用的，消息发送机制通过isa指针找到对应的方法与实现，因此先找到分类方法中的实现，会优先调用分类方法中的实现。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>问：Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？<br>答：Category中有load方法，load方法在程序<code>启动装载类信息</code>(_objc_init)的时候就会调用。load方法可以继承。调用子类的load方法之前，会先调用<code>父类的load</code>方法<br>问：load、initialize的区别，以及它们在category重写的时候的调用的次序。<br>答：区别在于调用方式和调用时刻<br>调用方式：load是根据函数地址直接调用，initialize是通过objc_msgSend调用<br>调用时刻：load是runtime加载类、分类的时候调用（只会调用1次），initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次（父类的initialize方法可能会被调用多次）<br>调用顺序：先调用类的load方法，先编译那个类，就先调用load。在调用load之前会先调用父类的load方法。分类中load方法不会覆盖本类的load方法，先编译的分类优先调用load方法。initialize先初始化父类，之后再初始化子类。如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次），如果分类实现了+initialize，就覆盖类本身的+initialize调用。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>源码学习</category>
        <category>分类原理</category>
      </categories>
      <tags>
        <tag>iOS源码学习</tag>
        <tag>分类原理</tag>
      </tags>
  </entry>
  <entry>
    <title>dispatch_once</title>
    <url>/iOS/origincode/dispatch_once.html</url>
    <content><![CDATA[<p>本文使用的源码是<span class="exturl" data-url="aHR0cHM6Ly9vcGVuc291cmNlLmFwcGxlLmNvbS90YXJiYWxscy9saWJkaXNwYXRjaC8=">libdispatch-1008.220.2<i class="fa fa-external-link-alt"></i></span>版本。</p>
<h1 id="once-h"><a href="#once-h" class="headerlink" title="once.h"></a>once.h</h1><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一部分 dispatch_once 的定义，其实是一个_dispatch_once</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="built_in">dispatch_once</span>(<span class="built_in">dispatch_once_t</span> *predicate,</span><br><span class="line">		DISPATCH_NOESCAPE dispatch_block_t block);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_<span class="built_in">dispatch_once</span>(<span class="built_in">dispatch_once_t</span> *predicate,</span><br><span class="line">		DISPATCH_NOESCAPE dispatch_block_t block)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (DISPATCH_EXPECT(*predicate, ~<span class="number">0</span>l) != ~<span class="number">0</span>l) &#123;</span><br><span class="line">		<span class="built_in">dispatch_once</span>(predicate, block);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dispatch_compiler_barrier();</span><br><span class="line">	&#125;</span><br><span class="line">	DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~<span class="number">0</span>l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> dispatch_once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dispatch_once _dispatch_once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二部分 dispatch_once_f 的定义，其实是一个 ——dispatch_once_f</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">dispatch_once_f(<span class="built_in">dispatch_once_t</span> *predicate, <span class="type">void</span> *_Nullable context,</span><br><span class="line">		dispatch_function_t function);</span><br><span class="line"><span class="type">void</span></span><br><span class="line">_dispatch_once_f(<span class="built_in">dispatch_once_t</span> *predicate, <span class="type">void</span> *_Nullable context,</span><br><span class="line">		dispatch_function_t function)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (DISPATCH_EXPECT(*predicate, ~<span class="number">0</span>l) != ~<span class="number">0</span>l) &#123;</span><br><span class="line">		dispatch_once_f(predicate, context, function);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		dispatch_compiler_barrier();</span><br><span class="line">	&#125;</span><br><span class="line">	DISPATCH_COMPILER_CAN_ASSUME(*predicate == ~<span class="number">0</span>l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> dispatch_once_f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dispatch_once_f _dispatch_once_f</span></span><br></pre></td></tr></table></figure>

<p>由上可以简单的知道，dispatch_once 调用了 dispatch_once_f方法，<br>为了解释<code>DISPATCH_EXPECT</code>,我把宏定义贴下面</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> __GNUC__</span><br><span class="line">#define <span class="constructor">DISPATCH_EXPECT(<span class="params">x</span>, <span class="params">v</span>)</span> <span class="constructor">__builtin_expect((<span class="params">x</span>)</span>, (v))</span><br><span class="line">#define dispatch<span class="constructor">_compiler_barrier()</span>  __asm__ <span class="constructor">__volatile__(<span class="string">&quot;&quot;</span> ::: <span class="string">&quot;memory&quot;</span>)</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">#define <span class="constructor">DISPATCH_EXPECT(<span class="params">x</span>, <span class="params">v</span>)</span> (x)</span><br><span class="line">#define dispatch<span class="constructor">_compiler_barrier()</span>  <span class="keyword">do</span> &#123; &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<blockquote>
<p>头文件中用到一个DISPATCH_EXPECT宏，这个宏展开之后其实是一个GCC内置函数__builtin_expect(exp, c)，在GCC手册上是这样描述这个函数的：由于大部分程序员在分支预测方面做得很糟糕，所以 GCC 提供了这个内建函数来帮助程序员处理分支预测，优化程序。其第一个参数 exp 为一个整型表达式，这个内建函数的返回值也是这个 exp ，而 c 为一个编译期常量。这个函数的语义是：你期望 exp 表达式的值等于常量 c ，从而 GCC 为你优化程序，将符合这个条件的分支放在合适的地方</p>
</blockquote>
<p>我们来看实现</p>
<h1 id="once-c"><a href="#once-c" class="headerlink" title="once.c"></a>once.c</h1>]]></content>
      <categories>
        <category>iOS</category>
        <category>源码学习</category>
        <category>dispatch_once</category>
      </categories>
      <tags>
        <tag>iOS源码学习</tag>
        <tag>dispatch_once</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C中的元类是什么？</title>
    <url>/iOS/origincode/metaclass.html</url>
    <content><![CDATA[<h1 id="在运行时创建一个类"><a href="#在运行时创建一个类" class="headerlink" title="在运行时创建一个类"></a>在运行时创建一个类</h1><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class newClass = objc_allocateClassPair([<span class="built_in">NSError</span> <span class="keyword">class</span>], <span class="string">&quot;RuntimeErrorSubclass&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addMethod(newClass, <span class="keyword">@selector</span>(report), (IMP)ReportFunction, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">objc_registerClassPair(newClass);</span><br></pre></td></tr></table></figure>

<p>添加的方法使用名为ReportFunction其实现的函数，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> ReportFunction(<span class="type">id</span> <span class="keyword">self</span>, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;This object is %p.&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Class is %@, and super is %@.&quot;</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], [<span class="keyword">self</span> superclass]);</span><br><span class="line">    </span><br><span class="line">    Class currentClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;Following the isa pointer %d times gives %p&quot;</span>, i, currentClass);</span><br><span class="line">        currentClass = object_getClass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;NSObject&#x27;s class is %p&quot;</span>, [<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;NSObject&#x27;s meta class is %p&quot;</span>, object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从表面上看，这一切都非常简单。在运行时创建类只需三个简单的步骤：</p>
<ul>
<li>为“类对”分配存储（使用objc_allocateClassPair）。</li>
<li>根据需要将方法和ivars添加到类中（我添加了一个方法class_addMethod）。</li>
<li>注册该类以便可以使用（使用objc_registerClassPair）。</li>
</ul>
<p>然而，当前的问题是：什么是“class pair”？该函数objc_allocateClassPair只返回一个值：类。那对的另一半在哪里？</p>
<p>我敢肯定你已经猜到了这一对的另一半是元类（这是这篇文章的标题）但是为了解释这是什么以及你为什么需要它，我将给出一些关于对象的背景知识和Objective-C中的类。</p>
<h1 id="成为对象de数据结构需要什么？"><a href="#成为对象de数据结构需要什么？" class="headerlink" title="成为对象de数据结构需要什么？"></a>成为对象de数据结构需要什么？</h1><p>在Objective-C中，对象的类由其isa指针确定。该isa指针指向对象的类。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125; *<span class="type">id</span>;</span><br></pre></td></tr></table></figure>
<p>这就是说：任何以指向Class结构的指针开头的结构都可以视为objc_object。</p>
<p>Objective-C中对象最重要的特性是你可以向它们发送消息：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="string">@&quot;stringValue&quot;</span></span><br><span class="line">    writeToFile:<span class="string">@&quot;/file.txt&quot;</span> atomically:<span class="literal">YES</span> encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>

<h1 id="什么是元级？"><a href="#什么是元级？" class="headerlink" title="什么是元级？"></a>什么是元级？</h1><p>现在，正如您可能已经知道的那样，Class 在Objective-C中也是一个对象。这意味着您可以发送消息给Class。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSStringEncoding</span> defaultStringEncoding = [<span class="built_in">NSString</span> defaultStringEncoding];</span><br></pre></td></tr></table></figure>
<p>在这种情况下，defaultStringEncoding被发送到NSString class。</p>
<p>这是有效的，因为Class 在Objective-C中的每个都是一个对象本身。这意味着Class结构必须以isa指针开头，以便它与objc_object上面显示的结构二进制兼容，并且结构中的下一个字段必须是指向superclass（或nil基类）的指针。</p>
<p>正如我上面所展示的那样Class，根据您运行的运行时版本，有几种不同的方式可以定义，但是，它们都以isa字段后跟字段开头superclass。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class super_class;</span><br><span class="line">    <span class="comment">/* followed by runtime specific details... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是，为了让我们调用类上的方法，类的isa指针本身必须指向一个类结构，而这个类结构必须包含我们可以在类上调用的方法列表。</p>
<p>这就引出了元类的定义:元类是类对象的类。</p>
<p>简单地说:</p>
<ul>
<li>当您向对象发送消息时，将在对象类的方法列表中查找该消息。</li>
<li>当您向类发送消息时，将在类的元类的方法列表中查找该消息。</li>
</ul>
<p>元类非常重要，因为它存储类的类方法。每个类必须有一个惟一的元类，因为每个类都有一个潜在惟一的类方法列表。</p>
<h1 id="元类的类是什么"><a href="#元类的类是什么" class="headerlink" title="元类的类是什么?"></a>元类的类是什么?</h1><p>与之前的类一样，元类也是一个对象。这意味着您也可以在其上调用方法。当然，这意味着它还必须有一个类。</p>
<p>所有元类都使用<code>基类的元类</code>(继承层次结构中顶层类的元类)作为<code>类</code>。这意味着对于从NSObject派生的所有类(大多数类)，<code>元类</code>都将<code>NSObject元类</code>作为其<code>类</code>。</p>
<p>遵循所有元类都使用基类的元类作为它们的类的规则，任何基元类都将是它自己的类(它们的isa指针指向它们自己)。这意味着NSObject元类上的isa指针指向它自己(它是它自己的一个实例)。</p>
<h1 id="类和元类的继承"><a href="#类和元类的继承" class="headerlink" title="类和元类的继承"></a>类和元类的继承</h1><p>就像类用它的超类指针指向超类一样，元类使用它自己的超类指针指向类的超类的元类。</p>
<p>更奇怪的是，<code>基类</code>的<code>元类</code>将其<code>超类</code>设置为<code>基类本身</code>。</p>
<p>这种继承层次结构的结果是，层次结构中的所有实例、类和元类都继承自层次结构的基类。</p>
<p>对于NSObject层次结构中的所有实例、类和元类，这意味着所有NSObject实例方法都是有效的。对于类和元类，所有NSObject类方法也是有效的。</p>
<p>所有这些在文本中都很混乱。Greg Parker将实例、类、元类和它们的超类以及它们是如何组合在一起的组成了一个很好的图表。</p>
<h1 id="这一点的实验证实"><a href="#这一点的实验证实" class="headerlink" title="这一点的实验证实"></a>这一点的实验证实</h1><p>为了确认这一切，让我们看看我在本文开头给出的ReportFunction的输出。这个函数的目的是跟踪isa指针并记录它所发现的内容。</p>
<p>要运行ReportFunction，我们需要创建动态创建的类的实例，并在其上调用report方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">id</span> instanceOfNewClass = [[newClass alloc] initWithDomain:<span class="string">@&quot;someDomain&quot;</span> code:<span class="number">0</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">[instanceOfNewClass performSelector:<span class="keyword">@selector</span>(report)];</span><br><span class="line">[instanceOfNewClass release];</span><br></pre></td></tr></table></figure>

<p>由于报表方法没有声明，所以我使用performSelector:调用它，因此编译器不会给出警告。</p>
<p>ReportFunction现在将遍历isa指针，并告诉我们使用哪些对象作为类、元类和元类的类。</p>
<blockquote>
<p>获取对象的类:ReportFunction使用object_getClass跟踪isa指针，因为isa指针是该类的受保护成员(您不能直接访问其他对象的isa指针)。ReportFunction不使用类方法来实现这一点，因为在类对象上调用类方法不会返回元类，而是再次返回类(因此[NSString类]将返回NSString类而不是NSString元类)。</p>
</blockquote>
<p>This is the output (minus NSLog prefixes) when the program runs:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">This object is <span class="number">0x10010c810</span>.</span><br><span class="line">Class is RuntimeErrorSubclass, and <span class="variable language_">super</span> is <span class="built_in">NSError</span>.</span><br><span class="line">Following the isa pointer <span class="number">1</span> times gives <span class="number">0x10010c600</span></span><br><span class="line">Following the isa pointer <span class="number">2</span> times gives <span class="number">0x10010c630</span></span><br><span class="line">Following the isa pointer <span class="number">3</span> times gives <span class="number">0x7fff71038480</span></span><br><span class="line">Following the isa pointer <span class="number">4</span> times gives <span class="number">0x7fff71038480</span></span><br><span class="line"><span class="built_in">NSObject</span><span class="string">&#x27;s class is 0x7fff71038490</span></span><br><span class="line"><span class="string">NSObject&#x27;</span>s meta <span class="keyword">class</span> is <span class="number">0x7fff71038480</span></span><br></pre></td></tr></table></figure>

<p>反复查看isa值所达到的地址:</p>
<ul>
<li>对象是地址0x10010c810。</li>
<li>类的地址是0x10010c600。</li>
<li>元类是地址0x10010c630。</li>
<li>元类的类(即NSObject元类)是地址0x7fff71038480。</li>
<li>NSObject元类的类是它自己。</li>
</ul>
<p>地址的值并不十分重要，除非它显示了从类到元类到NSObject元类的过程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>元类是类对象的类。每个类都有自己独特的元类(因为每个类都可以有自己独特的方法列表)。这意味着所有类对象本身并不都属于同一个类。</p>
<p>元类将始终确保类对象具有层次结构中基类的所有实例和类方法，以及中间的所有类方法。对于派生自NSObject的类，这意味着所有NSObject实例和协议方法都为所有类(和元类)对象定义。</p>
<p>所有元类本身都使用基类的元类(NSObject层次结构类的NSObject元类)作为类，包括运行时中惟一自定义的基类元类。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>源码学习</category>
        <category>元类是什么</category>
      </categories>
      <tags>
        <tag>iOS源码学习</tag>
        <tag>元类是什么</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS类的本质</title>
    <url>/iOS/origincode/origincodestudy.html</url>
    <content><![CDATA[<h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><p>class_data_bits_t bits 这是一个64位结构体，里面只有一个 uintptr_t bits,<br>在x86_64架构上，并且class_rw_t [2, 47]只占到了47位，如下</p>
<table>
<thead>
<tr>
<th>63</th>
<th>47</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>extra</td>
<td>class_rw_t data</td>
<td>requires raw_isa</td>
<td>has default_rr</td>
<td>is_swift</td>
</tr>
</tbody></table>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_IS_SWIFT           (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br></pre></td></tr></table></figure>
<p>在编译期间类的结构中的 <code>class_data_bits_t *data</code> 指向的是一个 <code>class_ro_t *</code> 指针：</p>
<ul>
<li>类在内存中的位置是在编译期间决定的，在之后修改代码，也不会改变内存中的位置。</li>
<li>类的方法、属性以及协议在编译期间存放到了“错误”的位置，直到 realizeClass 执行之后，才放到了 class_rw_t 指向的只读区域 class_ro_t，这样我们即可以在运行时为 class_rw_t 添加方法，也不会影响类的只读结构。</li>
<li>在 class_ro_t 中的属性在运行期间就不能改变了，再添加方法时，会修改 class_rw_t 中的 methods 列表，而不是 class_ro_t 中的 baseMethods，对于方法的添加会在之后的文章中分析。</li>
</ul>
<p>在 Objective-C 运行时 初始化的过程中会对其中的类进行第一次初始化也就是执行 realizeClass 方法，为类分配可读写结构体 class_rw_t 的空间，并返回正确的类结构体。</p>
<p>而 _class_initialize 方法会调用类的 initialize 方法，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="operator">!</span>cls-&gt;isRealized()) &#123;</span><br><span class="line">    rwlock_writer_t lock(runtimeLock);</span><br><span class="line">    realizeClass(cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (initialize  <span class="operator">&amp;&amp;</span>  <span class="operator">!</span>cls-&gt;isInitialized()) &#123;</span><br><span class="line">    _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考 <span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUvb2JqZWN0LWluaXQ=">对象是如何初始化的<i class="fa fa-external-link-alt"></i></span></p>
<h1 id="selector"><a href="#selector" class="headerlink" title="@selector()"></a>@selector()</h1><p>使用 @selector() 生成的选择子不会因为类的不同而改变，其内存地址在编译期间就已经确定了。也就是说向不同的类发送相同的消息时，其生成的选择子是完全相同的。</p>
<ul>
<li>Objective-C 为我们维护了一个巨大的选择子表</li>
<li>在使用 @selector() 时会从这个选择子表中根据选择子的名字查找对应的 SEL。如果没有找到，则会生成一个 SEL 并添加到表中</li>
<li>在编译期间会扫描全部的头文件和实现文件将其中的方法以及使用 @selector() 生成的选择子加入到选择子表中</li>
</ul>
<h1 id="objc-msgsend"><a href="#objc-msgsend" class="headerlink" title="objc_msgsend()"></a>objc_msgsend()</h1><p>Objective-C 中 objc_msgSend 的实现并没有开源，它只存在于 message.h 这个头文件中。</p>
<blockquote>
<p>当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个 objc_msgSend、objc_msgSend_stret、objc_msgSendSuper 和 objc_msgSendSuper_stret。 发送给对象的父类的消息会使用 objc_msgSendSuper 有数据结构作为返回值的方法会使用 objc_msgSendSuper_stret 或 objc_msgSend_stret 其它的消息都是使用 objc_msgSend 发送的</p>
</blockquote>
<p>objc_msgSend -&gt; _class_loopupMethodAndLocadCache3 -&gt; lookUpImpOrForward </p>
<p>对于 objc/objc-runtime-new.mm 中 lookupImpOrForward 的总结如下：</p>
<ul>
<li>无锁的缓存查找</li>
<li>如果类没有实现（isRealized）或者初始化（isInitialized），实现或者初始化类</li>
<li>加锁</li>
<li>缓存以及当前类中方法的查找</li>
<li>尝试查找父类的缓存以及方法列表</li>
<li>没有找到实现，尝试方法解析器</li>
<li>进行消息转发</li>
<li>解锁、返回实现</li>
</ul>
<blockquote>
<p>不过因为 _class_lookupMethodAndLoadCache3 传入的 cache = NO，所以这里会直接跳过 if 中代码的执行，在 objc_msgSend 中已经使用汇编代码查找过了。</p>
</blockquote>
<p>如果缓存没有命中 -&gt; 找到之后加入缓存 -&gt; 第二次调用的时候，就不会走lookupImpOrForward,而是汇编查找了缓存，</p>
<p>为了提高消息传递的效率，ObjC 对 objc_msgSend 以及  cache_getImp 使用了汇编语言来编写。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyYXZlbmVzcy9hbmFseXpl">看着看着来到了这里<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>源码学习</category>
        <category>类的本质</category>
      </categories>
      <tags>
        <tag>iOS源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>runtime</title>
    <url>/iOS/origincode/runtime.html</url>
    <content><![CDATA[<h1 id="先说类的本质"><a href="#先说类的本质" class="headerlink" title="先说类的本质"></a>先说类的本质</h1><p>我们都知道类的本质其实就是一个isa指针,我们直接看源码</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line"><span class="comment">//从这开始往下不用看了，都是方法</span></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ISA() assumes this is NOT a tagged pointer object</span></span><br><span class="line">    Class ISA();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getIsa() allows this to be a tagged pointer object</span></span><br><span class="line">    Class getIsa();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initIsa() should be used to init the isa of new objects only.</span></span><br><span class="line">    <span class="comment">// If this object already has an isa, use changeIsa() for correctness.</span></span><br><span class="line">    <span class="comment">// initInstanceIsa(): objects with no custom RR/AWZ</span></span><br><span class="line">    <span class="comment">// initClassIsa(): class objects</span></span><br><span class="line">    <span class="comment">// initProtocolIsa(): protocol objects</span></span><br><span class="line">    <span class="comment">// initIsa(): other objects</span></span><br><span class="line">    <span class="type">void</span> initIsa(Class cls <span class="comment">/*nonpointer=false*/</span>);</span><br><span class="line">    <span class="comment">//、、、下面的省略</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>isa_t 的isa又是什么？</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> isa_t &#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原来就是一个union共用体，包含cls, bits, ISA_BITFIELD, 我们展开ISA_BITFIELD看一下<br>在arm64结构下，</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="keyword">define</span> ISA_BITFIELD                                                      \</span></span><br><span class="line"><span class="meta">      uintptr_t nonpointer        : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t has_assoc         : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t has_cxx_dtor      : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t shiftcls          : 33; <span class="comment">/*MACH_VM_MAX_ADDRESS 0x1000000000*/</span> \</span></span><br><span class="line"><span class="meta">      uintptr_t magic             : 6;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t weakly_referenced : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t deallocating      : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t has_sidetable_rc  : 1;                                       \</span></span><br><span class="line"><span class="meta">      uintptr_t extra_rc          : 19</span></span><br></pre></td></tr></table></figure>
<p>加上注释吧：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// 0代表普通的指针，存储着Class，Meta-Class对象的内存地址。</span></span><br><span class="line">    <span class="comment">// 1代表优化后的使用位域存储更多的信息。</span></span><br><span class="line">    <span class="type">uintptr_t</span> nonpointer        : <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否有设置过关联对象，如果没有，释放时会更快</span></span><br><span class="line">    <span class="type">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有C++析构函数，如果没有，释放时会更快</span></span><br><span class="line">    <span class="type">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储着Class、Meta-Class对象的内存地址信息</span></span><br><span class="line">    <span class="type">uintptr_t</span> shiftcls          : <span class="number">33</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于在调试时分辨对象是否未完成初始化</span></span><br><span class="line">    <span class="type">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有被弱引用指向过。</span></span><br><span class="line">    <span class="type">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象是否正在释放</span></span><br><span class="line">    <span class="type">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数器是否过大无法存储在isa中</span></span><br><span class="line">    <span class="comment">// 如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</span></span><br><span class="line">    <span class="type">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 里面存储的值是引用计数器减1</span></span><br><span class="line">    <span class="type">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>cls的内存分布可以参考我的另外一片文章, <a href="./iOS/origincode/origincodestudy.html">类的本质</a> </p>
<p>看过我分类的本质也会发现，class_rw_t中的methods是二维数组的结构，并且可读可写，因此可以动态的添加方法，并且更加便于分类方法的添加。参考 category 源码可以发现，attachList函数内通过memmove 和 memcpy两个操作将分类的方法列表合并在本类的方法列表中。那么此时就将分类的方法和本类的方法统一整合到一起了。<br>其实一开始类的方法，属性，成员变量属性协议等等都是存放在class_ro_t中的，当程序运行的时候，需要将分类中的列表跟类初始的列表合并在一起的时，就会将class_ro_t中的列表和分类中的列表合并起来存放在class_rw_t中，也就是说class_rw_t中有部分列表是从class_ro_t里面拿出来的。</p>
<p>类的初始信息本来其实是存储在class_ro_t中的，并且ro本来是指向cls-&gt;data()的，也就是说bits.data()得到的是ro，但是在运行过程中创建了class_rw_t，并将cls-&gt;data指向rw，同时将初始信息ro赋值给rw中的ro。最后在通过setData(rw)设置data。那么此时bits.data()得到的就是rw，之后再去检查是否有分类，同时将分类的方法，属性，协议列表整合存储在class_rw_t的方法，属性及协议列表中。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>源码学习</category>
        <category>runtime</category>
      </categories>
      <tags>
        <tag>iOS源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS性能优化</title>
    <url>/iOS/performance/index.html</url>
    <content><![CDATA[<h2 id="如何提升-tableview-的流畅度？"><a href="#如何提升-tableview-的流畅度？" class="headerlink" title="如何提升 tableview 的流畅度？"></a>如何提升 <code>tableview</code> 的流畅度？</h2><p>本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。</p>
<ul>
<li>CPU：对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制</li>
<li>GPU：纹理的渲染</li>
</ul>
<h3 id="卡顿优化在-CPU-层面"><a href="#卡顿优化在-CPU-层面" class="headerlink" title="卡顿优化在 CPU 层面"></a>卡顿优化在 CPU 层面</h3><ul>
<li>尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView</li>
<li>不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改</li>
<li>尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性</li>
<li>Autolayout 会比直接设置 frame 消耗更多的 CPU 资源</li>
<li>图片的 size 最好刚好跟 UIImageView 的 size 保持一致</li>
<li>控制一下线程的最大并发数量</li>
<li>尽量把耗时的操作放到子线程<ul>
<li>文本处理（尺寸计算、绘制）</li>
<li>图片处理（解码、绘制）</li>
</ul>
</li>
</ul>
<h3 id="卡顿优化在-GPU层面"><a href="#卡顿优化在-GPU层面" class="headerlink" title="卡顿优化在 GPU层面"></a>卡顿优化在 GPU层面</h3><ul>
<li>尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示</li>
<li>GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸</li>
<li>尽量减少视图数量和层次</li>
<li>减少透明的视图（alpha&lt;1），不透明的就设置 opaque 为 YES</li>
<li>尽量避免出现离屏渲染</li>
</ul>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmliaXJlbWUuY29tLzIwMTUvMTEvMTIvc21vb3RoX3VzZXJfaW50ZXJmYWNlc19mb3JfaW9zLw==">iOS 保持界面流畅的技巧<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="1-预排版，提前计算"><a href="#1-预排版，提前计算" class="headerlink" title="1.预排版，提前计算"></a>1.预排版，提前计算</h4><p>在接收到服务端返回的数据后，尽量将 <code>CoreText</code> 排版的结果、单个控件的高度、<code>cell</code> 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。</p>
<p>尽量少用 <code>UILabel</code>，可以使用 <code>CALayer</code> 。避免使用 <code>AutoLayout</code> 的自动布局技术，采取纯代码的方式 </p>
<blockquote>
<p>Autolayout 是苹果本身提倡的技术，在大部分情况下也能很好的提升开发效率，但是 Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。具体数据可以看这个文章：<span class="exturl" data-url="aHR0cDovL3BpbGt5Lm1lLzM2LyVFMyU4MCU4Mg==">http://pilky.me/36/。<i class="fa fa-external-link-alt"></i></span> 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、<a href="./iOS/thirdpart/asdk.html">AsyncDisplayKit</a> 等框架。</p>
</blockquote>
<h4 id="2-预渲染，提前绘制"><a href="#2-预渲染，提前绘制" class="headerlink" title="2.预渲染，提前绘制"></a>2.预渲染，提前绘制</h4><p>例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了</p>
<p>避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。</p>
<h4 id="3-异步绘制"><a href="#3-异步绘制" class="headerlink" title="3.异步绘制"></a>3.异步绘制</h4><h4 id="4-全局并发线程"><a href="#4-全局并发线程" class="headerlink" title="4.全局并发线程"></a>4.全局并发线程</h4><h4 id="5-高效的图片异步加载"><a href="#5-高效的图片异步加载" class="headerlink" title="5.高效的图片异步加载"></a>5.高效的图片异步加载</h4><h2 id="如何有效降低-APP-包的大小？"><a href="#如何有效降低-APP-包的大小？" class="headerlink" title="如何有效降低 APP 包的大小？"></a>如何有效降低 <code>APP</code> 包的大小？</h2><p>降低包大小需要从两方面着手</p>
<h3 id="可执行文件"><a href="#可执行文件" class="headerlink" title="可执行文件"></a>可执行文件</h3><ul>
<li><p>编译器优化</p>
<ul>
<li>Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default 设置为 YES</li>
<li>去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为 NO， Other C Flags 添加 -fno-exceptions   </li>
</ul>
</li>
<li><p>利用 AppCode 检测未使用的代码：菜单栏 -&gt; Code -&gt; Inspect Code</p>
</li>
<li><p>编写LLVM插件检测出重复代码、未被调用的代码</p>
</li>
</ul>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><blockquote>
<p>资源包括 图片、音频、视频 等</p>
</blockquote>
<ul>
<li>优化的方式可以对资源进行无损的压缩</li>
<li>去除没有用到的资源： <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RpbnltaW5kL0xTVW51c2VkUmVzb3VyY2Vz">https://github.com/tinymind/LSUnusedResources<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h2><h3 id="1、重用和延迟加载-lazy-load-Views"><a href="#1、重用和延迟加载-lazy-load-Views" class="headerlink" title="1、重用和延迟加载(lazy load) Views"></a>1、重用和延迟加载(lazy load) Views</h3><ul>
<li>更多的view意味着更多的渲染，也就是更多的CPU和内存消耗，对于那种嵌套了很多view在UIScrollView里边的app更是如此。</li>
<li>这里我们用到的技巧就是模仿UITableView和UICollectionView的操作: 不要一次创建所有的subview，而是当需要时才创建，当它们完成了使命，把他们放进一个可重用的队列中。这样的话你就只需要在滚动发生时创建你的views，避免了不划算的内存分配。</li>
</ul>
<h3 id="2、Cache-Cache-还是Cache"><a href="#2、Cache-Cache-还是Cache" class="headerlink" title="2、Cache, Cache, 还是Cache!"></a>2、Cache, Cache, 还是Cache!</h3><ul>
<li>一个极好的原则就是，缓存所需要的，也就是那些不大可能改变但是需要经常读取的东西。</li>
<li>我们能缓存些什么呢？一些选项是，远端服务器的响应，图片，甚至计算结果，比如UITableView的行高。</li>
<li>NSCache和NSDictionary类似，不同的是系统回收内存的时候它会自动删掉它的内容。</li>
</ul>
<h3 id="3、权衡渲染方法-性能能还是要bundle保持合适的大小。"><a href="#3、权衡渲染方法-性能能还是要bundle保持合适的大小。" class="headerlink" title="3、权衡渲染方法.性能能还是要bundle保持合适的大小。"></a>3、权衡渲染方法.性能能还是要bundle保持合适的大小。</h3><h3 id="4、处理内存警告-移除对缓存，图片object和其他一些可以重创建的objects的strong-references"><a href="#4、处理内存警告-移除对缓存，图片object和其他一些可以重创建的objects的strong-references" class="headerlink" title="4、处理内存警告.移除对缓存，图片object和其他一些可以重创建的objects的strong references."></a>4、处理内存警告.移除对缓存，图片object和其他一些可以重创建的objects的strong references.</h3><h3 id="5、重用大开销对象"><a href="#5、重用大开销对象" class="headerlink" title="5、重用大开销对象"></a>5、重用大开销对象</h3><h3 id="6、一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。"><a href="#6、一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。" class="headerlink" title="6、一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。"></a>6、一些objects的初始化很慢，比如NSDateFormatter和NSCalendar。然而，你又不可避免地需要使用它们，比如从JSON或者XML中解析数据。想要避免使用这个对象的瓶颈你就需要重用他们，可以通过添加属性到你的class里或者创建静态变量来实现。</h3><h3 id="7、避免反复处理数据-在服务器端和客户端使用相同的数据结构很重要。"><a href="#7、避免反复处理数据-在服务器端和客户端使用相同的数据结构很重要。" class="headerlink" title="7、避免反复处理数据.在服务器端和客户端使用相同的数据结构很重要。"></a>7、避免反复处理数据.在服务器端和客户端使用相同的数据结构很重要。</h3><h3 id="8、选择正确的数据格式-解析JSON会比XML更快一些，JSON也通常更小更便于传输。从iOS5起有了官方内建的JSON-deserialization-就更加方便使用了。但是XML也有XML的好处，比如使用SAX-来解析XML就像解析本地文件一样，你不需像解析json一样等到整个文档下载完成才开始解析。当你处理很大的数据的时候就会极大地减低内存消耗和增加性能。"><a href="#8、选择正确的数据格式-解析JSON会比XML更快一些，JSON也通常更小更便于传输。从iOS5起有了官方内建的JSON-deserialization-就更加方便使用了。但是XML也有XML的好处，比如使用SAX-来解析XML就像解析本地文件一样，你不需像解析json一样等到整个文档下载完成才开始解析。当你处理很大的数据的时候就会极大地减低内存消耗和增加性能。" class="headerlink" title="8、选择正确的数据格式.解析JSON会比XML更快一些，JSON也通常更小更便于传输。从iOS5起有了官方内建的JSON deserialization 就更加方便使用了。但是XML也有XML的好处，比如使用SAX 来解析XML就像解析本地文件一样，你不需像解析json一样等到整个文档下载完成才开始解析。当你处理很大的数据的时候就会极大地减低内存消耗和增加性能。"></a>8、选择正确的数据格式.解析JSON会比XML更快一些，JSON也通常更小更便于传输。从iOS5起有了官方内建的JSON deserialization 就更加方便使用了。但是XML也有XML的好处，比如使用SAX 来解析XML就像解析本地文件一样，你不需像解析json一样等到整个文档下载完成才开始解析。当你处理很大的数据的时候就会极大地减低内存消耗和增加性能。</h3><h3 id="9、正确设定背景图片"><a href="#9、正确设定背景图片" class="headerlink" title="9、正确设定背景图片"></a>9、正确设定背景图片</h3><ul>
<li>全屏背景图，在view中添加一个UIImageView作为一个子View</li>
<li>只是某个小的view的背景图，你就需要用UIColor的colorWithPatternImage来做了，它会更快地渲染也不会花费很多内存：</li>
</ul>
<h3 id="10、减少使用Web特性。想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。注意你使用的图片，保证图片的符合你使用的大小。"><a href="#10、减少使用Web特性。想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。注意你使用的图片，保证图片的符合你使用的大小。" class="headerlink" title="10、减少使用Web特性。想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。注意你使用的图片，保证图片的符合你使用的大小。"></a>10、减少使用Web特性。想要更高的性能你就要调整下你的HTML了。第一件要做的事就是尽可能移除不必要的javascript，避免使用过大的框架。能只用原生js就更好了。尽可能异步加载例如用户行为统计script这种不影响页面表达的javascript。注意你使用的图片，保证图片的符合你使用的大小。</h3><h3 id="11、Shadow-Path-。CoreAnimation不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。使用shadowPath的话就避免了这个问题。使用shadow-path的话iOS就不必每次都计算如何渲染，它使用一个预先计算好的路径。但问题是自己计算path的话可能在某些View中比较困难，且每当view的frame变化的时候你都需要去update-shadow-path"><a href="#11、Shadow-Path-。CoreAnimation不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。使用shadowPath的话就避免了这个问题。使用shadow-path的话iOS就不必每次都计算如何渲染，它使用一个预先计算好的路径。但问题是自己计算path的话可能在某些View中比较困难，且每当view的frame变化的时候你都需要去update-shadow-path" class="headerlink" title="11、Shadow Path 。CoreAnimation不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。使用shadowPath的话就避免了这个问题。使用shadow path的话iOS就不必每次都计算如何渲染，它使用一个预先计算好的路径。但问题是自己计算path的话可能在某些View中比较困难，且每当view的frame变化的时候你都需要去update shadow path."></a>11、Shadow Path 。CoreAnimation不得不先在后台得出你的图形并加好阴影然后才渲染，这开销是很大的。使用shadowPath的话就避免了这个问题。使用shadow path的话iOS就不必每次都计算如何渲染，它使用一个预先计算好的路径。但问题是自己计算path的话可能在某些View中比较困难，且每当view的frame变化的时候你都需要去update shadow path.</h3><h3 id="12、优化Table-View"><a href="#12、优化Table-View" class="headerlink" title="12、优化Table View"></a>12、优化Table View</h3><ul>
<li>正确使用reuseIdentifier来重用cells</li>
<li>尽量使所有的view opaque，包括cell自身</li>
<li>避免渐变，图片缩放，后台选人</li>
<li>缓存行高</li>
<li>如果cell内现实的内容来自web，使用异步加载，缓存请求结果</li>
<li>使用shadowPath来画阴影</li>
<li>减少subviews的数量</li>
<li>尽量不适用cellForRowAtIndexPath:，如果你需要用到它，只用-一次然后缓存结果</li>
<li>使用正确的数据结构来存储数据</li>
<li>使用rowHeight, sectionFooterHeight 和 sectionHeaderHeight来设定固定的高，不要请求delegate</li>
</ul>
<h3 id="13、选择正确的数据存储选项"><a href="#13、选择正确的数据存储选项" class="headerlink" title="13、选择正确的数据存储选项"></a>13、选择正确的数据存储选项</h3><ul>
<li>NSUserDefaults的问题是什么？虽然它很nice也很便捷，但是它只适用于小数据，比如一些简单的布尔型的设置选项，再大点你就要考虑其它方式了</li>
<li>XML这种结构化档案呢？总体来说，你需要读取整个文件到内存里去解析，这样是很不经济的。使用SAX又是一个很麻烦的事情。</li>
<li>NSCoding？不幸的是，它也需要读写文件，所以也有以上问题。</li>
<li>在这种应用场景下，使用SQLite 或者 Core Data比较好。使用这些技术你用特定的查询语句就能只加载你需要的对象。</li>
<li>在性能层面来讲，SQLite和Core Data是很相似的。他们的不同在于具体使用方法。</li>
<li>Core Data代表一个对象的graph model，但SQLite就是一个DBMS。</li>
<li>Apple在一般情况下建议使用Core Data，但是如果你有理由不使用它，那么就去使用更加底层的SQLite吧。</li>
<li>如果你使用SQLite，你可以用FMDB这个库来简化SQLite的操作，这样你就不用花很多经历了解SQLite的C API了。</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS性能优化</category>
      </categories>
      <tags>
        <tag>iOS性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS检测卡顿/OOM</title>
    <url>/iOS/performance/kadun.html</url>
    <content><![CDATA[<h1 id="卡顿的发生通常有以下几个原因："><a href="#卡顿的发生通常有以下几个原因：" class="headerlink" title="卡顿的发生通常有以下几个原因："></a>卡顿的发生通常有以下几个原因：</h1><ul>
<li>UI过于复杂，图文混排的绘制量过大；</li>
<li>在主线程上进行同步的网络请求；</li>
<li>在主线程上进行大量的IO操作；</li>
<li>函数运算量过大，持续占用较高的CPU；</li>
<li>死锁和主子线程抢锁；</li>
</ul>
<h1 id="dump线程"><a href="#dump线程" class="headerlink" title="dump线程"></a>dump线程</h1><p>iOS 的线程技术与Mac OS X类似，也是基于 Mach 线程技术实现的，在 Mach 层中thread_basic_info 结构体封装了单个线程的基本信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_basic_info</span> &#123;</span></span><br><span class="line">    <span class="type">time_value_t</span>  user_time;      <span class="comment">/* user run time */</span></span><br><span class="line">    <span class="type">time_value_t</span>  system_time;    <span class="comment">/* system run time */</span></span><br><span class="line">    <span class="type">integer_t</span>    cpu_usage;       <span class="comment">/* scaled cpu usage percentage */</span></span><br><span class="line">    <span class="type">policy_t</span>     policy;          <span class="comment">/* scheduling policy in effect */</span></span><br><span class="line">    <span class="type">integer_t</span>    run_state;       <span class="comment">/* run state (see below) */</span></span><br><span class="line">    <span class="type">integer_t</span>    flags;           <span class="comment">/* various flags (see below) */</span></span><br><span class="line">    <span class="type">integer_t</span>    suspend_count;   <span class="comment">/* suspend count for thread */</span></span><br><span class="line">    <span class="type">integer_t</span>    sleep_time;      <span class="comment">/* number of seconds that thread  has been sleeping */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个Mach Task包含它的线程列表。内核提供了task_threads API 调用获取指定 task 的线程列表，然后可以通过thread_info API调用来查询指定线程的信息，在 thread_act.h 中有相关定义。</p>
<p>task_threads 将target_task 任务中的所有线程保存在act_list数组中，act_listCnt表示线程个数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">kern_return_t</span> <span class="title function_">task_threads</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">task_t</span> target_task,</span></span><br><span class="line"><span class="params">    <span class="type">thread_act_array_t</span> *act_list,</span></span><br><span class="line"><span class="params">    <span class="type">mach_msg_type_number_t</span> *act_listCnt</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>thread_info结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">kern_return_t</span> <span class="title function_">thread_info</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">thread_act_t</span> target_act,</span></span><br><span class="line"><span class="params">    <span class="type">thread_flavor_t</span> flavor,  <span class="comment">// 传入不同的宏定义获取不同的线程信息</span></span></span><br><span class="line"><span class="params">    <span class="type">thread_info_t</span> thread_info_out,  <span class="comment">// 查询到的线程信息</span></span></span><br><span class="line"><span class="params">    <span class="type">mach_msg_type_number_t</span> *thread_info_outCnt  <span class="comment">// 信息的大小</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>所以我们如下来获取CPU的占有率：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&quot;LSLCpuUsage.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;mach/task.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;mach/vm_map.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;mach/mach_init.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;mach/thread_act.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;mach/thread_info.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">@implementation LSLCpuUsage</span><br><span class="line"></span><br><span class="line">+ (<span class="type">double</span>)getCpuUsage &#123;</span><br><span class="line">    <span class="type">kern_return_t</span>           kr;</span><br><span class="line">    <span class="type">thread_array_t</span>          threadList;         <span class="comment">// 保存当前Mach task的线程列表</span></span><br><span class="line">    <span class="type">mach_msg_type_number_t</span>  threadCount;        <span class="comment">// 保存当前Mach task的线程个数</span></span><br><span class="line">    <span class="type">thread_info_data_t</span>      threadInfo;         <span class="comment">// 保存单个线程的信息列表</span></span><br><span class="line">    <span class="type">mach_msg_type_number_t</span>  threadInfoCount;    <span class="comment">// 保存当前线程的信息列表大小</span></span><br><span class="line">    <span class="type">thread_basic_info_t</span>     threadBasicInfo;    <span class="comment">// 线程的基本信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过“task_threads”API调用获取指定 task 的线程列表</span></span><br><span class="line">    <span class="comment">//  mach_task_self_，表示获取当前的 Mach task</span></span><br><span class="line">    kr = task_threads(mach_task_self(), &amp;threadList, &amp;threadCount);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> cpuUsage = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">        threadInfoCount = THREAD_INFO_MAX;</span><br><span class="line">        <span class="comment">// 通过“thread_info”API调用来查询指定线程的信息</span></span><br><span class="line">        <span class="comment">//  flavor参数传的是THREAD_BASIC_INFO，使用这个类型会返回线程的基本信息，</span></span><br><span class="line">        <span class="comment">//  定义在 thread_basic_info_t 结构体，包含了用户和系统的运行时间、运行状态和调度优先级等</span></span><br><span class="line">        kr = thread_info(threadList[i], THREAD_BASIC_INFO, (<span class="type">thread_info_t</span>)threadInfo, &amp;threadInfoCount);</span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        threadBasicInfo = (<span class="type">thread_basic_info_t</span>)threadInfo;</span><br><span class="line">        <span class="keyword">if</span> (!(threadBasicInfo-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">            cpuUsage += threadBasicInfo-&gt;cpu_usage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回收内存，防止内存泄漏</span></span><br><span class="line">    vm_deallocate(mach_task_self(), (<span class="type">vm_offset_t</span>)threadList, threadCount * <span class="keyword">sizeof</span>(<span class="type">thread_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cpuUsage / (<span class="type">double</span>)TH_USAGE_SCALE * <span class="number">100.0</span>;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>


<p>博主文中提到：关于 phys_footprint 的定义可以在 XNU 源码中，找到 osfmk/kern/task.c 里对于 phys_footprint 的注释，博主认为注释里提到的公式计算的应该才是应用实际使用的物理内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * phys_footprint</span></span><br><span class="line"><span class="comment"> *   Physical footprint: This is the sum of:</span></span><br><span class="line"><span class="comment"> *     + (internal - alternate_accounting)</span></span><br><span class="line"><span class="comment"> *     + (internal_compressed - alternate_accounting_compressed)</span></span><br><span class="line"><span class="comment"> *     + iokit_mapped</span></span><br><span class="line"><span class="comment"> *     + purgeable_nonvolatile</span></span><br><span class="line"><span class="comment"> *     + purgeable_nonvolatile_compressed</span></span><br><span class="line"><span class="comment"> *     + page_table</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * internal</span></span><br><span class="line"><span class="comment"> *   The task&#x27;s anonymous memory, which on iOS is always resident.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * internal_compressed</span></span><br><span class="line"><span class="comment"> *   Amount of this task&#x27;s internal memory which is held by the compressor.</span></span><br><span class="line"><span class="comment"> *   Such memory is no longer actually resident for the task [i.e., resident in its pmap],</span></span><br><span class="line"><span class="comment"> *   and could be either decompressed back into memory, or paged out to storage, depending</span></span><br><span class="line"><span class="comment"> *   on our implementation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * iokit_mapped</span></span><br><span class="line"><span class="comment"> *   IOKit mappings: The total size of all IOKit mappings in this task, regardless of</span></span><br><span class="line"><span class="comment">     clean/dirty or internal/external state].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * alternate_accounting</span></span><br><span class="line"><span class="comment"> *   The number of internal dirty pages which are part of IOKit mappings. By definition, these pages</span></span><br><span class="line"><span class="comment"> *   are counted in both internal *and* iokit_mapped, so we must subtract them from the total to avoid</span></span><br><span class="line"><span class="comment"> *   double counting.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="如何判断发生了OOM"><a href="#如何判断发生了OOM" class="headerlink" title="如何判断发生了OOM"></a>如何判断发生了OOM</h1><img src="/images/general/breakpad-rifle.jpeg" class="" title="breakpad流程">


<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><ul>
<li>oom instsrument测试工具</li>
<li>开发过程检测泄露</li>
<li>大对象， 图片等资源的缓存  </li>
<li>hook  alloc dealloc</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly9lbmdpbmVlcmluZy5mYi5jb20vMjAxNS8wOC8yNC9pb3MvcmVkdWNpbmctZm9vbXMtaW4tdGhlLWZhY2Vib29rLWlvcy1hcHAv">https://engineering.fb.com/2015/08/24/ios/reducing-fooms-in-the-facebook-ios-app/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>性能</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>Runloop</tag>
        <tag>卡顿</tag>
      </tags>
  </entry>
  <entry>
    <title>组件化</title>
    <url>/iOS/performance/modularization.html</url>
    <content><![CDATA[<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>由于我们的工程代码越来越多，文件原来越多，编译速度直线下降，工作效率直线下降，甚至会影响情绪（误 ）</p>
<p>所以计划将所有pod进行静态库构建，这样编译的时候就不会再重编了，再加上我们组件化也在持续推进，最终可能只需要编我修改的库就行了（理想状态）</p>
<h2 id="静态库构建"><a href="#静态库构建" class="headerlink" title="静态库构建"></a>静态库构建</h2><ol>
<li>静态库构建最初方案与尝试<br>最初指定的方案是在pod更新的时候进行打包，基于cocoapods-packager(后简称为packager)进行魔改。魔改后packger整体的方案是传入Podfile，在指定位置重新创建工程，根据Podfile与依赖进行libtool编译(动态库是使用xcodebuild，但我们不用动态库)，然后将编译好的静态库拷贝出来。为什么要传入Podfile呢，在之前的packager是使用podspec进行工程生成，这会导致生成的静态库所依赖的其他pod版本号会和主工程中的Podfile对不上。所以我们需要维护一个和主工程Podfile相同版本号的Podfile（是不是有点绕）</li>
</ol>
<p>其实packger内部也是使用Podspec生成Podfile的，我们只是做了直接传入Podfile，省去了生成的步骤。原理很简单，但实现还是需要摸索了一段时间。在扒了cocoapods源码后，发现cocoapods对Podfile对象提供了一个from_ruby的方法，这使得我们可以直接使用Podfile ruby文件就可以获取一个Podfile对象，但我们还需要对Podfile进行一些修改。我们将Podfile转化为yaml，然后将库中Podfile写的../ ./ 这种相对路径修改为工程地址（这是因为使用相对路径会导致生成的工程引用的代码文件不会被拷贝到工程下，源码调试会有问题），关闭uses_frameworks。</p>
<p>我们对packger还做了一些其他的修改。使用Podfile；修改生成工程的地址；对生成的工程<code>Build Setting中的GCC_GENERATE_DEBUGGING_SYMBOLS</code>打开（后面会介绍这个字段是干什么用的）；修改了编译架构，只保留了arm64；修改了一些默认参数；增加了将生成的工程拷贝出来的参数；</p>
<p>这个魔改后的cocoapods plugin会镶嵌在自动更新pod脚本当中，使用的时候会询问是否要构建静态库。</p>
<p>但这个方案有两个问题，首先是需要维护一个和主工程版本号相同的Podfile比较麻烦，第二个是当依赖的库有变动的时候这个库的静态库也需要重新构建（包括依赖的依赖的依赖… 老套娃了）。这个其实可以通过分析Podfile.lock文件来寻找影响的所有库，但未免有些麻烦了。</p>
<ol start="2">
<li>最终方案<br>​我们既然不想维护一份单独的Podfile的话，那我们直接使用主工程不就好了吗？</li>
</ol>
<p>所以最终我们选择了使用主工程编译后的产物来当做我们使用的静态库。</p>
<p>我们在工程内使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcodebuild CONFIGURATION_BUILD_DIR=&quot;#&#123;library_path&#125;&quot; clean build -configuration Debug -scheme Pods-XXX -workspace &quot;#&#123;project_path&#125;/XXX.xcworkspace&quot; -arch arm64 -sdk iphoneos</span><br></pre></td></tr></table></figure>

<ul>
<li>在 library_path 的位置生成所有静态库与bundle。这是我们的主体思路。</li>
<li>在library_pods.json填入我们需要更新的库名（所有库名在工程pod update时候会在工程文件夹中生成一个current_mmpods.json当中）。</li>
<li>分析 ~/.cocoapods/repos 中都有什么repo，获取repo的Git地址。</li>
<li>分析Podfile.lock获取Pod都在那个repo中、版本号、是否被当成subspec引入。</li>
<li>使用xcodebuild构建。</li>
<li>遍历library_pods.json。<ul>
<li>从工程中拷贝源码。</li>
<li>拷贝构建完成的静态库。</li>
<li>从bundle中拷贝metalllib（.metal文件特有）生成对应的bundle。</li>
<li>拷贝Podfile.lock（为了查询是什么情况下构建的静态库）。</li>
<li>repo中拷贝Podspec。</li>
<li>如果Podspec没有被转化为json，就把它转成json。</li>
<li>处理Podspec<ul>
<li>将静态库加入vendored_libraries。</li>
<li>将源码路径加入Podfile（稍后讲到源码调试的时候会讲）。</li>
<li>将使用的subspec中的一些字段比如source_files加入到最外面，这里是因为如果工程只引入了subspec的话，外层的对应字段会失效。</li>
</ul>
</li>
<li>将bundle路径加入到resources。</li>
</ul>
</li>
<li>构建源码的zip。</li>
<li>构建完整的zip（包含源码zip）。</li>
<li>上传完整的zip（这里踩了很多坑我们稍后再说）。</li>
<li>提交Podspec至对应的静态库单独的repo仓库中。</li>
</ul>
<p>好了，至此我们已经成功构建了一个使用静态库的Pod版本，版本号为为当前版本号.a.debug eg 1.0.0.a.debug。</p>
<p>我们每个版本之后进行统一回扫也不会存在有某些依赖的库更新上层库没更新的问题了。</p>
<h2 id="源码调试"><a href="#源码调试" class="headerlink" title="源码调试"></a>源码调试</h2><p><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTkvMDgvMDgvdGhlLXRoaW5ncy1iZWhpbmQtdGhlLWlvcy1wcm9qZWN0LXpzb3VyY2UtY29tbWFuZC5odG1s">https://tech.meituan.com/2019/08/08/the-things-behind-the-ios-project-zsource-command.html<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>源码调试原理与过程<br>切换完静态库之后直接带来了一个问题就是大家无法看到源码，没办法根据crash寻找代码，没法打断点了。</li>
</ol>
<p>​为了解决这个问题，我们查阅了资料发现使用dwarfdump可以分析出静态库中AT_comp_dir的这个字段，AT_comp_dir代表编译地址，只要源码在这个位置，xcode就会根据它去寻找代码，当然了只是显示，编译还是使用静态库来编译的。（前文说的GCC_GENERATE_DEBUGGING_SYMBOLS就是为了生成这个字段用的，不过我们统一构建后就不需要再去用脚本设置了。）</p>
<p>​换句话说就是只要我们其他电脑上在当时构建静态库的源码路径上还是有源代码的，xcode就可以自动寻找到代码并显示。不过在我们尝试了软链接、硬链接和文件拷贝后，软链接和硬链接都有相应的问题（找不到源码或者无法进行断点调试）。最终我们还是选择了文件拷贝（又为大家岌岌可危的硬盘空间火上浇油了，不过没有很大啦。）</p>
<p>​现在问题来了我们需要找到一个大家都有的且有权限的路径下面进行静态库构建在经过大量尝试之后我们选择了 /private/var/folders/cocoapods/MOMO_iOS_Binary 这个路径来进行构建所以打包机上的工程师在这个路径下面的。</p>
<p>同时我们也支持的在工程中直接对源码进行断点，这个我们等下再说。</p>
<p>我们先来介绍一下我们为此做了什么工作：</p>
<ul>
<li>上文提到的源码zip就是为了一起打到zip包中方便我们pod update的时候获取源码的（考虑到再去下载可能会更麻烦）。</li>
<li>需要把源码的zip包 xxx.binary 加入到podspec的Podfile字段中，否则update后工程中是没有它的。</li>
<li>在我们进行pod update的时候使用Podfile提供的hook pre_install(在cocoapods拷贝文件完成之后)调用解压脚本将我们所有存在 xxx.binaryzip的文件全部解压到指定路径也就是编译时候的的路径。</li>
<li>然后使用Podfile的另外一个hook post_integrate (在Integrating client project之后)（v1.10版本才提供，当前可调用工程/Binary/handle_add_source_file_to_project.sh）。<br>这个路径其实可以通过dwarfdump来获取，但是执行的有点慢，不过我们都自己制定了路径了，那不如还是把路径写死吧！</li>
</ul>
<blockquote>
<p>dwarfdump xxx | grep “AT_comp_dir” | head -1 | cut -d \“ -f2 </p>
</blockquote>
<p>这一步我们分析了xcodeproj文件，可以将目标路径的整个文件夹当成一个Group加入到我们在Pod的xcodeproj文件中的SourceCode路径下。这些文件是不会被编译的，因为没有被加入到Build Phases中。</p>
<p>至此，我们就可以在工程目录中看到源码，可以直接打断点，当crash或者assert时也会直接跳转到对应位置啦（如果不是为了看源码，其实可以不操作第四步的）。</p>
<ol start="2">
<li>我有多个工程对应不同的源码版本怎么办呢？<br>首先我们先重申一个概念，只要静态库中的AT_comp_dir对应的地方有源码，xcode会自动找到代码。<br>最初我们的做法是不管什么版本的代码，只要是同名pod都会在默认的位置进行编译，如 Pods/AFNetworking。<br>这样对于我们只有一个工程的情况确实没问题。但众所周知，大家的电脑里最少都有两个以上的工程副本。当处于不同的分支的时候有可能同一pod对应的就是不同的版本。这就会出现，我并不信任我当前调试的代码是不是和我当前的pod版本所对应。</li>
</ol>
<p>我们为了解决这个问题，分为编译和解压两个部分。</p>
<p>编译<br>首先在打包的时候根据版本在不同的文件路径下编译。是不是有点没看懂，我先举个例子。假如我现在要给<br>AFNetworking,’1.0’版本进行静态库构建，它的原始代码路径为’工程/Pods/AFNetworking/xxx’。我们只需要把它改为工程/Pods/AFNetworking/1.0/xxx，这样在不同版本的情况下打包不就可以区分了吗？我们最终采用的是软链接，在’工程/Pods/AFNetworking/‘中创建一个名为1.0的软链接，链接’工程/Pods/AFNetworking/‘，这里有点绕，就是在目录下创建了一个指向自己的软链接，类似祖传套娃。</p>
<p>然后我们还需要修改project的group path,不改的话还是使用原来的路径编译。还是用AFNetworking来举例。原始的project group为</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span>F144D000000D0 <span class="regexp">/* AFNetworking */</span> = &#123;</span><br><span class="line">			isa = PBXGroup;</span><br><span class="line">			children = (</span><br><span class="line">				<span class="number">9</span>F144D00000100 <span class="regexp">/* AFNetworking.h */</span>,</span><br><span class="line">				<span class="number">9</span>F144D000000E0 <span class="regexp">/* AFURLRequestSerialization.h */</span>,</span><br><span class="line">				<span class="number">9</span>F144D000000F0 <span class="regexp">/* AFURLResponseSerialization.h */</span>,</span><br><span class="line">				<span class="number">9</span>F144D00000250 <span class="regexp">/* Frameworks */</span>,</span><br><span class="line">				<span class="number">9</span>F144D00000110 <span class="regexp">/* NSURLSession */</span>,</span><br><span class="line">				<span class="number">9</span>F144D00000150 <span class="regexp">/* Reachability */</span>,</span><br><span class="line">				<span class="number">9</span>F144D00000170 <span class="regexp">/* Security */</span>,</span><br><span class="line">				<span class="number">9</span>F144D00000190 <span class="regexp">/* Serialization */</span>,</span><br><span class="line">				<span class="number">9</span>F144D000002D0 <span class="regexp">/* Support Files */</span>,</span><br><span class="line">				<span class="number">9</span>F144D000001A0 <span class="regexp">/* UIKit */</span>,</span><br><span class="line">			);</span><br><span class="line">			name = AFNetworking;</span><br><span class="line">			path = AFNetworking;</span><br><span class="line">			sourceTree = <span class="string">&quot;&lt;group&gt;&quot;</span>;</span><br><span class="line">		&#125;;</span><br></pre></td></tr></table></figure>
<p>我们需要把path修改为AFNetworking/1.0，然后就会发现编译不过了。因为有一个地方有些问题</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span>F144D000002D0 <span class="regexp">/* Support Files */</span> = &#123;</span><br><span class="line">			isa = PBXGroup;</span><br><span class="line">			children = (</span><br><span class="line">				<span class="number">9</span>F144D000002E0 <span class="regexp">/* AFNetworking.debug.xcconfig */</span>,</span><br><span class="line">				<span class="number">9</span>F144D000002F0 <span class="regexp">/* AFNetworking.release.xcconfig */</span>,</span><br><span class="line">			);</span><br><span class="line">			name = <span class="string">&quot;Support Files&quot;</span>;</span><br><span class="line">			path = <span class="string">&quot;../Target Support Files/AFNetworking&quot;</span>;</span><br><span class="line">			sourceTree = <span class="string">&quot;&lt;group&gt;&quot;</span>;</span><br><span class="line">		&#125;;</span><br></pre></td></tr></table></figure>
<p>发现问题所在了没？Support Files的path使用的是相对路径，因为我们相当于在上面多建立了一层文件结构所以这里要改为</p>
<ul>
<li>path = “../../Target Support Files/AFNetworking”;<br>以上修改完成之后就可以进行编译了。</li>
</ul>
<p>解压<br>解压就比较简明易懂了，就是解压到和编译时相同的路径就可以了。这样我们就可以同时存在不同版本的代码了！</p>
<h2 id="源码与静态库切换"><a href="#源码与静态库切换" class="headerlink" title="源码与静态库切换"></a>源码与静态库切换</h2><p>先判断是否有二进制 git cat-file -e origin/master:#{first_name}/#{version + library_version_suffix}/#{first_name}.podspec.json</p>
<h2 id="大文件存储"><a href="#大文件存储" class="headerlink" title="大文件存储"></a>大文件存储</h2><p>现在流程都跑通的，但我们每个版本都会构建新的静态库，那么我们的git仓库岂不是爆炸了吗？</p>
<p>我们最初有讨论将所有.a文件忽略掉，但这需要每次拉代码后进行一次pod update将静态库拉回来，有些麻烦。</p>
<p>经过调研和验证后我们选择了Git提供的Git LFS进行大文件存储，它实质上是讲所有文件传到Git LFS的仓库中而不是我们的工程仓库，在我们的工程仓库中会有一个类似指针的文件指向Git LFS仓库中的文件，所以我们仓库不会变大（理论上是会变大因为有一个指针文件）。当我们进行git pull的时候同时会进行git lfs pull将文件下载下来，这样解决了我们大文件存储的问题。</p>
<p>具体就是在.gitattribute中将*.a加入到Git LFS中。同时我们也加入了*.binaryzip</p>
<p>其实理论上可以进行工程回扫，将之前的所有commit都进行重建，这样我们的仓库就会从现在的十几个G减少到3个G左右，但需要SA配合，我们的电脑向Git服务器推因为过大，有三万多个commit，会在传输完成后被Git服务器中断连接，所以目前还没搞。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>Q：Podfile.lock是一个什么样的文件</p>
<p>A：Podfile.lock实际上是一个yaml文件，类似于json</p>
<p>Q：lottie-ios为什么没有切为静态库</p>
<p>A：有些库在spec中dependency这个库的时候限制了版本号 ~&gt; 2.0，但cocoapods没有识别 2.0.a.debug 为2.x版本内</p>
<p>Q：ReactiveCocoa为什么和其他切换静态库的方式不一样</p>
<p>A：我们自动打出来的静态库，头文件会被增加RAC前缀，导致文件找不到。于是用单一构建的方式来构建了一版。</p>
<p>Q：为啥Jenkins打带有Git-LFS的包会报错？</p>
<p>A：因为Jenkins寻找的路径是xcode的目录，我们需要把Git-LFS拷贝到xcode目录中</p>
<p>cp $(which git-lfs) /Applications/Xcode.app/Contents/Developer/usr/libexec/git-core</p>
<h2 id="启动速度优化"><a href="#启动速度优化" class="headerlink" title="启动速度优化"></a>启动速度优化</h2><ul>
<li>静态库</li>
<li>二进制重排，clang插桩 </li>
</ul>
<p>Total pre-main time: 1.2 seconds (100.0%)<br>         dylib loading time: 567.72 milliseconds (45.5%)<br>        rebase/binding time: 105.14 milliseconds (8.4%)<br>            ObjC setup time:  40.01 milliseconds (3.2%)<br>           initializer time: 532.47 milliseconds (42.7%)<br>           slowest intializers :<br>             libSystem.B.dylib :   4.70 milliseconds (0.3%)<br>          libglInterpose.dylib : 295.89 milliseconds (23.7%)<br>                  AFNetworking :  48.75 milliseconds (3.9%)<br>                         Oasis : 285.94 milliseconds (22.9%)</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTkvMDgvMDgvdGhlLXRoaW5ncy1iZWhpbmQtdGhlLWlvcy1wcm9qZWN0LXpzb3VyY2UtY29tbWFuZC5odG1s">https://tech.meituan.com/2019/08/08/the-things-behind-the-ios-project-zsource-command.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>performance</title>
    <url>/iOS/performance/performance.html</url>
    <content><![CDATA[<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><h2 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h2><h2 id="电量优化"><a href="#电量优化" class="headerlink" title="电量优化"></a>电量优化</h2><h2 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h2><h2 id="体积优化"><a href="#体积优化" class="headerlink" title="体积优化"></a>体积优化</h2><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2><h2 id="APM"><a href="#APM" class="headerlink" title="APM"></a>APM</h2><h2 id="调试-amp-Crash"><a href="#调试-amp-Crash" class="headerlink" title="调试 &amp; Crash"></a>调试 &amp; Crash</h2><p>收集中</p>
<h1 id="性能优化-1"><a href="#性能优化-1" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="性能优化，架构先行"><a href="#性能优化，架构先行" class="headerlink" title="性能优化，架构先行"></a>性能优化，架构先行</h2><ul>
<li>组件化 <ul>
<li>共享基础设施</li>
<li>下沉公共服务</li>
<li>隔离业务模块</li>
</ul>
</li>
<li>标准化<ul>
<li>统一的基础服务</li>
<li>统一的应用框架</li>
<li>统一的开发范式</li>
<li>统一的用户体验</li>
</ul>
</li>
</ul>
<h2 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h2><ul>
<li>共享公共服务，业务统一模板，降低项目复杂度</li>
<li>代码复用率 0 -&gt; 80%</li>
<li>线上性能问题种类，减少3倍以上</li>
<li>Crash率，减少3倍以上</li>
</ul>
<h2 id="端上性能监控"><a href="#端上性能监控" class="headerlink" title="端上性能监控"></a>端上性能监控</h2><ul>
<li>可用性<ul>
<li>Crash</li>
<li>Abort</li>
<li>业务异常</li>
</ul>
</li>
<li>基础性能<ul>
<li>启动时间</li>
<li>包体积</li>
</ul>
</li>
<li>流畅性<ul>
<li>页面测速</li>
<li>卡炖检测</li>
<li>关键路径</li>
<li>渲染检测</li>
</ul>
</li>
<li>资源消耗<ul>
<li>CPU</li>
<li>内存</li>
<li>流量</li>
<li>储存<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2></li>
</ul>
</li>
<li>服务端开关</li>
<li>热修复</li>
<li>新版本</li>
</ul>
<h2 id="验证效果，AB实验"><a href="#验证效果，AB实验" class="headerlink" title="验证效果，AB实验"></a>验证效果，AB实验</h2><h2 id="网络优化-1"><a href="#网络优化-1" class="headerlink" title="网络优化"></a>网络优化</h2><p>利用http2.0 </p>
<ul>
<li>多路复用；二进制分桢；头部压缩；服务端推送</li>
<li>页面加载时间缩短 ~7.5%</li>
<li>数据</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhbmdrZWppZS9pT1MtUGVyZm9ybWFuY2UtT3B0aW1pemF0aW9u">汇总<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9pbWFnZXMuYXBwbGUuY29tL21lZGlhL3VzL29zeC8yMDEzL2RvY3MvT1NYX01hdmVyaWNrc19Db3JlX1RlY2hub2xvZ3lfT3ZlcnZpZXcucGRm">https://images.apple.com/media/us/osx/2013/docs/OSX_Mavericks_Core_Technology_Overview.pdf<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>野指针</title>
    <url>/iOS/performance/wildpoint.html</url>
    <content><![CDATA[<h1 id="先看我画的一张图"><a href="#先看我画的一张图" class="headerlink" title="先看我画的一张图"></a>先看我画的一张图</h1><img src="/images/iOS/wildpoint.png" class="" title="˙野指针">

<h1 id="野指针探测实现1"><a href="#野指针探测实现1" class="headerlink" title="野指针探测实现1"></a>野指针探测实现1</h1><p>1、通过fishhook替换C函数的free方法为自定义的safe_free，类似于Method Swizzling<br>2、在safe_free方法中对已经释放变量的内存，填充0x55，使已经释放变量不能访问，从而使某些野指针的crash从不必现安变成必现。</p>
<ul>
<li>为了防止填充0x55的内存被新的数据内容填充，使野指针crash变成不必现，在这里采用的策略是，safe_free不释放这片内存，而是自己保留着，即safe_free方法中不会真的调用free。</li>
<li>同时为了防止系统内存过快消耗（因为要保留内存），需要在保留的内存大于一定值时释放一部分，防止被系统杀死，同时，在收到系统内存警告时，也需要释放一部分内存</li>
</ul>
<p>3、发生crash时，得到的崩溃信息有限，不利于问题排查，所以这里采用代理类（即继承自NSProxy的子类），重写消息转发的三个方法，以及NSObject的实例方法，来获取异常信息。但是这的话，还有一个问题，就是NSProxy只能做OC对象的代理，所以需要在safe_free中增加对象类型的判断</p>
<h1 id="Zombie-Objects"><a href="#Zombie-Objects" class="headerlink" title="Zombie Objects"></a>Zombie Objects</h1><p>僵尸对象</p>
<p>可以用来检测内存错误（EXC_BAD_ACCESS），它可以捕获任何阐释访问坏内存的调用<br>给僵尸对象发送消息的话，它仍然是可以响应的，然后会发生崩溃，并输出错误日志来显示野指针对象调用的类名和方法</p>
<p>苹果的僵尸对象检测原理<br>从dealloc的源码中，我们可以看到“Replaced by NSZombie”，即对象释放时， NSZombie 将在 dealloc 里做替换，如下所示<br>所以僵尸对象的生成过程伪代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、获取到即将deallocted对象所属类（Class）</span></span><br><span class="line">Class cls = object_getClass(self);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、获取类名</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *clsName = class_getName(cls)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、生成僵尸对象类名</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *zombieClsName = <span class="string">&quot;_NSZombie_&quot;</span> + clsName;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、查看是否存在相同的僵尸对象类名，不存在则创建</span></span><br><span class="line">Class zombieCls = objc_lookUpClass(zombieClsName);</span><br><span class="line"><span class="keyword">if</span> (!zombieCls) &#123;</span><br><span class="line">     <span class="comment">//5、获取僵尸对象类 _NSZombie_</span></span><br><span class="line"> Class baseZombieCls = objc_lookUpClass(“_NSZombie_<span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     //6、创建 zombieClsName 类</span></span><br><span class="line"><span class="string"> zombieCls = objc_duplicateClass(baseZombieCls, zombieClsName, 0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">//7、在对象内存未被释放的情况下销毁对象的成员变量及关联引用。</span></span><br><span class="line"><span class="string">   objc_destructInstance(self);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//8、修改对象的 isa 指针，令其指向特殊的僵尸类</span></span><br><span class="line"><span class="string">objc_setClass(self, zombieCls);</span></span><br></pre></td></tr></table></figure>

<h1 id="野指针探测实现2"><a href="#野指针探测实现2" class="headerlink" title="野指针探测实现2"></a>野指针探测实现2</h1><p>野指针检测流程<br>1、开启野指针检测<br>2、设置监控到野指针时的回调block，在block中打印信息，或者存储堆栈<br>3、检测到野指针是否crash<br>4、最大内存占用空间<br>5、是否记录dealloc调用栈<br>6、监控策略<br>    1）只监控自定义对象<br>    2）白名单策略<br>    3）黑名单策略<br>4）监控所有对象<br>7、交换NSObject的dealloc方法</p>
<p>触发野指针<br>1、开始处理对象<br>2、是否达到替换条件<br>    1）根据监控策略，是否属于要检测的类<br>    2）空间是否足够<br>    3、如果符合条件，则获取对象，并解除引用，如果不符合则正常释放，即调用原来的dealloc方法<br>4、向对象内填充数据<br>5、赋值僵尸对象的类指针替换isa<br>6、对象+dealloc调用栈，保存在僵尸对象中<br>7、根据情况是否清理内存和对象</p>
<p>通过僵尸对象检测的实现思路<br>1、通过OC中Mehod Swizzling，交换根类NSObject和NSProxy的dealloc方法为自定义的dealloc方法<br>2、为了避免内存空间释放后被重写造成野指针的问题，通过字典存储被释放的对象，同时设置在30s后调用dealloc方法将字典中存储的对象释放，避免内存增大<br>3、为了获取更多的崩溃信息，这里同样需要创建NSProxy的子类</p>
<p>具体实现</p>
<p>1、创建NSProxy的子类<br>2、hook dealloc函数的具体实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MIZombieSniffer</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> *  @method installSniffer</span></span><br><span class="line"><span class="comment"> *  启动zombie检测</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="type">void</span>)installSniffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> *  @method uninstallSnifier</span></span><br><span class="line"><span class="comment"> *  停止zombie检测</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="type">void</span>)uninstallSnifier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> *  @method appendIgnoreClass</span></span><br><span class="line"><span class="comment"> *  添加白名单类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="type">void</span>)appendIgnoreClass: (Class)cls;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">&lt;!-<span class="number">-2</span>、MIZombieSniffer.m--&gt;</span><br><span class="line"><span class="meta">#import <span class="string">&quot;MIZombieSniffer.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;MIZombieProxy.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (*MIDeallocPointer) (<span class="type">id</span> objc);</span><br><span class="line"><span class="comment">//野指针探测器是否开启</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">BOOL</span> _enabled = <span class="literal">NO</span>;</span><br><span class="line"><span class="comment">//根类</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> *_rootClasses = <span class="literal">nil</span>;</span><br><span class="line"><span class="comment">//用于存储被释放的对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSDictionary</span>&lt;<span class="type">id</span>, <span class="built_in">NSValue</span>*&gt; *_rootClassDeallocImps = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//白名单</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">NSMutableSet</span> *__mi_sniffer_white_lists()&#123;</span><br><span class="line">    <span class="comment">//创建白名单集合</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSMutableSet</span> *mi_sniffer_white_lists;</span><br><span class="line">    <span class="comment">//单例初始化白名单集合</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        mi_sniffer_white_lists = [[<span class="built_in">NSMutableSet</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> mi_sniffer_white_lists;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="type">void</span> __mi_dealloc(__<span class="keyword">unsafe_unretained</span> <span class="type">id</span> obj)&#123;</span><br><span class="line">    <span class="comment">//获取对象的类</span></span><br><span class="line">    Class currentCls = [obj <span class="keyword">class</span>];</span><br><span class="line">    Class rootCls = currentCls;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取非NSObject和NSProxy的类</span></span><br><span class="line">    <span class="keyword">while</span> (rootCls != [<span class="built_in">NSObject</span> <span class="keyword">class</span>] &amp;&amp; rootCls != [<span class="built_in">NSProxy</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">        <span class="comment">//获取rootCls的父类，并赋值</span></span><br><span class="line">        rootCls = class_getSuperclass(rootCls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取类名</span></span><br><span class="line">    <span class="built_in">NSString</span> *clsName = <span class="built_in">NSStringFromClass</span>(rootCls);</span><br><span class="line">    <span class="comment">//根据类名获取dealloc的imp指针</span></span><br><span class="line">    MIDeallocPointer deallocImp = <span class="literal">NULL</span>;</span><br><span class="line">    [[_rootClassDeallocImps objectForKey:clsName] getValue:&amp;deallocImp];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (deallocImp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        deallocImp(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hook交换dealloc</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> IMP __mi_swizzleMethodWithBlock(Method method, <span class="type">void</span> *block)&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     imp_implementationWithBlock ：接收一个block参数，将其拷贝到堆中，返回一个trampoline</span></span><br><span class="line"><span class="comment">     可以让block当做任何一个类的方法的实现，即当做类的方法的IMP来使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IMP blockImp = imp_implementationWithBlock((__bridge <span class="type">id</span> _Nonnull)(block));</span><br><span class="line">    <span class="comment">//method_setImplementation 替换掉method的IMP</span></span><br><span class="line">    <span class="keyword">return</span> method_setImplementation(method, blockImp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MIZombieSniffer</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化根类</span></span><br><span class="line">+ (<span class="type">void</span>)initialize</span><br><span class="line">&#123;</span><br><span class="line">    _rootClasses = [@[[<span class="built_in">NSObject</span> <span class="keyword">class</span>], [<span class="built_in">NSProxy</span> <span class="keyword">class</span>]] <span class="keyword">retain</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - public</span></span><br><span class="line">+ (<span class="type">void</span>)installSniffer&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_enabled) &#123;</span><br><span class="line">            <span class="comment">//hook根类的dealloc方法</span></span><br><span class="line">            [<span class="keyword">self</span> _swizzleDealloc];</span><br><span class="line">            _enabled = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)uninstallSnifier&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_enabled) &#123;</span><br><span class="line">            <span class="comment">//还原dealloc方法</span></span><br><span class="line">            [<span class="keyword">self</span> _unswizzleDealloc];</span><br><span class="line">            _enabled = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加百名单</span></span><br><span class="line">+ (<span class="type">void</span>)appendIgnoreClass:(Class)cls&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSMutableSet</span> *whiteList = __mi_sniffer_white_lists();</span><br><span class="line">        <span class="built_in">NSString</span> *clsName = <span class="built_in">NSStringFromClass</span>(cls);</span><br><span class="line">        [clsName <span class="keyword">retain</span>];</span><br><span class="line">        [whiteList addObject:clsName];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> mark - private</span></span><br><span class="line">+ (<span class="type">void</span>)_swizzleDealloc&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">void</span> *swizzledDeallocBlock = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义block，作为方法的IMP</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        swizzledDeallocBlock = (__bridge <span class="type">void</span> *)[^<span class="type">void</span>(<span class="type">id</span> obj) &#123;</span><br><span class="line">            <span class="comment">//获取对象的类</span></span><br><span class="line">            Class currentClass = [obj <span class="keyword">class</span>];</span><br><span class="line">            <span class="comment">//获取类名</span></span><br><span class="line">            <span class="built_in">NSString</span> *clsName = <span class="built_in">NSStringFromClass</span>(currentClass);</span><br><span class="line">            <span class="comment">//判断该类是否在白名单类</span></span><br><span class="line">            <span class="keyword">if</span> ([__mi_sniffer_white_lists() containsObject: clsName]) &#123;</span><br><span class="line">                <span class="comment">//如果在白名单内，则直接释放对象</span></span><br><span class="line">                __mi_dealloc(obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//修改对象的isa指针，指向MIZombieProxy</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 valueWithBytes:objCType  创建并返回一个包含给定值的NSValue对象，该值会被解释为一个给定的NSObject类型</span></span><br><span class="line"><span class="comment">                 - 参数1：NSValue对象的值</span></span><br><span class="line"><span class="comment">                 - 参数2：给定值的对应的OC类型，需要使用编译器指令@encode来创建</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="built_in">NSValue</span> *objVal = [<span class="built_in">NSValue</span> valueWithBytes: &amp;obj objCType: <span class="keyword">@encode</span>(<span class="keyword">typeof</span>(obj))];</span><br><span class="line">                <span class="comment">//为obj设置指定的类</span></span><br><span class="line">                object_setClass(obj, [MIZombieProxy <span class="keyword">class</span>]);</span><br><span class="line">                <span class="comment">//保留对象原本的类</span></span><br><span class="line">                ((MIZombieProxy *)obj).originClass = currentClass;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//设置在30s后调用dealloc将存储的对象释放，避免内存空间的增大</span></span><br><span class="line">                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">30</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    __<span class="keyword">unsafe_unretained</span> <span class="type">id</span> deallocObj = <span class="literal">nil</span>;</span><br><span class="line">                    <span class="comment">//获取需要dealloc的对象</span></span><br><span class="line">                    [objVal getValue: &amp;deallocObj];</span><br><span class="line">                    <span class="comment">//设置对象的类为原本的类</span></span><br><span class="line">                    object_setClass(deallocObj, currentClass);</span><br><span class="line">                    <span class="comment">//释放</span></span><br><span class="line">                    __mi_dealloc(deallocObj);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">copy</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换了根类NSObject和NSProxy的dealloc方法为originalDeallocImp</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *deallocImps = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="comment">//遍历根类</span></span><br><span class="line">    <span class="keyword">for</span> (Class rootClass <span class="keyword">in</span> _rootClasses) &#123;</span><br><span class="line">        <span class="comment">//获取指定类中dealloc方法</span></span><br><span class="line">        Method oriMethod = class_getInstanceMethod([rootClass <span class="keyword">class</span>], <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;dealloc&quot;</span>));</span><br><span class="line">        <span class="comment">//hook - 交换dealloc方法的IMP实现</span></span><br><span class="line">        IMP originalDeallocImp = __mi_swizzleMethodWithBlock(oriMethod, swizzledDeallocBlock);</span><br><span class="line">        <span class="comment">//设置IMP的具体实现</span></span><br><span class="line">        [deallocImps setObject: [<span class="built_in">NSValue</span> valueWithBytes: &amp;originalDeallocImp objCType: <span class="keyword">@encode</span>(<span class="keyword">typeof</span>(IMP))] forKey: <span class="built_in">NSStringFromClass</span>(rootClass)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//_rootClassDeallocImps字典存储交换后的IMP实现</span></span><br><span class="line">    _rootClassDeallocImps = [deallocImps <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="type">void</span>)_unswizzleDealloc&#123;</span><br><span class="line">    <span class="comment">//还原dealloc交换的IMP</span></span><br><span class="line">    [_rootClasses enumerateObjectsUsingBlock:^(Class rootClass, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        IMP originDeallocImp = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//获取根类类名</span></span><br><span class="line">        <span class="built_in">NSString</span> *clsName = <span class="built_in">NSStringFromClass</span>(rootClass);</span><br><span class="line">        <span class="comment">//获取hook后的dealloc实现</span></span><br><span class="line">        [[_rootClassDeallocImps objectForKey:clsName] getValue:&amp;originDeallocImp];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSParameterAssert</span>(originDeallocImp);</span><br><span class="line">        <span class="comment">//获取原本的dealloc实现</span></span><br><span class="line">        Method oriMethod = class_getInstanceMethod([rootClass <span class="keyword">class</span>], <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;dealloc&quot;</span>));</span><br><span class="line">        <span class="comment">//还原dealloc的实现</span></span><br><span class="line">        method_setImplementation(oriMethod, originDeallocImp);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">//释放</span></span><br><span class="line">    [_rootClassDeallocImps release];</span><br><span class="line">    _rootClassDeallocImps = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>性能</category>
        <category>apm</category>
      </categories>
      <tags>
        <tag>野指针</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 面试题(持续更新)</title>
    <url>/iOS/questions/index.html</url>
    <content><![CDATA[<blockquote>
<p>我不是推广，我也是个学习者，推荐一个慕课网学习，我还专门写了一个<a href="./iOS/study.html">笔记博客</a></p>
</blockquote>
<h1 id="iOS面试题大全—全方面剖析面试"><a href="#iOS面试题大全—全方面剖析面试" class="headerlink" title="iOS面试题大全—全方面剖析面试"></a>iOS面试题大全—全方面剖析面试</h1><ul>
<li>UIView与CALayer</li>
<li>事件传递与视图响应链</li>
<li>图像显示原理</li>
<li>UI卡顿掉帧原因</li>
<li>滑动优化方案</li>
<li>UI绘制原理</li>
<li>离屏渲染</li>
</ul>
<h2 id="UIView与CALayer"><a href="#UIView与CALayer" class="headerlink" title="UIView与CALayer"></a>UIView与CALayer</h2><img src="/images/iOS/uiviewuilayer.png" class="" title="uiviewuilayer">
<p>&lt;单一职责原则&gt;<br>UIView为CALayer提供内容，以及负责处理触摸等事件，参与响应链<br>CALayer负责显示内容contents</p>
<h2 id="事件传递与视图响应链"><a href="#事件传递与视图响应链" class="headerlink" title="事件传递与视图响应链"></a>事件传递与视图响应链</h2><figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">- <span class="params">(UIView *)</span>hitTest:<span class="params">(CGPoint)</span>point withEvent:<span class="params">(UIEvent *)</span>event;</span><br><span class="line"></span><br><span class="line">- <span class="params">(BOOL)</span>pointInside:<span class="params">(CGPoint)</span>point withEvent:<span class="params">(UIEvent *)</span>event;</span><br></pre></td></tr></table></figure>
<img src="/images/iOS/question_event_process.png" class="" title="question_event_process">
<p>如果事件一直传递到UIAppliction还是没处理，那就会忽略掉</p>
<h2 id="图像显示原理"><a href="#图像显示原理" class="headerlink" title="图像显示原理"></a>图像显示原理</h2><ol>
<li>CPU:输出位图</li>
<li>GPU :图层渲染，纹理合成</li>
<li>把结果放到帧缓冲区(frame buffer)中</li>
<li>再由视频控制器根据vsync信号在指定时间之前去提取帧缓冲区的屏幕显示内容</li>
<li>显示到屏幕上<img src="/images/iOS/imagedisplay.png" class="" title="imagedisplay"></li>
</ol>
<p>CPU工作</p>
<ol>
<li>Layout: UI布局，文本计算</li>
<li>Display: 绘制</li>
<li>Prepare: 图片解码</li>
<li>Commit：提交位图</li>
</ol>
<p>GPU渲染管线(OpenGL)</p>
<ul>
<li>顶点着色，图元装配，光栅化，片段着色，片段处理</li>
</ul>
<h2 id="UI卡顿掉帧原因"><a href="#UI卡顿掉帧原因" class="headerlink" title="UI卡顿掉帧原因"></a>UI卡顿掉帧原因</h2><img src="/images/iOS/kadun.png" class="" title="kadun">
<p>iOS设备的硬件时钟会发出Vsync（垂直同步信号），然后App的CPU会去计算屏幕要显示的内容，之后将计算好的内容提交到GPU去渲染。随后，GPU将渲染结果提交到帧缓冲区，等到下一个VSync到来时将缓冲区的帧显示到屏幕上。也就是说，一帧的显示是由CPU和GPU共同决定的。<br>一般来说，页面滑动流畅是60fps，也就是1s有60帧更新，即每隔16.7ms就要产生一帧画面，而如果CPU和GPU加起来的处理时间超过了16.7ms，就会造成掉帧甚至卡顿。</p>
<h2 id="滑动优化方案"><a href="#滑动优化方案" class="headerlink" title="滑动优化方案"></a>滑动优化方案</h2><p>CPU：把以下操作放在子线程中</p>
<ol>
<li>对象创建、调整、销毁</li>
<li>预排版（布局计算、文本计算、缓存高度等等）</li>
<li>预渲染（文本等异步绘制，图片解码等）<br>GPU:</li>
</ol>
<ul>
<li>纹理渲染，视图混合</li>
<li>一般遇到性能问题时，考虑以下问题：<ul>
<li>是否受到CPU或者GPU的限制？</li>
<li>是否有不必要的CPU渲染？</li>
<li>是否有太多的离屏渲染操作？</li>
<li>是否有太多的图层混合操作？</li>
<li>是否有奇怪的图片格式或者尺寸？</li>
<li>是否涉及到昂贵的view或者效果？</li>
<li>view的层次结构是否合理？</li>
</ul>
</li>
</ul>
<h2 id="UI绘制原理"><a href="#UI绘制原理" class="headerlink" title="UI绘制原理"></a>UI绘制原理</h2><img src="/images/iOS/uidraw.png" class="" title="uidraw">
<img src="/images/iOS/uidrawdisplay.png" class="" title="uidrawdisplay">
<p>异步绘制：</p>
<ul>
<li>[self.layer.delegate displayLayer: ]</li>
<li>代理负责生成对应的bitmap</li>
<li>设置该bitmap作为该layer.contents属性的值<img src="/images/iOS/asyndraw.png" class="" title="asyndraw"></li>
</ul>
<h2 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><p>On-Screen Rendering:当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行<br>Off-Screen Rendering:离屏渲染，分为CPU离屏渲染和GPU离屏渲染两种形式。GPU离屏渲染指的是GPU在当前屏幕缓冲区外新开辟一个缓冲区进行渲染操作<br>应当尽量避免的则是GPU离屏渲染<br>GPU离屏渲染何时会触发呢？<br>圆角（当和maskToBounds一起使用时）、图层蒙版、阴影，设置</p>
<blockquote>
<p>layer.shouldRasterize ＝ YES</p>
</blockquote>
<p>为什么要避免GPU离屏渲染？</p>
<ul>
<li>GPU需要做额外的渲染操作。通常GPU在做渲染的时候是很快的，但是涉及到offscreen-render的时候情况就可能有些不同，因为需要额外开辟一个新的缓冲区进行渲染，然后绘制到当前屏幕的过程需要做onscreen跟offscreen上下文之间的切换，这个过程的消耗会比较昂贵，涉及到OpenGL的pipeline跟barrier，而且offscreen-render在每一帧都会涉及到，因此处理不当肯定会对性能产生一定的影响。另外由于离屏渲染会增加GPU的工作量，可能会导致CPU+GPU的处理时间超出16.7ms，导致掉帧卡顿。所以可以的话应尽量减少offscreen-render的图层</li>
</ul>
<h1 id="Runtime-RunLoop-面试请看我相关具体博客内容，不再累赘"><a href="#Runtime-RunLoop-面试请看我相关具体博客内容，不再累赘" class="headerlink" title="Runtime/RunLoop 面试请看我相关具体博客内容，不再累赘"></a>Runtime/RunLoop 面试请看我相关具体博客内容，不再累赘</h1><h1 id="暂停，不定期更新，看心情。。。。。"><a href="#暂停，不定期更新，看心情。。。。。" class="headerlink" title="暂停，不定期更新，看心情。。。。。"></a>暂停，不定期更新，看心情。。。。。</h1>]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS面试题</category>
      </categories>
      <tags>
        <tag>iOS面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS解决过的问题汇总</title>
    <url>/iOS/questions/resolved.html</url>
    <content><![CDATA[<h1 id="关于断点-objc-exception-throw-问题分析"><a href="#关于断点-objc-exception-throw-问题分析" class="headerlink" title="关于断点 objc_exception_throw 问题分析"></a>关于断点 objc_exception_throw 问题分析</h1><p>通过<code>bt</code>打印出堆栈信息<br>例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">thread #<span class="number">1</span>, queue = <span class="string">&#x27;com.apple.main-thread&#x27;</span>, stop reason = breakpoint <span class="number">2.3</span></span><br><span class="line">    frame #<span class="number">0</span>: <span class="number">0x00000002232679c0</span> libobjc.A.dylib`objc_exception_throw</span><br><span class="line">    frame #<span class="number">1</span>: <span class="number">0x0000000223fabe10</span> CoreFoundation`-[<span class="built_in">NSException</span> raise] + <span class="number">12</span></span><br><span class="line">    frame #<span class="number">2</span>: <span class="number">0x0000000224a778fc</span> Foundation`-[<span class="built_in">NSObject</span>(<span class="built_in">NSKeyValueCoding</span>) valueForUndefinedKey:] + <span class="number">248</span></span><br><span class="line">    frame #<span class="number">3</span>: <span class="number">0x00000002249ebe1c</span> Foundation`-[<span class="built_in">NSObject</span>(<span class="built_in">NSKeyValueCoding</span>) valueForKey:] + <span class="number">260</span></span><br><span class="line">    frame #<span class="number">4</span>: <span class="number">0x0000000224a091a4</span> Foundation`-[<span class="built_in">NSObject</span>(<span class="built_in">NSKeyValueCoding</span>) setValue:forKeyPath:] + <span class="number">256</span></span><br><span class="line">    frame #<span class="number">5</span>: <span class="number">0x00000002507d45ac</span> <span class="built_in">UIKitCore</span>`-[<span class="built_in">UINibKeyValuePair</span> apply] + <span class="number">72</span></span><br><span class="line">    frame #<span class="number">6</span>: <span class="number">0x0000000223f7be88</span> CoreFoundation`-[<span class="built_in">NSArray</span> makeObjectsPerformSelector:] + <span class="number">280</span></span><br><span class="line">    frame #<span class="number">7</span>: <span class="number">0x00000002507d3fec</span> <span class="built_in">UIKitCore</span>`-[<span class="built_in">UINib</span> instantiateWithOwner:options:] + <span class="number">1628</span></span><br><span class="line">    frame #<span class="number">8</span>: <span class="number">0x0000000250d1ef84</span> <span class="built_in">UIKitCore</span>`-[<span class="built_in">UITableView</span> _dequeueReusableViewOfType:withIdentifier:] + <span class="number">592</span></span><br><span class="line">    frame #<span class="number">9</span>: <span class="number">0x000000010351f838</span> Gundam`-[<span class="built_in">UITableView</span>(TestinUITableView) testin_DequeueReusableCellWithIdentifier:] + <span class="number">112</span></span><br><span class="line">    frame #<span class="number">10</span>: <span class="number">0x0000000250d1f42c</span> <span class="built_in">UIKitCore</span>`-[<span class="built_in">UITableView</span> _dequeueReusableCellWithIdentifier:forIndexPath:usingPresentationValues:] + <span class="number">164</span></span><br><span class="line">    frame #<span class="number">11</span>: <span class="number">0x0000000250d1f358</span> <span class="built_in">UIKitCore</span>`-[<span class="built_in">UITableView</span> dequeueReusableCellWithIdentifier:forIndexPath:] + <span class="number">96</span></span><br><span class="line">    frame #<span class="number">12</span>: <span class="number">0x000000010351f9b8</span> Gundam`-[<span class="built_in">UITableView</span>(TestinUITableView) testin_DequeueReusableCellWithIdentifier:forIndexPath:] + <span class="number">292</span></span><br><span class="line">  * frame #<span class="number">13</span>: <span class="number">0x000000010267cfe8</span> Gundam`-[DKLandlordEntrustViewController tableView:cellForRowAtIndexPath:](<span class="keyword">self</span>=<span class="number">0x0000000155b0aa00</span>, _cmd=<span class="string">&quot;tableView:cellForRowAtIndexPath:&quot;</span>, tableView=<span class="number">0x000000015495fa00</span>, indexPath=<span class="number">0xb59300120e671f5c</span>) at DKLandlordEntrustViewController.m:<span class="number">220</span>:<span class="number">33</span></span><br><span class="line">    frame #<span class="number">14</span>: <span class="number">0x0000000250d38618</span> <span class="built_in">UIKitCore</span>`-[<span class="built_in">UITableView</span> _createPreparedCellForGlobalRow:withIndexPath:willDisplay:] + <span class="number">680</span></span><br><span class="line">    frame #<span class="number">15</span>: <span class="number">0x0000000250d38b18</span> <span class="built_in">UIKitCore</span>`-[<span class="built_in">UITableView</span> _createPreparedCellForGlobalRow:willDisplay:] + <span class="number">80</span></span><br><span class="line">    frame #<span class="number">16</span>: <span class="number">0x0000000250d05320</span> <span class="built_in">UIKitCore</span>`-[<span class="built_in">UITableView</span> _updateVisibleCellsNow:isRecursive:] + <span class="number">2260</span></span><br><span class="line">    frame #<span class="number">17</span>: <span class="number">0x0000000250d22640</span> <span class="built_in">UIKitCore</span>`-[<span class="built_in">UITableView</span> layoutSubviews] + <span class="number">140</span></span><br><span class="line">    frame #<span class="number">18</span>: <span class="number">0x0000000250fb1170</span> <span class="built_in">UIKitCore</span>`-[<span class="built_in">UIView</span>(<span class="built_in">CALayerDelegate</span>) layoutSublayersOfLayer:] + <span class="number">1292</span></span><br><span class="line">    frame #<span class="number">19</span>: <span class="number">0x00000002285cbc60</span> QuartzCore`-[<span class="built_in">CALayer</span> layoutSublayers] + <span class="number">184</span></span><br><span class="line">    frame #<span class="number">20</span>: <span class="number">0x00000002285d0c08</span> QuartzCore`CA::Layer::layout_if_needed(CA::Transaction*) + <span class="number">332</span></span><br><span class="line">    frame #<span class="number">21</span>: <span class="number">0x00000002285333e4</span> QuartzCore`CA::Context::commit_transaction(CA::Transaction*) + <span class="number">348</span></span><br><span class="line">    frame #<span class="number">22</span>: <span class="number">0x0000000228561620</span> QuartzCore`CA::Transaction::commit() + <span class="number">640</span></span><br><span class="line">    frame #<span class="number">23</span>: <span class="number">0x000000022856215c</span> QuartzCore`CA::Transaction::observer_callback(__CFRunLoopObserver*, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">void</span>*) + <span class="number">92</span></span><br><span class="line">    frame #<span class="number">24</span>: <span class="number">0x000000022401fd08</span> CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ + <span class="number">32</span></span><br><span class="line">    frame #<span class="number">25</span>: <span class="number">0x000000022401aa30</span> CoreFoundation`__CFRunLoopDoObservers + <span class="number">412</span></span><br><span class="line">    frame #<span class="number">26</span>: <span class="number">0x000000022401afac</span> CoreFoundation`__CFRunLoopRun + <span class="number">1228</span></span><br><span class="line">    frame #<span class="number">27</span>: <span class="number">0x000000022401a7c0</span> CoreFoundation`<span class="built_in">CFRunLoopRunSpecific</span> + <span class="number">436</span></span><br><span class="line">    frame #<span class="number">28</span>: <span class="number">0x000000022621b79c</span> GraphicsServices`GSEventRunModal + <span class="number">104</span></span><br><span class="line">    frame #<span class="number">29</span>: <span class="number">0x0000000250b19c38</span> <span class="built_in">UIKitCore</span>`<span class="built_in">UIApplicationMain</span> + <span class="number">212</span></span><br><span class="line">    frame #<span class="number">30</span>: <span class="number">0x00000001024cd140</span> Gundam`main(argc=<span class="number">1</span>, argv=<span class="number">0x000000016dbc37f0</span>) at main.m:<span class="number">15</span>:<span class="number">16</span></span><br><span class="line">    frame #<span class="number">31</span>: <span class="number">0x0000000223ade8e0</span> libdyld.dylib`start + <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>然后通过单步调试，在汇编里面看到生成exception （creat）等等,最后定位到位置。</p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS解决过的问题汇总</category>
      </categories>
      <tags>
        <tag>iOS解决过的问题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>AFNetWorking</title>
    <url>/iOS/thirdpart/afn.html</url>
    <content><![CDATA[<h1 id="AFNetWorking"><a href="#AFNetWorking" class="headerlink" title="AFNetWorking"></a>AFNetWorking</h1><p>由于AFNetWorking在 NSURLSession初始化的时候，用到了一个代理方法。Session在ARC下不会及时的释放</p>
<p>在使用instruments做内存泄漏分析时，发现所有使用如下语句的地方都有内存泄漏，:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[AFHTTPSessionManager manager];</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="type">id</span> &lt;<span class="built_in">NSURLSessionDelegate</span>&gt; delegate;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Customization of NSURLSession occurs during creation of a new session.</span></span><br><span class="line"><span class="comment"> * If you only need to use the convenience routines with custom</span></span><br><span class="line"><span class="comment"> * configuration options it is not necessary to specify a delegate.</span></span><br><span class="line"><span class="comment"> * If you do specify a delegate, the delegate will be retained until after</span></span><br><span class="line"><span class="comment"> * the delegate has been sent the URLSession:didBecomeInvalidWithError: message.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*翻译：</span></span><br><span class="line"><span class="comment">NSURLSession的自定义发生在创建新会话期间。如果只需要使用带有自定义配置选项的便利例程，则不需要指定委托。</span></span><br><span class="line"><span class="comment">如果您指定了一个委托，那么该委托将被保留(retain)，直到URLSession:didBecomeInvalidWithError: message发送给委托之后。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSURLSession</span> *)sessionWithConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration delegate:(<span class="keyword">nullable</span> <span class="type">id</span> &lt;<span class="built_in">NSURLSessionDelegate</span>&gt;)delegate delegateQueue:(<span class="keyword">nullable</span> <span class="built_in">NSOperationQueue</span> *)queue;</span><br></pre></td></tr></table></figure>


<p>解决方法：<br>一般我们通过写单例的方式</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">static AFHTTPSessionManager *manager ;`</span><br><span class="line"><span class="built_in">-</span>(AFHTTPSessionManager *)sharedHTTPSession&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        manager = [AFHTTPSessionManager manager];</span><br><span class="line">        manager.requestSerializer.timeoutInterval = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，就不会创造出更多的session，避免了泄露</p>
<h1 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h1>]]></content>
      <categories>
        <category>iOS</category>
        <category>Third-Party Lib</category>
        <category>AFNetWorking</category>
      </categories>
      <tags>
        <tag>AFNetWorking</tag>
      </tags>
  </entry>
  <entry>
    <title>AsyncDisplayKit</title>
    <url>/iOS/thirdpart/asdk.html</url>
    <content><![CDATA[<h1 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h1><p>AsyncDisplayKit 是 Facebook 开源的一个用于保持 iOS 界面流畅的库。在我博客其它章节也提到过。<br>ASDK 的作者是 Scott Goodson (<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlua2VkaW4uY29tL2luL2lvc2VuZ2luZWVy">Linkedin<i class="fa fa-external-link-alt"></i></span>)，<br>他曾经在苹果工作，负责 iOS 的一些内置应用的开发，比如股票、计算器、地图、钟表、设置、Safari 等，当然他也参与了 UIKit framework 的开发。后来他加入 Facebook 后，负责 Paper 的开发，创建并开源了 AsyncDisplayKit。目前他在 Pinterest 和 Instagram 负责 iOS 开发和用户体验的提升等工作。</p>
<p>ASDK 自 2014 年 6 月开源，10 月发布 1.0 版。目前 ASDK 即将要发布 2.0 版。<br>V2.0 增加了更多布局相关的代码，ComponentKit 团队为此贡献很多。<br>现在 Github 的 master 分支上的版本是 V1.9.1，已经包含了 V2.0 的全部内容。</p>
<p><span class="exturl" data-url="aHR0cDovL3RleHR1cmVncm91cC5vcmcvZG9jcy9nZXR0aW5nLXN0YXJ0ZWQuaHRtbA==">官方教程<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="ASDK的基本原理"><a href="#ASDK的基本原理" class="headerlink" title="ASDK的基本原理"></a>ASDK的基本原理</h2><img src="/images/iOS/asdk_design.png" class="" title="asdk_design">


<p>ASDK 认为，阻塞主线程的任务，主要分为上面这三大类。文本和布局的计算、渲染、解码、绘制都可以通过各种方式异步执行，但 UIKit 和 Core Animation 相关操作必需在主线程进行。ASDK 的目标，就是尽量把这些任务从主线程挪走，而挪不走的，就尽量优化性能。</p>
<p>为了达成这一目标，ASDK 尝试对 UIKit 组件进行封装：</p>
<img src="/images/iOS/asdk_layer_backed_view.png" class="" title="asdk_design">

<p>这是常见的 UIView 和 CALayer 的关系：View 持有 Layer 用于显示，View 中大部分显示属性实际是从 Layer 映射而来；Layer 的 delegate 在这里是 View，当其属性改变、动画产生时，View 能够得到通知。UIView 和 CALayer 不是线程安全的，并且只能在主线程创建、访问和销毁。</p>
<img src="/images/iOS/asdk_view_backed_node.png" class="" title="asdk_design">

<p>ASDK 为此创建了 ASDisplayNode 类，包装了常见的视图属性（比如 frame/bounds/alpha/transform/backgroundColor/superNode/subNodes 等），然后它用 UIView-&gt;CALayer 相同的方式，实现了 ASNode-&gt;UIView 这样一个关系。  </p>
<img src="/images/iOS/asdk_layer_backed_node.png" class="" title="asdk_design">


<p>当不需要响应触摸事件时，ASDisplayNode 可以被设置为 layer backed，即 ASDisplayNode 充当了原来 UIView 的功能，节省了更多资源。</p>
<p>与 UIView 和 CALayer 不同，ASDisplayNode 是线程安全的，它可以在后台线程创建和修改。Node 刚创建时，并不会在内部新建 UIView 和 CALayer，直到第一次在主线程访问 view 或 layer 属性时，它才会在内部生成对应的对象。当它的属性（比如frame/transform）改变后，它并不会立刻同步到其持有的 view 或 layer 去，而是把被改变的属性保存到内部的一个中间变量，稍后在需要时，再通过某个机制一次性设置到内部的 view 或 layer。</p>
<p>通过模拟和封装 UIView/CALayer，开发者可以把代码中的 UIView 替换为 ASNode，很大的降低了开发和学习成本，同时能获得 ASDK 底层大量的性能优化。为了方便使用， ASDK 把大量常用控件都封装成了 ASNode 的子类，比如 Button、Control、Cell、Image、ImageView、Text、TableView、CollectionView 等。利用这些控件，开发者可以尽量避免直接使用 UIKit 相关控件，以获得更完整的性能提升。</p>
<h1 id="ASDK-的图层预合成"><a href="#ASDK-的图层预合成" class="headerlink" title="ASDK 的图层预合成"></a>ASDK 的图层预合成</h1><table>
    <tr>
        <td> <img src="/images/iOS/asdk_comoose_1.png" class="" title="asdk_design"> </td>
        <td> <img src="/images/iOS/asdk_compose_2.png" class="" title="asdk_design"> </td>
    </tr>
</table>

<p>有时一个 layer 会包含很多 sub-layer，而这些 sub-layer 并不需要响应触摸事件，也不需要进行动画和位置调整。ASDK 为此实现了一个被称为 pre-composing 的技术，可以把这些 sub-layer 合成渲染为一张图片。开发时，ASNode 已经替代了 UIView 和 CALayer；直接使用各种 Node 控件并设置为 layer backed 后，ASNode 甚至可以通过预合成来避免创建内部的 UIView 和 CALayer。</p>
<p>通过这种方式，把一个大的层级，通过一个大的绘制方法绘制到一张图上，性能会获得很大提升。CPU 避免了创建 UIKit 对象的资源消耗，GPU 避免了多张 texture 合成和渲染的消耗，更少的 bitmap 也意味着更少的内存占用。</p>
<h1 id="ASDK-异步并发操作"><a href="#ASDK-异步并发操作" class="headerlink" title="ASDK 异步并发操作"></a>ASDK 异步并发操作</h1><img src="/images/iOS/asdk_a9_chip.jpg" class="" title="asdk_a9_chip">

<p>自 iPhone 4S 起，iDevice 已经都是双核 CPU 了，现在的 iPad 甚至已经更新到 3 核了。充分利用多核的优势、并发执行任务对保持界面流畅有很大作用。ASDK 把布局计算、文本排版、图片/文本/图形渲染等操作都封装成较小的任务，并利用 GCD 异步并发执行。如果开发者使用了 ASNode 相关的控件，那么这些并发操作会自动在后台进行，无需进行过多配置。</p>
<h1 id="Runloop-任务分发"><a href="#Runloop-任务分发" class="headerlink" title="Runloop 任务分发"></a>Runloop 任务分发</h1><p>Runloop work distribution 是 ASDK 比较核心的一个技术，ASDK 的介绍视频和文档中都没有详细展开介绍，所以这里我会多做一些分析。如果你对 Runloop 还不太了解，可以看一下我之前的文章 <a href="./iOS/RunLoop/index.html">RunLoop</a>，里面对 ASDK 也有所提及。</p>
<img src="/images/iOS/ios_vsync_runloop.png" class="" title="ios_vsync_runloop">


<p>iOS 的显示系统是由 VSync 信号驱动的，VSync 信号由硬件时钟生成，每秒钟发出 60 次（这个值取决设备硬件，比如 iPhone 真机上通常是 59.97）。iOS 图形服务接收到 VSync 信号后，会通过 IPC 通知到 App 内。App 的 Runloop 在启动后会注册对应的 CFRunLoopSource 通过 mach_port 接收传过来的时钟信号通知，随后 Source 的回调会驱动整个 App 的动画与显示。</p>
<p>Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件。这个 Observer 的优先级是 2000000，低于常见的其他 Observer。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 捕获，并通过 CATransaction 提交到一个中间状态去（CATransaction 的文档略有提到这些内容，但并不完整）。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 CA 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，CA 会通过 DisplayLink 等机制多次触发相关流程。</p>
<p>ASDK 在此处模拟了 Core Animation 的这个机制：所有针对 ASNode 的修改和提交，总有些任务是必需放入主线程执行的。当出现这种任务时，ASNode 会把任务用 ASAsyncTransaction(Group) 封装并提交到一个全局的容器去。ASDK 也在 RunLoop 中注册了一个 Observer，监视的事件和 CA 一样，但优先级比 CA 要低。当 RunLoop 进入休眠前、CA 处理完事件后，ASDK 就会执行该 loop 内提交的所有任务。具体代码见这个文件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL0FzeW5jRGlzcGxheUtpdC9ibG9iL21hc3Rlci9Bc3luY0Rpc3BsYXlLaXQlMkZEZXRhaWxzJTJGVHJhbnNhY3Rpb25zJTJGX0FTQXN5bmNUcmFuc2FjdGlvbkdyb3VwLm0=">ASAsyncTransactionGroup<i class="fa fa-external-link-alt"></i></span>。</p>
<p>通过这种机制，ASDK 可以在合适的机会把异步、并发的操作同步到主线程去，并且能获得不错的性能。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>ASDK 中还有封装很多高级的功能，比如滑动列表的预加载、V2.0添加的新的布局模式等。ASDK 是一个很庞大的库，它本身并不推荐你把整个 App 全部都改为 ASDK 驱动，把最需要提升交互性能的地方用 ASDK 进行优化就足够了。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmliaXJlbWUuY29tLzIwMTUvMTEvMTIvc21vb3RoX3VzZXJfaW50ZXJmYWNlc19mb3JfaW9zLw==">不够尽兴的朋友请移步博客<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>iOS</category>
        <category>Third-Party Lib</category>
        <category>AsyncDisplayKit</category>
      </categories>
      <tags>
        <tag>AsyncDisplayKit</tag>
      </tags>
  </entry>
  <entry>
    <title>Glide</title>
    <url>/iOS/thirdpart/glide.html</url>
    <content><![CDATA[<h1 id="逐步分析"><a href="#逐步分析" class="headerlink" title="逐步分析"></a>逐步分析</h1><h2 id="Glide-with-……"><a href="#Glide-with-……" class="headerlink" title="Glide.with(……)"></a>Glide.with(……)</h2><p>Glide.with() 有下面几种实现方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Glide.with(Context context)</span><br><span class="line"><span class="number">2.</span> Glide.with(Activity activity)</span><br><span class="line"><span class="number">3.</span> Glide.with(FragmentActivity activity)</span><br><span class="line"><span class="number">4.</span> Glide.with(android.app.Fragment fragment)</span><br><span class="line"><span class="number">5.</span> Glide.with(View view)</span><br></pre></td></tr></table></figure>

<p>所以的方法实现也是很类似，都是调用同一个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title function_">with</span><span class="params">(Fragment fragment)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一下 getRetriever() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> RequestManagerRetriever <span class="title function_">getRetriever</span><span class="params">(<span class="meta">@Nullable</span> Context context)</span> &#123;</span><br><span class="line">  ……</span><br><span class="line">  省略一些判空检查</span><br><span class="line">  ——</span><br><span class="line">  <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 Glide.get(context) 主要用来初始化 Glide 的全局单利对象，以及一些配置。</p>
<p>getRequestManagerRetriever() 则是返回 Glide 对象的 requestManagerRetriever 对象。</p>
<p>然后看一下 requestManagerRetriever.get() 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RequestManager <span class="title function_">get</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;You cannot start a load on a null Context&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get() 方法会根据传入的 context 对象和当前线程，创建不同的 RequestManager 实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 非 UI 线程，返回 applicationManager 对象，能感知 Application 生命周期。</span><br><span class="line"><span class="number">2.</span> UI 线程，如果 context 是 Activity 、FragmentActivity </span><br><span class="line">   则会创建一个能感知对应 Activity 的 RequestManager。</span><br><span class="line"><span class="number">3.</span> UI 线程，如果 Context 是 Fragment、android.support.v4.app.Fragment </span><br><span class="line">   则会创建一个能感知对应 Fragment 生命周期 的 RequestManager。</span><br></pre></td></tr></table></figure>
<p>这里反复提到了一个 <code>感知生命 xx 周期</code>，也是 Glide 的一个特性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Glide 在加载资源的时候，如果是在 Activity、Fragment 这一类有生命周期的组件上进行。</span><br><span class="line">当 Activity、Fragment 等组件进入不可见，或者已经销毁的时候，Glide 会停止加载资源。</span><br><span class="line">Application 的生命周期贯穿整个应用，所以 applicationManager 只有在应用程序关闭的时候终止加载。</span><br></pre></td></tr></table></figure>
<p>所以尽量不要在非 UI 线程使用 Glide 加载图片，尽量使用 Activity、Fragment 等带有生命周期的组件配合 Glide 使用。</p>
<h2 id="Glide-如何获得-Activity、Fragment-生命周期回调"><a href="#Glide-如何获得-Activity、Fragment-生命周期回调" class="headerlink" title="Glide 如何获得 Activity、Fragment 生命周期回调"></a>Glide 如何获得 Activity、Fragment 生命周期回调</h2><p>在 各种 requestManagerRetriever.get() 方法中如果传入的是带有生命周期的组件，并且在 UI 线程，会执行以下几个方法端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FragmentActivity</span></span><br><span class="line">assertNotDestroyed(activity);</span><br><span class="line"><span class="type">FragmentManager</span> <span class="variable">fm</span> <span class="operator">=</span> activity.getSupportFragmentManager();</span><br><span class="line"><span class="keyword">return</span> supportFragmentGet(activity, fm, <span class="literal">null</span> <span class="comment">/*parentHint*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//android.support.v4.app.Fragment</span></span><br><span class="line"><span class="type">FragmentManager</span> <span class="variable">fm</span> <span class="operator">=</span> fragment.getChildFragmentManager();</span><br><span class="line"><span class="keyword">return</span> supportFragmentGet(fragment.getActivity(), fm, fragment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Activity</span></span><br><span class="line">assertNotDestroyed(activity);</span><br><span class="line">android.app.<span class="type">FragmentManager</span> <span class="variable">fm</span> <span class="operator">=</span> activity.getFragmentManager();</span><br><span class="line"><span class="keyword">return</span> fragmentGet(activity, fm, <span class="literal">null</span> <span class="comment">/*parentHint*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//android.app.Fragment</span></span><br><span class="line">android.app.<span class="type">FragmentManager</span> <span class="variable">fm</span> <span class="operator">=</span> fragment.getChildFragmentManager();</span><br><span class="line"><span class="keyword">return</span> fragmentGet(fragment.getActivity(), fm, fragment);</span><br></pre></td></tr></table></figure>
<ol>
<li>如果是 Activity ，先获取 FragmentManager ，如果是 Fragment 则先获取 ChildFragmentManager。</li>
<li>如果是 support 包下面的 Activity 、Fragment 调用 supportFragmentGet，否则调用 fragmentGet。</li>
</ol>
<p>fragmentGet() 和 supportFragmentGet() 方法大致类似，选取一个分析一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RequestManager <span class="title function_">fragmentGet</span><span class="params">(Context context, android.app.FragmentManager fm,</span></span><br><span class="line"><span class="params">    android.app.Fragment parentHint)</span> &#123;</span><br><span class="line">  <span class="type">RequestManagerFragment</span> <span class="variable">current</span> <span class="operator">=</span> getRequestManagerFragment(fm, parentHint);</span><br><span class="line">  <span class="type">RequestManager</span> <span class="variable">requestManager</span> <span class="operator">=</span> current.getRequestManager();</span><br><span class="line">  <span class="keyword">if</span> (requestManager == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">    <span class="type">Glide</span> <span class="variable">glide</span> <span class="operator">=</span> Glide.get(context);</span><br><span class="line">    requestManager =</span><br><span class="line">        factory.build(</span><br><span class="line">            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">    current.setRequestManager(requestManager);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码做了两个功能</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 创建一个 RequestManagerFragment。</span><br><span class="line"><span class="bullet">2.</span> 创建一个 RequestManager。</span><br></pre></td></tr></table></figure>
<p>先看一下 getRequestManagerFragment</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)</span></span><br><span class="line">RequestManagerFragment <span class="title function_">getRequestManagerFragment</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">final</span> android.app.FragmentManager fm, android.app.Fragment parentHint)</span> &#123;</span><br><span class="line">  <span class="type">RequestManagerFragment</span> <span class="variable">current</span> <span class="operator">=</span> (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">  <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">    current = pendingRequestManagerFragments.get(fm);</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">      current = <span class="keyword">new</span> <span class="title class_">RequestManagerFragment</span>();</span><br><span class="line">      current.setParentFragmentHint(parentHint);</span><br><span class="line">      pendingRequestManagerFragments.put(fm, current);</span><br><span class="line">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">      handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是是 Glide 设计中比较一个巧妙的地方</p>
<figure class="highlight graphql"><table><tr><td class="code"><pre><span class="line">创建一个透明的 RequestManagerFragment 加入到FragmentManager 之中</span><br><span class="line">通过添加的这个 <span class="keyword">Fragment</span> 感知 Activity 、<span class="keyword">Fragment</span> 的生命周期。</span><br></pre></td></tr></table></figure>
<p>在 RequestManagerFragment 中可以看到以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStart</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.onStart();</span><br><span class="line">  lifecycle.onStart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.onStop();</span><br><span class="line">  lifecycle.onStop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>.onDestroy();</span><br><span class="line">  lifecycle.onDestroy();</span><br><span class="line">  unregisterFragmentWithRoot();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以通过 RequestManagerFragment 把 Activity 的生命周期通过 lifecycle 传递给在 lifecycle 注册的 LifecycleListener。</p>
<h2 id="RequestManager-load-url"><a href="#RequestManager-load-url" class="headerlink" title="RequestManager.load(url)"></a>RequestManager.load(url)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title function_">load</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> asDrawable().load(model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title function_">asDrawable</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; RequestBuilder&lt;ResourceType&gt; <span class="title function_">as</span><span class="params">(Class&lt;ResourceType&gt; resourceClass)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestBuilder</span>&lt;&gt;(glide, <span class="built_in">this</span>, resourceClass, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title function_">load</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> loadGeneric(model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title function_">loadGeneric</span><span class="params">(<span class="meta">@Nullable</span> Object model)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.model = model;</span><br><span class="line">  isModelSet = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是 RequestBuilder.load(url) 的相关代码，发现并没有什么特殊之处。 只是创建了一个 RequestBuilder 。</p>
<h2 id="RequestBuilder-into-view"><a href="#RequestBuilder-into-view" class="headerlink" title="RequestBuilder.into(view)"></a>RequestBuilder.into(view)</h2><p>into() 方法调用起来十分方便，只要传递一个 ImageView ，Glide 就会自动下载图片，并且显示到 ImageView 上。这看似十分简单的一步，也是 Glide 最负责的调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Target&lt;TranscodeType&gt; <span class="title function_">into</span><span class="params">(ImageView view)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="type">RequestOptions</span> <span class="variable">requestOptions</span> <span class="operator">=</span> <span class="built_in">this</span>.requestOptions;</span><br><span class="line">  ……</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> into(</span><br><span class="line">      glideContext.buildImageViewTarget(view, transcodeClass),</span><br><span class="line">      <span class="comment">/*targetListener=*/</span> <span class="literal">null</span>,</span><br><span class="line">      requestOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟踪一下 glideContext.buildImageViewTarget(view, transcodeClass) 会发现这里返回的是一个<code>DrawableImageViewTarget</code><br>into(ImageView view) 把 requestOptions 和 DrawableImageViewTarget 传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y <span class="keyword">extends</span> <span class="title class_">Target</span>&lt;TranscodeType&gt;&gt; Y <span class="title function_">into</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@NonNull</span> Y target,</span></span><br><span class="line"><span class="params">    <span class="meta">@Nullable</span> RequestListener&lt;TranscodeType&gt; targetListener,</span></span><br><span class="line"><span class="params">    RequestOptions options)</span> &#123;</span><br><span class="line">  ……</span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> buildRequest(target, targetListener, options);</span><br><span class="line"></span><br><span class="line">  <span class="type">Request</span> <span class="variable">previous</span> <span class="operator">=</span> target.getRequest();</span><br><span class="line">  ……</span><br><span class="line">  requestManager.clear(target);</span><br><span class="line">  target.setRequest(request);</span><br><span class="line">  requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步跟踪到 requestManager.track(target, request)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">void</span> <span class="title function_">track</span><span class="params">(Target&lt;?&gt; target, Request request)</span> &#123;</span><br><span class="line">  targetTracker.track(target);</span><br><span class="line">  requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">  requests.add(request);</span><br><span class="line">  <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">    request.begin();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pendingRequests.add(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>isPaused 变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 如果此时 GlideRequests 的 Lifecycle 为 ApplicationLifecycle，只要应用存活</span><br><span class="line">   isPaused 为 <span class="literal">false</span> ，直接执行 request.begin()</span><br><span class="line"><span class="number">2.</span> 如果 GlideRequests 的 Lifecycle 是观测 Fragment 或者 Activity</span><br><span class="line">   isPaused 为<span class="literal">true</span> ,不会立即执行 request.begin()</span><br><span class="line">   当 Fragment 或者 Activity 显示到前台时通过遍历 requests 数组执行 request.begin()</span><br></pre></td></tr></table></figure>
<p>所以执行网络请求下载图片的操作在 request.begin() 之中。<br>回到 into(ImageView view) 方法的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> buildRequest(target, targetListener, options)</span><br></pre></td></tr></table></figure>
<p>经过层层包裹我们可以找到一下路线，发现最后返回的是 SingleRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buildRequest &gt;&gt; buildRequestRecursive &gt;&gt; buildThumbnailRequestRecursive</span><br><span class="line"></span><br><span class="line">&gt;&gt; obtainRequest &gt;&gt; SingleRequest</span><br></pre></td></tr></table></figure>
<p>创建 SingleRequest 的过程比较复杂，牵扯到缩略图、错误处理之类的逻辑，大致都是上面那条路径。</p>
<p>然后就看一下 SingleRequest.begin()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">begin</span><span class="params">()</span> &#123;</span><br><span class="line">  ……</span><br><span class="line">  省略一些其他分支</span><br><span class="line">  ……</span><br><span class="line">  status = Status.WAITING_FOR_SIZE;</span><br><span class="line">  <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">    onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    target.getSize(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ……</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>begin() 方法很长，我们剔除了一些异常处理，直接看最核心的方法。</p>
<p>如果我给 Glide 设置了 override() 则直接调用 onSizeReady(overrideWidth, overrideHeight)</p>
<p>否则会调用 target.getSize(this) 让 ImageView 计算自己的尺寸。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">glideContext.buildImageViewTarget(view, transcodeClass) 创建一个 DrawableImageViewTarget</span><br></pre></td></tr></table></figure>
<h2 id="Glide流程"><a href="#Glide流程" class="headerlink" title="Glide流程"></a>Glide流程</h2><img src="/images/Android/glide-liucheng.png" class="" title="glide-process">

<h2 id="Glide网络下载流程"><a href="#Glide网络下载流程" class="headerlink" title="Glide网络下载流程"></a>Glide网络下载流程</h2><img src="/images/Android/glide-netload.png" class="" title="glide-process">


<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>缓存<ul>
<li>活动资源 (Active Resources)</li>
<li>内存缓存 (Memory Cache)</li>
<li>资源类型（Resource Disk Cache）</li>
<li>原始数据 (Data Disk Cache)</li>
<li>网络缓存</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>图片加载</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage</title>
    <url>/iOS/thirdpart/sdwebimage.html</url>
    <content><![CDATA[<h1 id="SDWebImage介绍"><a href="#SDWebImage介绍" class="headerlink" title="SDWebImage介绍"></a>SDWebImage介绍</h1><ul>
<li><p>提供 UIImageView, UIButton, MKAnnotationView 的分类，用来加载网络图片，并进行缓存管理;</p>
</li>
<li><p>异步方式来下载网络图片</p>
</li>
<li><p>异步方式: memory (内存)＋ disk (磁盘) 来缓存网络图片，自动管理缓存;</p>
</li>
<li><p>后台图片解码,转换及压缩;</p>
<ul>
<li>空间换时间<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29jb2FuZXRpY3MuY29tLzIwMTEvMTAvYXZvaWRpbmctaW1hZ2UtZGVjb21wcmVzc2lvbi1zaWNrbmVzcy8=">https://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
<li><p>同一个 URL 不会重复下载;</p>
</li>
<li><p>失效的 URL 不会被无限重试;</p>
</li>
<li><p>支持 GIF动画 及 WebP 格式;</p>
</li>
<li><p>开启 子线程 进行耗时操作，不阻塞主线程;</p>
</li>
</ul>
<blockquote>
<p>下载完图片的储存发生在SDWebImageManager里面(下载operation也是这里面创建的)，可以作为提前缓存图片的方式</p>
</blockquote>
<h1 id="SDWebImageContext"><a href="#SDWebImageContext" class="headerlink" title="SDWebImageContext"></a>SDWebImageContext</h1><h2 id="SDWebImageContextSetImageOperationKey"><a href="#SDWebImageContextSetImageOperationKey" class="headerlink" title="SDWebImageContextSetImageOperationKey"></a>SDWebImageContextSetImageOperationKey</h2><ol>
<li>简单来说，这个key对应的value用于指定当前的id<SDWebImageOperation>保存在NSMapTable中的key，后续的cancel、remove都需要通过这个key来找到对应的线程。</li>
<li>当指定同一个key加载图片时会先cancel之前存在的线程。</li>
<li>SDWebImageContextSetImageOperationKey并不是在所有地方使用都生效的。</li>
</ol>
<p>比如UIButton的sd_setImageWithURL:和sd_setBackgroundImageWithURL:系列方法。</p>
<p>在其内部需要通过这个这值来保存、区分不同状态(UIControlState)的图片加载线程，所以即使设置了SDWebImageContextSetImageOperationKey也会被覆盖：</p>
<h2 id="SDWebImageContextCustomManager"><a href="#SDWebImageContextCustomManager" class="headerlink" title="SDWebImageContextCustomManager"></a>SDWebImageContextCustomManager</h2><p>可以传入一个自定义的SDWebImageManager，默认使用[SDWebImageManager sharedManager]</p>
<h2 id="SDWebImageContextImageTransformer"><a href="#SDWebImageContextImageTransformer" class="headerlink" title="SDWebImageContextImageTransformer"></a>SDWebImageContextImageTransformer</h2><p>可以传入一个id<SDImageTransformer>类型用于转换处理加载出来的图片。</p>
<ol>
<li>在SDWebImageManager中也可以设置一个id<SDImageTransformer>默认为nil，但是只有SDWebImageContext没有配置SDWebImageContextImageTransformer，才会使用它。<br>也就是配置优先级 SDWebImageContext&gt;SDWebImageManager</li>
<li>如果设置了id<SDImageTransformer>不会缓存原始图片，只缓存处理后的图片。</li>
<li>对于同个图片、不同参数的id<SDImageTransformer>会被认为是不同的图片：会产生不同的缓存文件、会重复下载。</li>
</ol>
<h2 id="SDWebImageContextImageScaleFactor"><a href="#SDWebImageContextImageScaleFactor" class="headerlink" title="SDWebImageContextImageScaleFactor"></a>SDWebImageContextImageScaleFactor</h2><p>在NSData -&gt; UIImage时对图片放大比例，是个大于1的CGFloat值，默认值：</p>
<h2 id="SDWebImageContextStoreCacheType"><a href="#SDWebImageContextStoreCacheType" class="headerlink" title="SDWebImageContextStoreCacheType"></a>SDWebImageContextStoreCacheType</h2><p>定义图片缓存规则具体看 SDImageCacheType中的定义。</p>
<h2 id="SDWebImageContextDownloadRequestModifier"><a href="#SDWebImageContextDownloadRequestModifier" class="headerlink" title="SDWebImageContextDownloadRequestModifier"></a>SDWebImageContextDownloadRequestModifier</h2><p>可以传入一个id<SDWebImageDownloaderRequestModifier>，用于在加载图片前修改NSURLRequest。</p>
<ol>
<li>SDWebImageContextDownloadRequestModifier协议比较简单，只需要实现一个方法，返回一个修改后的NSURLRequest即可：</li>
<li>内建了一个SDWebImageDownloaderRequestModifier对象，可以使用Block方便的修改NSURLRequest</li>
</ol>
<h2 id="SDWebImageContextCacheKeyFilter"><a href="#SDWebImageContextCacheKeyFilter" class="headerlink" title="SDWebImageContextCacheKeyFilter"></a>SDWebImageContextCacheKeyFilter</h2><p>可以传入一个id<SDWebImageCacheKeyFilter>，指定图片的缓存key。</p>
<ol>
<li>SDWebImageCacheKeyFilter协议也比较简单，只需要实现一个方法，返回一个对应的缓存key字符串即可</li>
</ol>
<ul>
<li>(nullable NSString *)cacheKeyForURL:(nonnull NSURL *)url;</li>
</ul>
<ol start="2">
<li>内建了一个SDWebImageCacheKeyFilter对象，可以使用Block方便的返回缓存key</li>
</ol>
<h2 id="SDWebImageContextCacheSerializer"><a href="#SDWebImageContextCacheSerializer" class="headerlink" title="SDWebImageContextCacheSerializer"></a>SDWebImageContextCacheSerializer</h2><ol>
<li>可以传入一个id<SDWebImageCacheSerializer>，转换需要缓存的图片格式。</li>
<li>在SDWebImageManager中也可以设置一个id<SDWebImageCacheSerializer>默认为nil，但是只有SDWebImageContext没有配置SDWebImageContextCacheSerializer，才会使用它。<br>也就是配置优先级 SDWebImageContext&gt;SDWebImageManager</li>
<li>通常用于需要缓存的图片格式与下载的图片格式不相符的时候，如：下载的时候为了节约流量、减少下载时间使用了WebP格式，但是如果缓存也用WebP，每次从缓存中取图片都需要经过一次解压缩，这样是比较影响性能的，就可以使用id<SDWebImageCacheSerializer>，实现其中的协议方法：</li>
</ol>
<h2 id="SDWebImageContextLoaderCachedImage"><a href="#SDWebImageContextLoaderCachedImage" class="headerlink" title="SDWebImageContextLoaderCachedImage"></a>SDWebImageContextLoaderCachedImage</h2><p>可以传入一个UIImage的缓存图像。</p>
<ol>
<li>这个值比较特殊，它是定义在SDImageLoader.m中的。</li>
<li>这个值可以认为是SDWebImage是内部用来从SDWebImageManager向SDWebImageDownloader(id<SDImageLoader>)传递缓存图像的，自定义实现SDImageLoader协议可能会用到这个值，其他情况一般不会用到。</li>
<li>这个属性只有在 SDWebImageOptions包含SDWebImageRefreshCached策略时才生效，也就是他是SDWebImageRefreshCached这个策略的配套值。</li>
<li>SDWebImageRefreshCached这个策略用于那些图片URL是静态的（图片更新时URL是不变的，SD给的例子是 Facebook graph api profile pics），这个时候它会根据HTTP header的 cache-control 字段来控制缓存并且使用NSURLCache来缓存图片，SDWebImageDownloader(id<SDImageLoader>)中判断SDWebImageContextLoaderCachedImage存在并且策略是SDWebImageRefreshCached的情况，仍然会发起请求。</li>
</ol>
<h1 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h1><ul>
<li>self.URLOperations <SDWebImageDownloaderOperation>包含所有的下载队列</li>
</ul>
<p>这句话很重要 url和callback关联dic<br> // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</p>
<p>downloadOperationCancelToken 返回绑定当前operation的callback、progressBlock, 是一个可变字典</p>
<blockquote>
<p>operation.loaderOperation = SDWebImageDownloadToken</p>
</blockquote>
<ul>
<li>addHandlersForProgress</li>
</ul>
<p>其实是向 SDWebImageDownloaderOperation 里面的callbackBlocks注册回调callback</p>
<p>SDWebImageDownloadToken 其实包含</p>
<ul>
<li>url</li>
<li>request</li>
<li>downloadOperationCancelToken (这是一个dic，又包含)<ul>
<li>callback</li>
<li>progressBlock</li>
</ul>
</li>
</ul>
<h2 id="cancel的时候"><a href="#cancel的时候" class="headerlink" title="cancel的时候"></a>cancel的时候</h2><p>其中一个队列SDWebImageDownloaderOperation，包含所有url对应的回调</p>
<ul>
<li>self.callbackBlocks </li>
</ul>
<h2 id="options参数："><a href="#options参数：" class="headerlink" title="options参数："></a>options参数：</h2><table>
<thead>
<tr>
<th>SDWebImageOptions属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SDWebImageRetryFailed</td>
<td>默认情况下，如果一个url在下载的时候失败了,那么这个url会被加入黑名单并且library不会尝试再次下载,这个flag会阻止library把失败的url加入黑名单</td>
</tr>
<tr>
<td>SDWebImageLowPriorit</td>
<td>默认情况下，图片会在交互发生的时候下载(例如你滑动tableview的时候),这个flag会禁止这个特性,导致的结果就是在scrollview减速的时候,才会开始下载</td>
</tr>
<tr>
<td>SDWebImageProgressiveLoad</td>
<td>这个flag启动渐进式下载图像，类似浏览器加载图像那样逐步显示，默认情况下，图像仅是在下载完成后显示</td>
</tr>
<tr>
<td>SDWebImageRefreshCached</td>
<td>一个图片缓存了，还是会重新请求.并且缓存侧略依据NSURLCache而不是SDWebImage。即在URL没变但是服务器图片发生更新时使用</td>
</tr>
<tr>
<td>SDWebImageContinueInBackground</td>
<td>启动后台下载，实现原理是通过向系统询问后台的额外时间来完成请求的。 如果后台任务到期，则操作将被取消。</td>
</tr>
<tr>
<td>SDWebImageHandleCookies</td>
<td>当设置了<code>NSMutableURLRequest.HTTPShouldHandleCookies = YES</code>时，可以控制存储NSHTTPCookieStorage中的cookie</td>
</tr>
<tr>
<td>SDWebImageAllowInvalidSSLCertificates</td>
<td>允许不安全的SSL证书，用于测试环境，在正式环境中谨慎使用</td>
</tr>
<tr>
<td>SDWebImageHighPriority</td>
<td>默认情况下,image在装载的时候是按照他们在队列中的顺序装载的(就是先进先出)。这个flag会把他们移动到队列的前端,并且立刻装载,而不是等到当前队列装载的时候再装载。</td>
</tr>
<tr>
<td>SDWebImageDelayPlaceholder</td>
<td>默认情况下,占位图会在图片下载的时候显示.这个flag开启会延迟占位图显示的时间,等到图片下载完成之后才会显示占位图.</td>
</tr>
<tr>
<td>SDWebImageTransformAnimatedImage</td>
<td>通常不会在可动画的图像上调用 <code>transformDownloadedImage</code> 代理方法，因为大多数转换代码会破坏动画文件，这个flag为尝试转换</td>
</tr>
<tr>
<td>SDWebImageAvoidAutoSetImage</td>
<td>图片在下载后被加载到imageView。但是在一些情况下，我们想要设置一下图片（引用一个滤镜或者加入透入动画）这个flag来手动的设置图片在下载图片成功后</td>
</tr>
<tr>
<td>SDWebImageScaleDownLargeImages</td>
<td>默认情况下，图像将根据其原始大小进行解码。 在iOS上，此flat会将图片缩小到与设备的受限内存兼容的大小。    但如果设置了<code>SDWebImageAvoidDecodeImage</code>则此flat不起作用。 如果设置了<code>SDWebImageProgressiveLoad</code>它将被忽略。</td>
</tr>
<tr>
<td>SDWebImageQueryMemoryData</td>
<td>默认情况下，当图像已缓存在内存中时，我们不会查询图像数据。 此flat则强制查询图像数据。 此查询是异步的，除非指定<code>SDWebImageQueryMemoryDataSync</code></td>
</tr>
<tr>
<td>SDWebImageQueryMemoryDataSync</td>
<td>结合<code>SDWebImageQueryMemoryData</code>设置同步查询图像数据（一般不建议这么使用，除非是在同一个<code>runloop</code>里避免单元格复用时发生闪现）</td>
</tr>
<tr>
<td>SDWebImageQueryDiskDataSync</td>
<td>如果内存查询没有的时候，强制同步磁盘查询（这三个查询可以组合使用，一般不建议这么使用，除非是在同一个<code>runloop</code>里避免单元格复用时发生闪现）</td>
</tr>
<tr>
<td>SDWebImageFromCacheOnly</td>
<td>默认情况下，当缓存丢失时，SD将从网络下载图像。 此flat可以防止这样，使其仅从缓存加载。</td>
</tr>
<tr>
<td>SDWebImageFromLoaderOnly</td>
<td>默认情况下，SD在下载之前先从缓存中查找，此flat可以防止这样，使其仅从网络下载</td>
</tr>
<tr>
<td>SDWebImageForceTransition</td>
<td>默认情况下，SD在图像加载完成后使用<code>SDWebImageTransition</code>进行某些视图转换，此转换仅适用于从网络下载图像。 此flat可以强制为内存和磁盘缓存应用视图转换。</td>
</tr>
<tr>
<td>SDWebImageAvoidDecodeImage</td>
<td>默认情况下，SD在查询缓存和从网络下载时会在后台解码图像，这有助于提高性能，因为在屏幕上渲染图像时，需要首先对其进行解码。这发生在<code>Core Animation</code>的主队列中。然而此过程也可能会增加内存使用量。 如果由于过多的内存消耗而遇到问题，可以用此flat禁止解码图像。</td>
</tr>
<tr>
<td>SDWebImageDecodeFirstFrameOnly</td>
<td>默认情况下，SD会解码动画图像，该flat强制只解码第一帧并生成静态图。</td>
</tr>
<tr>
<td>SDWebImagePreloadAllFrames</td>
<td>默认情况下，对于<code>SDAnimatedImage</code>，SD会在渲染过程中解码动画图像帧以减少内存使用量。 但是用户可以指定将所有帧预加载到内存中，以便在大量imageView共享动画图像时降低CPU使用率。这实际上会在后台队列中触发<code>preloadAllAnimatedImageFrames</code>（仅限磁盘缓存和下载）。</td>
</tr>
</tbody></table>
<h1 id="SDImageTransformer的类型"><a href="#SDImageTransformer的类型" class="headerlink" title="SDImageTransformer的类型"></a>SDImageTransformer的类型</h1><h1 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h1><p>NSCache</p>
<ul>
<li>自动删除机制：当系统内存紧张时，NSCache会自动删除一些缓存对象</li>
<li>线程安全：从不同线程中对同一个 NSCache 对象进行增删改查时，不需要加锁</li>
<li>不同于 NSMutableDictionary，NSCache存储对象时不会对 key 进行 copy 操作</li>
</ul>
<h1 id="小Tip"><a href="#小Tip" class="headerlink" title="小Tip"></a>小Tip</h1><ol>
<li>运行时存取关联对象：</li>
<li>数组的写操作需要加锁（多线程访问，避免覆写）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//给self.runningOperations加锁</span><br><span class="line">//self.runningOperations数组的添加操作</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//self.runningOperations数组的删除操作</span><br><span class="line">- (void)safelyRemoveOperationFromRunning:(nullable SDWebImageCombinedOperation*)operation &#123;</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        if (operation) &#123;</span><br><span class="line">            [self.runningOperations removeObject:operation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>确保在主线程的宏：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_main_async_safe(^&#123;</span><br><span class="line">                  //将下面这段代码放在主线程中</span><br><span class="line">            [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">//宏定义：</span><br><span class="line">#define dispatch_main_async_safe(block)\</span><br><span class="line">    if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></li>
<li>设置不能为nil的参数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (nonnull instancetype)initWithCache:(nonnull SDImageCache *)cache downloader:(nonnull SDWebImageDownloader *)downloader &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        _imageCache = cache;</span><br><span class="line">        _imageDownloader = downloader;</span><br><span class="line">        _failedURLs = [NSMutableSet new];</span><br><span class="line">        _runningOperations = [NSMutableArray new];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>容错，强制转换类型<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="UIImageView分类方法，分流到了UIView的分类方法，注释如下"><a href="#UIImageView分类方法，分流到了UIView的分类方法，注释如下" class="headerlink" title="UIImageView分类方法，分流到了UIView的分类方法，注释如下"></a>UIImageView分类方法，分流到了UIView的分类方法，注释如下</h1><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	使用图片的 URL 和可选的 placeholder image 设置 imageView 的 image </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	下载是异步和缓存的</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	@param url image的URL</span></span><br><span class="line"><span class="comment">	@param placeholder 初始图像，直至image数据请求完成</span></span><br><span class="line"><span class="comment">	@param options image下载的时候的选择项-SDWebImageOptions，下方有详细介绍</span></span><br><span class="line"><span class="comment">	@param context 为了补充options枚举没有的选择想，下方有详细介绍</span></span><br><span class="line"><span class="comment">	@param setImageBlock 用于自定义设置image</span></span><br><span class="line"><span class="comment">	@param progressBlock 在图片下载ing状态调用，注：在后台队列上执行</span></span><br><span class="line"><span class="comment">	@param completedBlock 在操作完成后调用，返回类型为</span></span><br><span class="line"><span class="comment">	completedBlock(image, data, error, cacheType, finished, url)</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                           context:(<span class="keyword">nullable</span> SDWebImageContext *)context</span><br><span class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(<span class="keyword">nullable</span> SDImageLoaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">//将可变对象copy为不可变的</span></span><br><span class="line">    context = [context <span class="keyword">copy</span>]; <span class="comment">// copy to avoid mutable object</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取出context设置中的operationKey</span></span><br><span class="line">    <span class="built_in">NSString</span> *validOperationKey = context[SDWebImageContextSetImageOperationKey];</span><br><span class="line">    <span class="comment">//如果operationKey为nil，就采用他自身的类的字符串作为key</span></span><br><span class="line">    <span class="keyword">if</span> (!validOperationKey) &#123;</span><br><span class="line">        validOperationKey = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取消之前绑定的operation，保证没有当前正在进行的异步下载操作, 使它不会与即将进行的操作发生冲突</span></span><br><span class="line">    [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:validOperationKey];</span><br><span class="line">    <span class="comment">//为自身绑定一个URL</span></span><br><span class="line">    <span class="keyword">self</span>.sd_imageURL = url;</span><br><span class="line">    <span class="comment">//如果不是延迟显示placeholder的情况</span></span><br><span class="line">    <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">    	 <span class="comment">//dispatch_main_async_safe 异步线程安全，下面有源码介绍</span></span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">        	 <span class="comment">//在图片下载下来之前，添加临时的占位图</span></span><br><span class="line">            [<span class="keyword">self</span> sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock cacheType:SDImageCacheTypeNone imageURL:url];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        <span class="comment">// reset the progress</span></span><br><span class="line">        <span class="keyword">self</span>.sd_imageProgress.totalUnitCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">self</span>.sd_imageProgress.completedUnitCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SD_UIKIT || SD_MAC</span></span><br><span class="line">        <span class="comment">// check and start image indicator</span></span><br><span class="line">        <span class="comment">// 检查是否设置了image indicator，如果有则启动，下面有方法的源码</span></span><br><span class="line">        [<span class="keyword">self</span> sd_startImageIndicator];</span><br><span class="line">        <span class="type">id</span>&lt;SDWebImageIndicator&gt; imageIndicator = <span class="keyword">self</span>.sd_imageIndicator;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 判断context中是否自定义了manager，如果没有则使用默认的</span></span><br><span class="line">        SDWebImageManager *manager = context[SDWebImageContextCustomManager];</span><br><span class="line">        <span class="keyword">if</span> (!manager) &#123;</span><br><span class="line">            manager = [SDWebImageManager sharedManager];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置image加载进度Block（已接收size，预计总size，image的URL）</span></span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</span><br><span class="line">        SDImageLoaderProgressBlock combinedProgressBlock = ^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize, <span class="built_in">NSURL</span> * _Nullable targetURL) &#123;</span><br><span class="line">        	<span class="comment">// 使用__strong __typeof是防止self在这个执行过程中释放，下方有详细介绍</span></span><br><span class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</span><br><span class="line">            <span class="built_in">NSProgress</span> *imageProgress = sself.sd_imageProgress;</span><br><span class="line">            imageProgress.totalUnitCount = expectedSize;</span><br><span class="line">            imageProgress.completedUnitCount = receivedSize;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SD_UIKIT || SD_MAC</span></span><br><span class="line">				<span class="comment">//加载指示器是否实现了updateIndicatorProgress方法</span></span><br><span class="line">            <span class="keyword">if</span> ([imageIndicator respondsToSelector:<span class="keyword">@selector</span>(updateIndicatorProgress:)]) &#123;</span><br><span class="line">                <span class="type">double</span> progress = imageProgress.fractionCompleted;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [imageIndicator updateIndicatorProgress:progress];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>			<span class="comment">//返回image加载进度Block</span></span></span><br><span class="line">            <span class="keyword">if</span> (progressBlock) &#123;</span><br><span class="line">                progressBlock(receivedSize, expectedSize, targetURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//下载图片</span></span><br><span class="line">        <span class="type">id</span> &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options context:context progress:combinedProgressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="type">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</span><br><span class="line">            <span class="keyword">if</span> (!sself) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// 如果progress没有更新，则标记其为完成状态</span></span><br><span class="line">            <span class="keyword">if</span> (finished &amp;&amp; !error &amp;&amp; sself.sd_imageProgress.totalUnitCount == <span class="number">0</span> &amp;&amp; sself.sd_imageProgress.completedUnitCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//const int64_t SDWebImageProgressUnitCountUnknown = 1LL; （LL是 long long 类型的缩写）</span></span><br><span class="line">                sself.sd_imageProgress.totalUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">                sself.sd_imageProgress.completedUnitCount = SDWebImageProgressUnitCountUnknown;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SD_UIKIT || SD_MAC</span></span><br><span class="line">            <span class="comment">// 检查并停止 image indicator</span></span><br><span class="line">            <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                [<span class="keyword">self</span> sd_stopImageIndicator];</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="comment">// 下载完成后是否自动加载图片 (options &amp; SDWebImageAvoidAutoSetImage)根据枚举名取枚举中的值，get了</span></span><br><span class="line">            <span class="type">BOOL</span> shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);</span><br><span class="line">            <span class="type">BOOL</span> shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</span><br><span class="line">                                      (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</span><br><span class="line">            SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (!sself) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">                <span class="keyword">if</span> (!shouldNotSetImage) &#123;</span><br><span class="line">                    [sself sd_setNeedsLayout];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置completedBlock</span></span><br><span class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">                    completedBlock(image, data, error, cacheType, finished, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// case 1a: we got an image, but the SDWebImageAvoidAutoSetImage flag is set</span></span><br><span class="line">            <span class="comment">// OR</span></span><br><span class="line">            <span class="comment">// case 1b: we got no image and the SDWebImageDelayPlaceholder is not set</span></span><br><span class="line">            <span class="keyword">if</span> (shouldNotSetImage) &#123;</span><br><span class="line">                dispatch_main_async_safe(callCompletedBlockClojure);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">UIImage</span> *targetImage = <span class="literal">nil</span>;</span><br><span class="line">            <span class="built_in">NSData</span> *targetData = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="comment">// case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set</span></span><br><span class="line">                targetImage = image;</span><br><span class="line">                targetData = data;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDelayPlaceholder) &#123;</span><br><span class="line">                <span class="comment">// case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set</span></span><br><span class="line">                targetImage = placeholder;</span><br><span class="line">                targetData = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SD_UIKIT || SD_MAC</span></span><br><span class="line">            <span class="comment">// check whether we should use the image transition</span></span><br><span class="line">            <span class="comment">// 检查image的过渡动画效果</span></span><br><span class="line">            SDWebImageTransition *transition = <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">if</span> (finished &amp;&amp; (options &amp; SDWebImageForceTransition || cacheType == SDImageCacheTypeNone)) &#123;</span><br><span class="line">                transition = sself.sd_imageTransition;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">				<span class="comment">// 设置image的过渡动画效果</span></span><br><span class="line">            dispatch_main_async_safe(^&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SD_UIKIT || SD_MAC</span></span><br><span class="line">                [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock transition:transition cacheType:cacheType imageURL:imageURL];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock cacheType:cacheType imageURL:imageURL];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                callCompletedBlockClojure();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="comment">//在操作缓存字典（operationDictionary）里添加operation，表示当前的操作正在进行，源码见下</span></span><br><span class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="comment">// 没有url，停止Image Indicator</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SD_UIKIT || SD_MAC</span></span><br><span class="line">        [<span class="keyword">self</span> sd_stopImageIndicator];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">                <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidURL userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@&quot;Image url is nil&quot;</span>&#125;];</span><br><span class="line">                completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, error, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
        <category>Third-Party Lib</category>
        <category>SDWebImage</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
</search>
